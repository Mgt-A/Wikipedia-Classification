<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Recursion (computer science),Articles with unsourced statements since May 2008,Ackermann function,Anonymous recursion,Binary search,Binary search tree,Binary tree,C (programming language),Call stack,Compiler,Computability theory (computer science)" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Recursion (computer science) - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Recursion_(computer_science)";
		var wgTitle = "Recursion (computer science)";
		var wgAction = "view";
		var wgArticleId = "4044867";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 281278816;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
</style>		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Recursion_computer_science skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Recursion (computer science)</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p><b>Recursion</b> in <a href="/wiki/Computer_science" title="Computer science">computer science</a> is a way of thinking about and solving problems. In fact, <strong class="selflink">recursion</strong> is one of the central ideas of computer science. <sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup> Solving a problem using recursion means the solution depends on solutions to smaller instances of the same problem. <sup id="cite_ref-1" class="reference"><a href="#cite_note-1" title=""><span>[</span>2<span>]</span></a></sup></p>
<blockquote>
<p>"The power of recursion evidently lies in the possibility of defining an infinite set of objects by a finite statement. In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions." <sup id="cite_ref-2" class="reference"><a href="#cite_note-2" title=""><span>[</span>3<span>]</span></a></sup></p>
</blockquote>
<p>Most high-level computer programming languages support recursion by allowing a function to call itself within the program text. <a href="/wiki/Imperative_languages" title="Imperative languages" class="mw-redirect">Imperative languages</a> define looping constructs like “while” and “for” loops that are used to perform repetitive actions. Some <a href="/wiki/Functional_languages" title="Functional languages" class="mw-redirect">functional programming languages</a> do not define any looping constructs but rely solely on recursion to repeatedly call code. <a href="/wiki/Computability_theory_(computer_science)" title="Computability theory (computer science)">Computability theory</a> has proven that these recursive only languages are mathematically equivalent to the imperative languages, meaning they can solve the same kinds of problems even without the typical control structures like “while” and “for”.<br /></p>
<div class="thumb tright">
<div class="thumbinner" style="width:182px;"><a href="/wiki/File:RecursiveTree.JPG" class="image" title="Tree created using the Logo programming language and relying heavily on recursion."><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/RecursiveTree.JPG/180px-RecursiveTree.JPG" width="180" height="237" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:RecursiveTree.JPG" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Tree created using the <a href="/wiki/Logo_(programming_language)" title="Logo (programming language)">Logo programming language</a> and relying heavily on recursion.</div>
</div>
</div>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Recursive_algorithms"><span class="tocnumber">1</span> <span class="toctext">Recursive algorithms</span></a></li>
<li class="toclevel-1"><a href="#Recursive_programming"><span class="tocnumber">2</span> <span class="toctext">Recursive programming</span></a>
<ul>
<li class="toclevel-2"><a href="#Recursive_procedures_.28generative_recursion.29"><span class="tocnumber">2.1</span> <span class="toctext">Recursive procedures (generative recursion)</span></a>
<ul>
<li class="toclevel-3"><a href="#Factorial"><span class="tocnumber">2.1.1</span> <span class="toctext">Factorial</span></a></li>
<li class="toclevel-3"><a href="#Fibonacci"><span class="tocnumber">2.1.2</span> <span class="toctext">Fibonacci</span></a></li>
<li class="toclevel-3"><a href="#Greatest_common_divisor"><span class="tocnumber">2.1.3</span> <span class="toctext">Greatest common divisor</span></a></li>
<li class="toclevel-3"><a href="#Towers_of_Hanoi"><span class="tocnumber">2.1.4</span> <span class="toctext">Towers of Hanoi</span></a></li>
<li class="toclevel-3"><a href="#Binary_search"><span class="tocnumber">2.1.5</span> <span class="toctext">Binary search</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Recursive_data_structures_.28structural_recursion.29"><span class="tocnumber">2.2</span> <span class="toctext">Recursive data structures (structural recursion)</span></a>
<ul>
<li class="toclevel-3"><a href="#Linked_lists"><span class="tocnumber">2.2.1</span> <span class="toctext">Linked lists</span></a></li>
<li class="toclevel-3"><a href="#Binary_trees"><span class="tocnumber">2.2.2</span> <span class="toctext">Binary trees</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Recursion_versus_iteration"><span class="tocnumber">2.3</span> <span class="toctext">Recursion versus iteration</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Tail-recursive_functions"><span class="tocnumber">3</span> <span class="toctext">Tail-recursive functions</span></a></li>
<li class="toclevel-1"><a href="#Order_of_function_calling"><span class="tocnumber">4</span> <span class="toctext">Order of function calling</span></a>
<ul>
<li class="toclevel-2"><a href="#Function_1"><span class="tocnumber">4.1</span> <span class="toctext">Function 1</span></a></li>
<li class="toclevel-2"><a href="#Function_2_with_swapped_lines"><span class="tocnumber">4.2</span> <span class="toctext">Function 2 with swapped lines</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Direct_and_indirect_recursion"><span class="tocnumber">5</span> <span class="toctext">Direct and indirect recursion</span></a></li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#Notes_and_References"><span class="tocnumber">7</span> <span class="toctext">Notes and References</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">8</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Recursive_algorithms" id="Recursive_algorithms"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Recursive algorithms">edit</a>]</span> <span class="mw-headline">Recursive algorithms</span></h2>
<p>A common method of simplification is to divide a problem into sub-problems of the same type. This is known as dialecting. As a <a href="/wiki/Computer_programming" title="Computer programming">computer programming</a> technique, this is called <a href="/wiki/Divide_and_conquer_algorithm" title="Divide and conquer algorithm">divide and conquer</a>, and it is key to the design of many important algorithms, as well as a fundamental part of <a href="/wiki/Dynamic_programming" title="Dynamic programming">dynamic programming</a>.</p>
<p>Virtually all <a href="/wiki/Programming_language" title="Programming language">programming languages</a> in use today allow the direct specification of recursive functions and procedures. When such a function is called, the computer (for most languages on most stack-based architectures) or the language implementation keeps track of the various instances of the function (on many architectures, by using a <a href="/wiki/Call_stack" title="Call stack">call stack</a>, although other methods may be used). Conversely, every recursive function can be transformed into an iterative function by using a <a href="/wiki/Stack_(data_structure)" title="Stack (data structure)">stack</a>.</p>
<p>Most (but not all) functions and procedures that can be evaluated by a computer can be expressed in terms of a recursive function (without having to use pure <a href="/wiki/Iteration" title="Iteration">iteration</a>),<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since May 2008" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup> in <a href="/wiki/Continuation-passing_style" title="Continuation-passing style">continuation-passing style</a>; conversely any recursive function can be expressed in terms of (pure) iteration, since recursion in itself is iterative too.<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since May 2008" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup> In order to evaluate a function by means of recursion, it has to be defined as a function of itself (e.g. the factorial n! = n * (n - 1)! , where 0! is defined as 1). Clearly thus, not all function evaluations lend themselves to a recursive approach. In general, all non-infinite functions can be described recursively directly; infinite functions (e.g. the series for e = 1/1! + 2/2! + 3/3!...) need an extra 'stopping criterion', e.g. the number of iterations, or the number of significant digits, because otherwise recursive iteration would result in an <a href="/wiki/Infinite_loop" title="Infinite loop">endless loop</a>.</p>
<p>To give a very literal example of this: If an unknown word is seen in a book, the reader can make a note of the current page number and put the note on a stack (which is empty so far). The reader can then look the new word up and, while reading on the subject, may find yet another unknown word. The page number of this word is also written down and put on top of the stack. At some point an article is read that does not require any explanation. The reader then returns to the previous page number and continues reading from there. This is repeated, sequentially removing the topmost note from the stack. Finally, the reader returns to the original book. This is a recursive approach.</p>
<p>Some languages designed for <a href="/wiki/Logic_programming" title="Logic programming">logic programming</a> and <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a> provide recursion as the only means of repetition directly available to the programmer. Such languages generally make <a href="/wiki/Tail_recursion" title="Tail recursion">tail recursion</a> as efficient as iteration, letting programmers express other repetition structures (such as <a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a>'s <code>map</code> and <code>for</code>) in terms of recursion.</p>
<p>Recursion is deeply embedded in the <a href="/wiki/Theory_of_computation" title="Theory of computation">theory of computation</a>, with the theoretical equivalence of <a href="/wiki/%CE%9C-recursive_function" title="Μ-recursive function">μ-recursive functions</a> and <a href="/wiki/Turing_machine" title="Turing machine">Turing machines</a> at the foundation of ideas about the universality of the modern computer.</p>
<p><a name="Recursive_programming" id="Recursive_programming"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Recursive programming">edit</a>]</span> <span class="mw-headline">Recursive programming</span></h2>
<p>Creating a recursive procedure essentially requires defining a "base case", and then defining rules to break down more complex cases into the base case. Key to a recursive procedure is that with each recursive call, the problem domain must be reduced in such a way that eventually the base case is arrived at.</p>
<p>Some authors classify recursion as either "generative" or "structural". The distinction is made based on where the procedure gets the data that it works on. If the data comes from a data structure like a list, then the procedure is "structurally recursive"; otherwise, it is "generatively recursive".<sup id="cite_ref-3" class="reference"><a href="#cite_note-3" title=""><span>[</span>4<span>]</span></a></sup></p>
<blockquote>
<p>Many well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it. HTDP (How To Design Programs) refers to this kind as generative recursion. Examples of generative recursion include: <a href="/wiki/Greatest_common_divisor" title="Greatest common divisor">gcd</a>, <a href="/wiki/Quicksort" title="Quicksort">quicksort</a>, <a href="/wiki/Binary_search" title="Binary search" class="mw-redirect">binary search</a>, <a href="/wiki/Mergesort" title="Mergesort" class="mw-redirect">mergesort</a>, <a href="/wiki/Newton%27s_method" title="Newton's method">Newton's method</a>, <a href="/wiki/Fractal" title="Fractal">fractals</a>, and <a href="/w/index.php?title=Adaptive_integration&amp;action=edit&amp;redlink=1" class="new" title="Adaptive integration (page does not exist)">adaptive integration</a>.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4" title=""><span>[</span>5<span>]</span></a></sup></p>
</blockquote>
<p><a name="Recursive_procedures_.28generative_recursion.29" id="Recursive_procedures_.28generative_recursion.29"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Recursive procedures (generative recursion)">edit</a>]</span> <span class="mw-headline">Recursive procedures (generative recursion)</span></h3>
<p><a name="Factorial" id="Factorial"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Factorial">edit</a>]</span> <span class="mw-headline">Factorial</span></h4>
<p>A classic example of a recursive procedure is the function used to calculate the <a href="/wiki/Factorial" title="Factorial">factorial</a> of an <a href="/wiki/Integer" title="Integer">integer</a>.</p>
<p><i>Function definition</i>:</p>
<dl>
<dd><img class="tex" alt=" \operatorname{fact}(n) =
 \begin{cases}
 1 &amp; \mbox{if } n = 0 \\
 n \cdot \operatorname{fact}(n-1) &amp; \mbox{if } n &gt; 0 \\
 \end{cases}
" src="http://upload.wikimedia.org/math/e/a/5/ea544e35fae4b89d25d8dfae229a051e.png" /></dd>
</dl>
<table class="wikitable">
<tr>
<th><a href="/wiki/Pseudocode" title="Pseudocode">Pseudocode</a> (recursive):</th>
</tr>
<tr>
<td>
<pre>
<b>function</b> factorial is:<br /><b>input</b>: integer <i>n</i> such that <i>n</i> &gt;= 0<br /><b>output</b>: [<i>n</i> × (<i>n</i>-1) × (<i>n</i>-2) × … × 1]
<br />    1. if <i>n</i> is 0, <b>return</b> 1
    2. otherwise, <b>return</b> [ <i>n</i> × factorial(<i>n</i>-1) ]
<br /><b>end</b> factorial
</pre></td>
</tr>
</table>
<p><br />
A <a href="/wiki/Recurrence_relation" title="Recurrence relation">recurrence relation</a> is an equation that relates later terms in the sequence to earlier terms<sup id="cite_ref-5" class="reference"><a href="#cite_note-5" title=""><span>[</span>6<span>]</span></a></sup>.</p>
<p><i>Recurrence relation for factorial</i>:</p>
<dl>
<dd><span class="texhtml"><i>b</i><sub><i>n</i></sub> = <i>n</i><i>b</i><sub><i>n</i> − 1</sub></span></dd>
<dd><span class="texhtml"><i>b</i><sub>0</sub> = 1</span></dd>
</dl>
<table class="wikitable">
<tr>
<th>Computing the recurrence relation for n = 4:</th>
</tr>
<tr>
<td>
<pre>
b<sub>4</sub>           = 4 * b<sub>3</sub><br />             = 4 * 3 * b<sub>2</sub>
             = 4 * 3 * 2 * b<sub>1</sub>
             = 4 * 3 * 2 * 1 * b<sub>0</sub>
             = 4 * 3 * 2 * 1 * 1
             = 4 * 3 * 2 * 1
             = 4 * 3 * 2
             = 4 * 6
             = 24
</pre></td>
</tr>
</table>
<p><br /></p>
<p>This factorial function can also be described without using recursion by making use of the typical looping constructs found in imperative programming languages:</p>
<table class="wikitable">
<tr>
<th><a href="/wiki/Pseudocode" title="Pseudocode">Pseudocode</a> (iterative):</th>
</tr>
<tr>
<td>
<pre>
<b>function</b> factorial is:<br /><b>input</b>: integer <i>n</i> such that <i>n</i> &gt;= 0<br /><b>output</b>: [<i>n</i> × (<i>n</i>-1) × (<i>n</i>-2) × … × 1]
<br />    1. <b>create</b> new variable called <i>running_total</i> with a value of 1
<br />    2. <b>begin</b> loop
          1. if <i>n</i> is 0, <b>exit</b> loop
          2. <b>set</b> <i>running_total</i> to (<i>running_total</i> × <i>n</i>)
          3. <b>decrement</b> <i>n</i>
          4. <b>repeat</b> loop
<br />    3. <b>return</b> <i>running_total</i>
<br /><b>end</b> factorial
</pre></td>
</tr>
</table>
<p><a href="/wiki/Scheme_(programming_language)" title="Scheme (programming language)">Scheme</a>, however, is a <a href="/wiki/Functional_programming_language" title="Functional programming language" class="mw-redirect">functional programming language</a> and does not define any looping constructs. It relies solely upon recursion to perform all looping. Because Scheme is tail-recursive, a recursive procedure can be defined that implements the factorial procedure as an iterative process — meaning that it uses constant space but linear time.</p>
<p><a name="Fibonacci" id="Fibonacci"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Fibonacci">edit</a>]</span> <span class="mw-headline">Fibonacci</span></h4>
<p>Another well known recursive sequence is the <a href="/wiki/Fibonacci_number" title="Fibonacci number">Fibonacci numbers</a>. The first few elements of this sequence are: 0, 1, 1, 2, 3, 5, 8, 13, 21...</p>
<p>Function definition: <img class="tex" alt=" fib(n) =
 \begin{cases}
 0 &amp; \mbox{if } n = 0 \\
 1 &amp; \mbox{if } n = 1 \\
 fib(n-1) + fib(n-2) &amp; \mbox{if } n &gt;= 2  \\
 \end{cases}
" src="http://upload.wikimedia.org/math/6/4/1/641cfaf770e827d00de07ea38d67a409.png" /></p>
<table class="wikitable">
<tr>
<th><a href="/wiki/Pseudocode" title="Pseudocode">Pseudocode</a></th>
</tr>
<tr>
<td>
<pre>
<b>function</b> fib is:
<b>input</b>: integer n such that n &gt;= 0
<br />    1. if n is 0, <b>return</b> 0
    2. if n is 1, <b>return</b> 1
    3. otherwise, <b>return</b> [ fib(n-1) + fib(n-2) ]
<br /><b>end</b> fib
</pre></td>
</tr>
</table>
<p><a href="/wiki/Recurrence_relation" title="Recurrence relation">Recurrence relation</a> for Fibonacci:<br />
b<sub>n</sub> = b<sub>n-1</sub> + b<sub>n-2</sub><br />
b<sub>1</sub> = 1, b<sub>0</sub> = 0</p>
<table class="wikitable">
<tr>
<th>Computing the recurrence relation for n = 4:</th>
</tr>
<tr>
<td>
<pre>
  b<sub>4</sub>            = b<sub>3</sub> + b<sub>2</sub>
                = b<sub>2</sub> + b<sub>1</sub> + b<sub>1</sub> + b<sub>0</sub>
                = b<sub>1</sub> + b<sub>0</sub> + 1 + 1 + 0
                = 1 + 0 + 1 + 1 + 0
                = 3
</pre></td>
</tr>
</table>
<p>This Fibonacci algorithm is especially bad because each time the function is executed, it will make two function calls to itself each of which in turn makes two more function calls and so on until they "bottom out" at 1 or 0. This is an example of "tree recursion", and grows exponentially in time and linearly in space requirements.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6" title=""><span>[</span>7<span>]</span></a></sup></p>
<p><a name="Greatest_common_divisor" id="Greatest_common_divisor"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Greatest common divisor">edit</a>]</span> <span class="mw-headline">Greatest common divisor</span></h4>
<p>Another famous recursive function is the <a href="/wiki/Euclidean_algorithm" title="Euclidean algorithm">Euclidean algorithm</a>, used to compute the <a href="/wiki/Greatest_common_divisor" title="Greatest common divisor">greatest common divisor</a> of two integers. Function definition<i>:</i></p>
<dl>
<dd><img class="tex" alt=" \gcd(x,y) =
 \begin{cases}
 x &amp; \mbox{if } y = 0 \\
 \gcd(y, \operatorname{remainder}(x,y)) &amp; \mbox{if } x \ge y \mbox{ and } y &gt; 0 \\
 \end{cases}
" src="http://upload.wikimedia.org/math/0/9/8/098fa56652ecd6d3dda870628bee9e74.png" /><br /></dd>
</dl>
<table class="wikitable">
<tr>
<th><a href="/wiki/Pseudocode" title="Pseudocode">Pseudocode</a> (recursive):</th>
</tr>
<tr>
<td>
<pre>
<b>function</b> gcd is:
<b>input</b>: integer <i>x</i>, integer <i>y</i> such that <i>x</i> &gt;= <i>y</i> and <i>y</i> &gt; 0
<br />    1. if <i>y</i> is 0, <b>return</b> <i>x</i>
    2. otherwise, <b>return</b> [ gcd( <i>y</i>, (remainder of <i>x</i>/<i>y</i>) ) ]
<br /><b>end</b> gcd
</pre></td>
</tr>
</table>
<p><i>Recurrence relation for greatest common divisor</i>, where <span class="texhtml"><i>x</i>%<i>y</i></span> expresses the remainder of <span class="texhtml"><i>x</i> / <i>y</i></span>:</p>
<dl>
<dd><span class="texhtml">gcd(<i>x</i>,<i>y</i>) = gcd(<i>y</i>,<i>x</i>%<i>y</i>)</span></dd>
<dd><span class="texhtml">gcd(<i>x</i>,0) = <i>x</i></span></dd>
</dl>
<table class="wikitable">
<tr>
<th>Computing the recurrence relation for x = 27 and y = 9:</th>
</tr>
<tr>
<td>
<pre>
gcd(27, 9)   = gcd(9, 27 % 9)
             = gcd(9, 0)
             = 9
</pre></td>
</tr>
<tr>
<th>Computing the recurrence relation for x = 259 and y = 111:</th>
</tr>
<tr>
<td>
<pre>
gcd(259, 111)   = gcd(111, 259 % 111)
                = gcd(111, 37)
                = gcd(37, 0)
                = 37
</pre></td>
</tr>
</table>
<p>Notice that the "recursive" algorithm above is in fact merely tail-recursive, which means it is equivalent to an iterative algorithm. Below is the same algorithm using explicit iteration. It does not accumulate a chain of deferred operations; rather, its state is maintained entirely in the variables <i>x</i> and <i>y</i>. Its "number of steps grows the as the logarithm of the numbers involved."<sup id="cite_ref-7" class="reference"><a href="#cite_note-7" title=""><span>[</span>8<span>]</span></a></sup></p>
<table class="wikitable">
<tr>
<th><a href="/wiki/Pseudocode" title="Pseudocode">Pseudocode</a> (iterative):</th>
</tr>
<tr>
<td>
<pre>
<b>function</b> gcd is:<br /><b>input</b>: integer <i>x</i>, integer <i>y</i> such that <i>x</i> &gt;= <i>y</i> and <i>y</i> &gt; 0
<br />    1. <b>create</b> new variable called <i>remainder</i>
<br />    2. <b>begin</b> loop
          1. if <i>y</i> is zero, <b>exit</b> loop
          2. <b>set</b> <i>remainder</i> to the remainder of x/y
          3. <b>set</b> x to y
          4. <b>set</b> y to <i>remainder</i>
          5. <b>repeat</b> loop
<br />    3. <b>return</b> <i>x</i>
<br /><b>end</b> gcd
</pre></td>
</tr>
</table>
<p>The iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.</p>
<p><a name="Towers_of_Hanoi" id="Towers_of_Hanoi"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: Towers of Hanoi">edit</a>]</span> <span class="mw-headline">Towers of Hanoi</span></h4>
<div class="rellink noprint relarticle mainarticle">Main article: <a href="/wiki/Towers_of_Hanoi" title="Towers of Hanoi" class="mw-redirect">Towers of Hanoi</a></div>
<p>For a full discussion of this problem's description, history and solution see the main article or one of the many references.<sup id="cite_ref-8" class="reference"><a href="#cite_note-8" title=""><span>[</span>9<span>]</span></a></sup> <sup id="cite_ref-9" class="reference"><a href="#cite_note-9" title=""><span>[</span>10<span>]</span></a></sup> Simply put the problem is this: given three pegs, one with a set of N disks of increasing size, determine the minimum (optimal) number of steps it takes to move all the disks from their initial position to another peg without placing a larger disk on top of a smaller one.</p>
<p><i>Function definition</i>:</p>
<dl>
<dd><img class="tex" alt=" \operatorname{hanoi}(n) =
 \begin{cases}
 1 &amp; \mbox{if } n = 1 \\
 2\cdot\operatorname{hanoi}(n-1) + 1 &amp; \mbox{if } n &gt; 1\\
 \end{cases}
" src="http://upload.wikimedia.org/math/a/4/e/a4e0ab55a595deaedab73eaa9e812a22.png" /></dd>
</dl>
<p><i>Recurrence relation for hanoi</i>:</p>
<dl>
<dd><span class="texhtml"><i>h</i><sub><i>n</i></sub> = 2<i>h</i><sub><i>n</i> − 1</sub> + 1</span></dd>
<dd><span class="texhtml"><i>h</i><sub>1</sub> = 1</span></dd>
</dl>
<table class="wikitable">
<tr>
<th>Computing the recurrence relation for n = 4:</th>
</tr>
<tr>
<td>
<pre>
hanoi(4)     = 2*hanoi(3) + 1
             = 2*(2*hanoi(2) + 1) + 1
             = 2*(2*(2*hanoi(1) + 1) + 1) + 1
             = 2*(2*(2*1 + 1) + 1) + 1
             = 2*(2*(3) + 1) + 1
             = 2*(7) + 1
             = 15
</pre></td>
</tr>
</table>
<p><br />
Example Implementations:</p>
<table class="wikitable">
<tr>
<th><a href="/wiki/Pseudocode" title="Pseudocode">Pseudocode</a> (recursive):</th>
</tr>
<tr>
<td>
<pre>
<b>function</b> hanoi is:<br /><b>input</b>: integer <i>n</i>, such that <i>n</i> &gt;= <i>1</i>
<br />    1. <b>if</b> n is 1 <b>then return</b> 1
<br />    2. <b>return</b> [2 * [<b>call</b> hanoi(n-1)] + 1]
<br /><b>end</b> hanoi
</pre></td>
</tr>
</table>
<p><br />
Although not all recursive functions have an explicit solution, the Tower of Hanoi sequence can be reduced to an explicit formula. <sup id="cite_ref-10" class="reference"><a href="#cite_note-10" title=""><span>[</span>11<span>]</span></a></sup></p>
<table class="wikitable">
<tr>
<th>An explicit formula for Towers of Hanoi:</th>
</tr>
<tr>
<td>
<pre>
h<sub>1</sub> = 1   = 2<sup>1</sup> - 1
h<sub>2</sub> = 3   = 2<sup>2</sup> - 1
h<sub>3</sub> = 7   = 2<sup>3</sup> - 1
h<sub>4</sub> = 15  = 2<sup>4</sup> - 1
h<sub>5</sub> = 31  = 2<sup>5</sup> - 1
h<sub>6</sub> = 63  = 2<sup>6</sup> - 1
h<sub>7</sub> = 127 = 2<sup>7</sup> - 1
</pre>
<pre>
In general:
h<sub>n</sub> = 2<sup>n</sup> - 1, for all n &gt;= 1
</pre></td>
</tr>
</table>
<p><a name="Binary_search" id="Binary_search"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: Binary search">edit</a>]</span> <span class="mw-headline">Binary search</span></h4>
<p>The <a href="/wiki/Binary_search" title="Binary search" class="mw-redirect">binary search</a> algorithm is a method of searching an ordered array for a single element by cutting the array in half with each pass. The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for.</p>
<p>Recursion is used in this algorithm because with each pass a new array is created by cutting the old one in half. The binary search procedure is then called recursively, this time on the new (and smaller) array. Typically the array's size is adjusted by manipulating a beginning and ending index. The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass.</p>
<p>Example Implementation of Binary Search:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
 <span class="coMULTI">/*
  Call binary_search with proper initial conditions.
 
  INPUT: 
    data is a array of integers SORTED in ASCENDING order,
    toFind is the integer to search for,
    count is the total number of elements in the array
 
  OUTPUT:
    result of binary_search
 
 */</span>
 <span class="kw4">int</span> search<span class="br0">(</span><span class="kw4">int</span> *data, <span class="kw4">int</span> toFind, <span class="kw4">int</span> count<span class="br0">)</span>
 <span class="br0">{</span>
    <span class="co1">//  Start = 0 (beginning index)</span>
    <span class="co1">//  End = count - 1 (top index)</span>
    <span class="kw1">return</span> binary_search<span class="br0">(</span>data, toFind, <span class="nu0">0</span>, count<span class="nu0">-1</span><span class="br0">)</span>;
 <span class="br0">}</span>
 
 <span class="coMULTI">/*
   Binary Search Algorithm.
 
   INPUT: 
        data is a array of integers SORTED in ASCENDING order,
        toFind is the integer to search for,
        start is the minimum array index,
        end is the maximum array index
   OUTPUT: 
        position of the integer toFind within array data, 
        -1 if not found
 */</span>
 <span class="kw4">int</span> binary_search<span class="br0">(</span><span class="kw4">int</span> *data, <span class="kw4">int</span> toFind, <span class="kw4">int</span> start, <span class="kw4">int</span> end<span class="br0">)</span>
 <span class="br0">{</span>
    <span class="co1">//Get the midpoint.</span>
    <span class="kw4">int</span> mid = start + <span class="br0">(</span>end - start<span class="br0">)</span>/<span class="nu0">2</span>;   <span class="co1">//Integer division</span>
 
    <span class="co1">//Stop condition.</span>
    <span class="kw1">if</span> <span class="br0">(</span>start &gt; end<span class="br0">)</span>
       <span class="kw1">return</span> <span class="nu0">-1</span>;
    <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>data<span class="br0">[</span>mid<span class="br0">]</span> == toFind<span class="br0">)</span>        <span class="co1">//Found?</span>
       <span class="kw1">return</span> mid;
    <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>data<span class="br0">[</span>mid<span class="br0">]</span> &gt; toFind<span class="br0">)</span>         <span class="co1">//Data is greater than toFind, search lower half</span>
       <span class="kw1">return</span> binary_search<span class="br0">(</span>data, toFind, start, mid<span class="nu0">-1</span><span class="br0">)</span>;
    <span class="kw1">else</span>                                 <span class="co1">//Data is less than toFind, search upper half</span>
       <span class="kw1">return</span> binary_search<span class="br0">(</span>data, toFind, mid<span class="nu0">+1</span>, end<span class="br0">)</span>;
 <span class="br0">}</span>
</pre></div>
<p><a name="Recursive_data_structures_.28structural_recursion.29" id="Recursive_data_structures_.28structural_recursion.29"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: Recursive data structures (structural recursion)">edit</a>]</span> <span class="mw-headline">Recursive data structures (structural recursion)</span></h3>
<p>An important application of recursion in computer science is in defining dynamic data structures such as Lists and Trees. Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, a static array's size requirements must be set at compile time.</p>
<blockquote>
<p>"Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms." <sup id="cite_ref-11" class="reference"><a href="#cite_note-11" title=""><span>[</span>12<span>]</span></a></sup></p>
</blockquote>
<p>The examples in this section illustrate what is known as "structural recursion". This term refers to the fact that the recursive procedures are acting on data that is defined recursively.</p>
<blockquote>
<p>As long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value. <sup id="cite_ref-12" class="reference"><a href="#cite_note-12" title=""><span>[</span>13<span>]</span></a></sup></p>
</blockquote>
<p><a name="Linked_lists" id="Linked_lists"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=10" title="Edit section: Linked lists">edit</a>]</span> <span class="mw-headline"><a href="/wiki/Linked_list" title="Linked list">Linked lists</a></span></h4>
<p>Below is a simple definition of a linked list node. Notice especially how the node is defined in terms of itself. The "next" element of struct node is a pointer to a struct node.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">struct</span> node
<span class="br0">{</span>
  <span class="kw4">int</span> n;              <span class="co1">// some data</span>
  <span class="kw4">struct</span> node *next;  <span class="co1">// pointer to another struct node</span>
<span class="br0">}</span>;
 
<span class="co1">// LIST is simply a synonym for struct node * (aka syntactic sugar).</span>
<span class="kw4">typedef</span> <span class="kw4">struct</span> node *LIST;
</pre></div>
<p>Procedures that operate on the LIST data structure can be implemented naturally as a recursive procedure because the data structure it operates on (LIST) is defined recursively. The printList procedure defined below walks down the list until the list is empty (NULL), for each node it prints the data element (an integer). In the C implementation, the list remains unchanged by the printList procedure.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span> printList<span class="br0">(</span>LIST lst<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>!isEmpty<span class="br0">(</span>lst<span class="br0">)</span><span class="br0">)</span>         <span class="co1">// base case</span>
    <span class="br0">{</span>
       <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span>, lst-&gt;n<span class="br0">)</span>;  <span class="co1">// print integer followed by a space</span>
       printList<span class="br0">(</span>lst-&gt;next<span class="br0">)</span>;   <span class="co1">// recursive call</span>
    <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<p><a name="Binary_trees" id="Binary_trees"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=11" title="Edit section: Binary trees">edit</a>]</span> <span class="mw-headline"><a href="/wiki/Binary_tree" title="Binary tree">Binary trees</a></span></h4>
<p>Below is a simple definition for a binary tree node. Like the node for Linked Lists, it is defined in terms of itself (recursively). There are two self-referential pointers - left (pointing to the left sub-tree) and right (pointing to the right sub-tree).</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">struct</span> node
<span class="br0">{</span>
  <span class="kw4">int</span> n;               <span class="co1">// some data</span>
  <span class="kw4">struct</span> node *left;   <span class="co1">// pointer to the left subtree</span>
  <span class="kw4">struct</span> node *right;  <span class="co1">// point to the right subtree</span>
<span class="br0">}</span>;
 
<span class="co1">// TREE is simply a synonym for struct node * (aka syntactic sugar).</span>
<span class="kw4">typedef</span> <span class="kw4">struct</span> node *TREE;
</pre></div>
<p>Operations on the tree can be implemented using recursion. Note that because there are two self-referencing pointers (left and right), that tree operations will require two recursive calls. For a similar example see the Fibonacci function and explanation above.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span> printTree<span class="br0">(</span>TREE t<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>!isEmpty<span class="br0">(</span>t<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>            <span class="co1">// base case                          </span>
                printTree<span class="br0">(</span>t-&gt;left<span class="br0">)</span>;   <span class="co1">// go left</span>
                <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d "</span>, t-&gt;n<span class="br0">)</span>;  <span class="co1">// print the integer followed by a space</span>
                printTree<span class="br0">(</span>t-&gt;right<span class="br0">)</span>;  <span class="co1">// go right</span>
        <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<p>The above example illustrates an <a href="/wiki/Tree_traversal" title="Tree traversal">in-order traversal</a> of the binary tree. A <a href="/wiki/Binary_search_tree" title="Binary search tree">Binary search tree</a> is a special case of the binary tree where the data elements of each node are in order.</p>
<p><a name="Recursion_versus_iteration" id="Recursion_versus_iteration"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=12" title="Edit section: Recursion versus iteration">edit</a>]</span> <span class="mw-headline">Recursion versus iteration</span></h3>
<p>In the "factorial" example the iterative implementation is likely to be slightly faster in practice than the recursive one. This is almost definite for the Euclidean Algorithm implementation. This result is typical, because iterative functions do not pay the "function-call overhead" as many times as recursive functions, and that overhead is relatively high in many languages. (Note that an even faster implementation for the factorial function on small integers is to use a <a href="/wiki/Lookup_table" title="Lookup table">lookup table</a>.)</p>
<p>There are other types of problems whose solutions are inherently recursive, because they need to keep track of prior state. One example is <a href="/wiki/Tree_traversal" title="Tree traversal">tree traversal</a>; others include the <a href="/wiki/Ackermann_function" title="Ackermann function">Ackermann function</a> and <a href="/wiki/Divide-and-conquer_algorithm" title="Divide-and-conquer algorithm" class="mw-redirect">divide-and-conquer algorithms</a> such as <a href="/wiki/Quicksort" title="Quicksort">Quicksort</a>. All of these algorithms can be implemented iteratively with the help of a <a href="/wiki/Stack_(data_structure)" title="Stack (data structure)">stack</a>, but the need for the stack arguably nullifies the advantages of the iterative solution.</p>
<p>Another possible reason for choosing an iterative rather than a recursive algorithm is that in today's programming languages, the stack space available to a thread is often much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms. However, see the caveat below regarding the special case of <a href="/wiki/Tail_recursion" title="Tail recursion">tail recursion</a>.</p>
<p><a name="Tail-recursive_functions" id="Tail-recursive_functions"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=13" title="Edit section: Tail-recursive functions">edit</a>]</span> <span class="mw-headline">Tail-recursive functions</span></h2>
<div class="rellink noprint relarticle mainarticle">Main article: <a href="/wiki/Tail_recursion" title="Tail recursion">Tail recursion</a></div>
<p>Tail-recursive functions are functions ending in a recursive call that does not build-up any deferred operations. For example, the gcd function (re-shown below) is tail-recursive; however, the factorial function (also re-shown below) is "augmenting recursive" because it builds up deferred operations that must be performed even after the final recursive call completes. With a <a href="/wiki/Compiler" title="Compiler">compiler</a> that automatically optimizes tail-recursive calls, a tail-recursive function such as gcd will execute using constant space. Thus the process it generates is iterative and equivalent to using imperative language control structures like the "for" and "while" loops.</p>
<table class="wikitable">
<tr>
<th><a href="/wiki/Tail_recursion" title="Tail recursion">Tail recursion</a>:</th>
<th>Augmenting recursion:</th>
</tr>
<tr>
<td>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="co1">//INPUT: Integers x, y such that x &gt;= y and y &gt; 0</span>
<span class="kw4">int</span> gcd<span class="br0">(</span><span class="kw4">int</span> x, <span class="kw4">int</span> y<span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">if</span> <span class="br0">(</span>y == <span class="nu0">0</span><span class="br0">)</span>
     <span class="kw1">return</span> x;
  <span class="kw1">else</span>
     <span class="kw1">return</span> gcd<span class="br0">(</span>y, x % y<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
</td>
<td>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="co1">//INPUT: n is an Integer such that n &gt;= 1</span>
<span class="kw4">int</span> fact<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
   <span class="kw1">if</span> <span class="br0">(</span>n == <span class="nu0">1</span><span class="br0">)</span>
      <span class="kw1">return</span> <span class="nu0">1</span>;
   <span class="kw1">else</span>
      <span class="kw1">return</span> n * fact<span class="br0">(</span>n - <span class="nu0">1</span><span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
</td>
</tr>
</table>
<p>The significance of tail recursion is that when making a tail-recursive call, the caller's return position need not be saved on the <a href="/wiki/Call_stack" title="Call stack">call stack</a>; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, on compilers which support tail-recursion optimization, tail recursion saves both space and time.</p>
<p><a name="Order_of_function_calling" id="Order_of_function_calling"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=14" title="Edit section: Order of function calling">edit</a>]</span> <span class="mw-headline">Order of function calling</span></h2>
<p>The order of calling a function may change the execution of a function, see this example in <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> language:</p>
<p><a name="Function_1" id="Function_1"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=15" title="Edit section: Function 1">edit</a>]</span> <span class="mw-headline">Function 1</span></h3>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span> recursiveFunction<span class="br0">(</span><span class="kw4">int</span> num<span class="br0">)</span> <span class="br0">{</span>
   <span class="kw1">if</span> <span class="br0">(</span>num &lt; <span class="nu0">5</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es0">\n</span>"</span>, num<span class="br0">)</span>;
      recursiveFunction<span class="br0">(</span>num + <span class="nu0">1</span><span class="br0">)</span>;
   <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<p><a href="/wiki/File:RecursiveFunction1_execution.png" class="image" title="Image:RecursiveFunction1 execution.png"><img alt="Image:RecursiveFunction1 execution.png" src="http://upload.wikimedia.org/wikipedia/commons/8/8a/RecursiveFunction1_execution.png" width="349" height="151" border="0" /></a></p>
<p><a name="Function_2_with_swapped_lines" id="Function_2_with_swapped_lines"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=16" title="Edit section: Function 2 with swapped lines">edit</a>]</span> <span class="mw-headline">Function 2 with swapped lines</span></h3>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span> recursiveFunction<span class="br0">(</span><span class="kw4">int</span> num<span class="br0">)</span> <span class="br0">{</span>
   <span class="kw1">if</span> <span class="br0">(</span>num &lt; <span class="nu0">5</span><span class="br0">)</span> <span class="br0">{</span>
      recursiveFunction<span class="br0">(</span>num + <span class="nu0">1</span><span class="br0">)</span>;
      <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"%d<span class="es0">\n</span>"</span>, num<span class="br0">)</span>;
   <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<p><a href="/wiki/File:RecursiveFunction2_execution.png" class="image" title="Image:RecursiveFunction2 execution.png"><img alt="Image:RecursiveFunction2 execution.png" src="http://upload.wikimedia.org/wikipedia/commons/0/0d/RecursiveFunction2_execution.png" width="349" height="143" border="0" /></a></p>
<p><a name="Direct_and_indirect_recursion" id="Direct_and_indirect_recursion"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=17" title="Edit section: Direct and indirect recursion">edit</a>]</span> <span class="mw-headline">Direct and indirect recursion</span></h2>
<p>Direct recursion is when a function calls itself. Indirect recursion is when (for example) function A calls function B, function B calls function C, and then function C calls function A. Long chains and branches are possible, see <a href="/wiki/Recursive_descent_parser" title="Recursive descent parser">Recursive descent parser</a>.</p>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=18" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/Mutual_recursion" title="Mutual recursion">Mutual recursion</a></li>
<li><a href="/wiki/Anonymous_recursion" title="Anonymous recursion">Anonymous recursion</a></li>
<li><a href="/wiki/%CE%9C-recursive_function" title="Μ-recursive function">μ-recursive function</a></li>
<li><a href="/wiki/Primitive_recursive_function" title="Primitive recursive function">Primitive recursive function</a></li>
<li><a href="/wiki/Functional_programming" title="Functional programming">Functional programming</a></li>
<li><a href="/wiki/Kleene-Rosser_paradox" title="Kleene-Rosser paradox">Kleene-Rosser paradox</a></li>
<li><a href="/wiki/McCarthy_91_function" title="McCarthy 91 function">McCarthy 91 function</a></li>
<li><a href="/wiki/Ackermann_function" title="Ackermann function">Ackermann function</a></li>
<li><a href="/wiki/Sierpi%C5%84ski_curve" title="Sierpiński curve">Sierpiński curve</a></li>
</ul>
<p><a name="Notes_and_References" id="Notes_and_References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=19" title="Edit section: Notes and References">edit</a>]</span> <span class="mw-headline">Notes and References</span></h2>
<div class="references-small references-column-count references-column-count-2" style="-moz-column-count:2; column-count:2;">
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFEpp1995">Epp, Susanna (1995). <i>Discrete Mathematics with Applications</i> (2nd ed.). p.&#160;427.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Discrete+Mathematics+with+Applications&amp;rft.aulast=Epp&amp;rft.aufirst=Susanna&amp;rft.au=Epp%2C+Susanna&amp;rft.date=1995&amp;rft.pages=p.%26nbsp%3B427&amp;rft.edition=2nd&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-1"><b><a href="#cite_ref-1" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFGrahamDonald_Knuth.2C_Oren_Patashnik1990">Graham, Ronald; Donald Knuth, Oren Patashnik (1990). <i><a href="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" class="external text" title="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" rel="nofollow">Concrete Mathematics</a></i>. Chapter 1: Recurrent Problems<span class="printonly">. <a href="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" class="external free" title="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" rel="nofollow">http://www-cs-faculty.stanford.edu/~knuth/gkp.html</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Concrete+Mathematics&amp;rft.aulast=Graham&amp;rft.aufirst=Ronald&amp;rft.au=Graham%2C+Ronald&amp;rft.au=Donald+Knuth%2C+Oren+Patashnik&amp;rft.date=1990&amp;rft.pages=Chapter+1%3A+Recurrent+Problems&amp;rft_id=http%3A%2F%2Fwww-cs-faculty.stanford.edu%2F%7Eknuth%2Fgkp.html&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-2"><b><a href="#cite_ref-2" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFWirth1976">Wirth, Niklaus (1976). <i>Algorithms + Data Structures = Programs</i>. Prentice-Hall. p.&#160;126.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Algorithms+%2B+Data+Structures+%3D+Programs&amp;rft.aulast=Wirth&amp;rft.aufirst=Niklaus&amp;rft.au=Wirth%2C+Niklaus&amp;rft.date=1976&amp;rft.pages=p.%26nbsp%3B126&amp;rft.pub=Prentice-Hall&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-3"><b><a href="#cite_ref-3" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFFelleisenRobert_Bruce_Findler.2C_Matthew_Flatt.2C_Shriram_Krishnamurthi2009">Felleisen, Matthias; Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi (2001). <i><a href="http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-31.html" class="external text" title="http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-31.html" rel="nofollow">How to Design Programs: An Introduction to Computing and Programming</a></i>. Cambridge, MASS: MIT Press. p.&#160;art V "Generative Recursion"<span class="printonly">. <a href="http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-31.html" class="external free" title="http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-31.html" rel="nofollow">http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-31.html</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=How+to+Design+Programs%3A+An+Introduction+to+Computing+and+Programming&amp;rft.aulast=Felleisen&amp;rft.aufirst=Matthias&amp;rft.au=Felleisen%2C+Matthias&amp;rft.au=Robert+Bruce+Findler%2C+Matthew+Flatt%2C+Shriram+Krishnamurthi&amp;rft.date=2001&amp;rft.pages=p.%26nbsp%3Bart+V+%22Generative+Recursion%22&amp;rft.place=Cambridge%2C+MASS&amp;rft.pub=MIT+Press&amp;rft_id=http%3A%2F%2Fwww.htdp.org%2F2003-09-26%2FBook%2Fcurriculum-Z-H-31.html&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-4"><b><a href="#cite_ref-4" title="">^</a></b> <cite style="font-style:normal" class="" id="CITEREFFelleisen2002">Felleisen, Matthias (2002), "Developing Interactive Web Programs", in Jeuring, Johan, <i>Advanced Functional Programming: 4th International School</i>, Oxford, UK: Springer, pp.&#160;108</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Developing+Interactive+Web+Programs&amp;rft.atitle=Advanced+Functional+Programming%3A+4th+International+School&amp;rft.aulast=Felleisen&amp;rft.aufirst=Matthias&amp;rft.au=Felleisen%2C+Matthias&amp;rft.date=2002&amp;rft.pages=pp.%26nbsp%3B108&amp;rft.place=Oxford%2C+UK&amp;rft.pub=Springer&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span>.</li>
<li id="cite_note-5"><b><a href="#cite_ref-5" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFEpp1995">Epp, Susanna (1995). <i>Discrete Mathematics with Applications</i>. Brooks-Cole Publishing Company. p.&#160;424.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Discrete+Mathematics+with+Applications&amp;rft.aulast=Epp&amp;rft.aufirst=Susanna&amp;rft.au=Epp%2C+Susanna&amp;rft.date=1995&amp;rft.pages=p.%26nbsp%3B424&amp;rft.pub=Brooks-Cole+Publishing+Company&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-6"><b><a href="#cite_ref-6" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFAbelsonGerald_Jay_Sussman1996">Abelson, Harold; Gerald Jay Sussman (1996). <i><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2" class="external text" title="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2" rel="nofollow">Structure and Interpretation of Computer Programs</a></i>. Section 1.2.2<span class="printonly">. <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2" class="external free" title="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2" rel="nofollow">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Structure+and+Interpretation+of+Computer+Programs&amp;rft.aulast=Abelson&amp;rft.aufirst=Harold&amp;rft.au=Abelson%2C+Harold&amp;rft.au=Gerald+Jay+Sussman&amp;rft.date=1996&amp;rft.pages=Section+1.2.2&amp;rft_id=http%3A%2F%2Fmitpress.mit.edu%2Fsicp%2Ffull-text%2Fbook%2Fbook-Z-H-11.html%23%25_sec_1.2.2&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-7"><b><a href="#cite_ref-7" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFAbelsonGerald_Jay_Sussman1996">Abelson, Harold; Gerald Jay Sussman (1996). <i><a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.5" class="external text" title="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.5" rel="nofollow">Structure and Interpretation of Computer Programs</a></i>. Section 1.2.5<span class="printonly">. <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.5" class="external free" title="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.5" rel="nofollow">http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.5</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Structure+and+Interpretation+of+Computer+Programs&amp;rft.aulast=Abelson&amp;rft.aufirst=Harold&amp;rft.au=Abelson%2C+Harold&amp;rft.au=Gerald+Jay+Sussman&amp;rft.date=1996&amp;rft.pages=Section+1.2.5&amp;rft_id=http%3A%2F%2Fmitpress.mit.edu%2Fsicp%2Ffull-text%2Fbook%2Fbook-Z-H-11.html%23%25_sec_1.2.5&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-8"><b><a href="#cite_ref-8" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFGrahamDonald_Knuth.2C_Oren_Patashnik1990">Graham, Ronald; Donald Knuth, Oren Patashnik (1990). <i><a href="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" class="external text" title="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" rel="nofollow">Concrete Mathematics</a></i>. Chapter 1, Section 1.1: The Tower of Hanoi<span class="printonly">. <a href="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" class="external free" title="http://www-cs-faculty.stanford.edu/~knuth/gkp.html" rel="nofollow">http://www-cs-faculty.stanford.edu/~knuth/gkp.html</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Concrete+Mathematics&amp;rft.aulast=Graham&amp;rft.aufirst=Ronald&amp;rft.au=Graham%2C+Ronald&amp;rft.au=Donald+Knuth%2C+Oren+Patashnik&amp;rft.date=1990&amp;rft.pages=Chapter+1%2C+Section+1.1%3A+The+Tower+of+Hanoi&amp;rft_id=http%3A%2F%2Fwww-cs-faculty.stanford.edu%2F%7Eknuth%2Fgkp.html&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-9"><b><a href="#cite_ref-9" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFEpp1995">Epp, Susanna (1995). <i>Discrete Mathematics with Applications</i> (2nd ed.). pp.&#160;427–430: The Tower of Hanoi.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Discrete+Mathematics+with+Applications&amp;rft.aulast=Epp&amp;rft.aufirst=Susanna&amp;rft.au=Epp%2C+Susanna&amp;rft.date=1995&amp;rft.pages=pp.%26nbsp%3B427%E2%80%93430%3A+The+Tower+of+Hanoi&amp;rft.edition=2nd&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-10"><b><a href="#cite_ref-10" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFEpp1995">Epp, Susanna (1995). <i>Discrete Mathematics with Applications</i> (2nd ed.). pp.&#160;447–448: An Explicit Formula for the Tower of Hanoi Sequence.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Discrete+Mathematics+with+Applications&amp;rft.aulast=Epp&amp;rft.aufirst=Susanna&amp;rft.au=Epp%2C+Susanna&amp;rft.date=1995&amp;rft.pages=pp.%26nbsp%3B447%E2%80%93448%3A+An+Explicit+Formula+for+the+Tower+of+Hanoi+Sequence&amp;rft.edition=2nd&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-11"><b><a href="#cite_ref-11" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFWirth1976">Wirth, Niklaus (1976). <i>Algorithms + Data Structures = Programs</i>. Prentice-Hall. p.&#160;127.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Algorithms+%2B+Data+Structures+%3D+Programs&amp;rft.aulast=Wirth&amp;rft.aufirst=Niklaus&amp;rft.au=Wirth%2C+Niklaus&amp;rft.date=1976&amp;rft.pages=p.%26nbsp%3B127&amp;rft.pub=Prentice-Hall&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-12"><b><a href="#cite_ref-12" title="">^</a></b> <cite style="font-style:normal" class="" id="CITEREFFelleisen2002">Felleisen, Matthias (2002), "Developing Interactive Web Programs", in Jeuring, Johan, <i>Advanced Functional Programming: 4th International School</i>, Oxford, UK: Springer, pp.&#160;108</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Developing+Interactive+Web+Programs&amp;rft.atitle=Advanced+Functional+Programming%3A+4th+International+School&amp;rft.aulast=Felleisen&amp;rft.aufirst=Matthias&amp;rft.au=Felleisen%2C+Matthias&amp;rft.date=2002&amp;rft.pages=pp.%26nbsp%3B108&amp;rft.place=Oxford%2C+UK&amp;rft.pub=Springer&amp;rfr_id=info:sid/en.wikipedia.org:Recursion_(computer_science)"><span style="display: none;">&#160;</span></span>.</li>
</ol>
</div>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit&amp;section=20" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" class="external text" title="http://mitpress.mit.edu/sicp/full-text/book/book.html" rel="nofollow">Harold Abelson and Gerald Sussman: "Structure and Interpretation Of Computer Programs"</a></li>
<li><a href="http://www-128.ibm.com/developerworks/linux/library/l-recurs.html" class="external text" title="http://www-128.ibm.com/developerworks/linux/library/l-recurs.html" rel="nofollow">IBM DeveloperWorks: "Mastering Recursive Programming"</a></li>
<li><a href="http://www.cs.cmu.edu/~dst/LispBook/" class="external text" title="http://www.cs.cmu.edu/~dst/LispBook/" rel="nofollow">David S. Touretzky: "Common Lisp: A Gentle Introduction to Symbolic Computation"</a></li>
<li><a href="http://www.htdp.org/2003-09-26/Book/" class="external text" title="http://www.htdp.org/2003-09-26/Book/" rel="nofollow">Matthias Felleisen: "How To Design Programs: An Introduction to Computing and Programming"</a></li>
<li><a href="http://www.cs.duke.edu/~ola/ap/recurrence.html" class="external text" title="http://www.cs.duke.edu/~ola/ap/recurrence.html" rel="nofollow">Duke University: "Big-Oh for Recursive Functions: Recurrence Relations"</a></li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 7070/1000000
Post-expand include size: 45299/2048000 bytes
Template argument size: 12969/2048000 bytes
Expensive parser function count: 2/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:4044867-0!1!0!default!!en!2 and timestamp 20090415180447 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Recursion_(computer_science)">http://en.wikipedia.org/wiki/Recursion_(computer_science)</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Theoretical_computer_science" title="Category:Theoretical computer science">Theoretical computer science</a></span> | <span dir='ltr'><a href="/wiki/Category:Recursion_theory" title="Category:Recursion theory">Recursion theory</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_pseudocode" title="Category:Articles with example pseudocode">Articles with example pseudocode</a></span> | <span dir='ltr'><a href="/wiki/Category:Control_flow" title="Category:Control flow">Control flow</a></span> | <span dir='ltr'><a href="/wiki/Category:Programming_idioms" title="Category:Programming idioms">Programming idioms</a></span></div><div id="mw-hidden-catlinks" class="mw-hidden-cats-hidden">Hidden categories:&#32;<span dir='ltr'><a href="/wiki/Category:All_articles_with_unsourced_statements" title="Category:All articles with unsourced statements">All articles with unsourced statements</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_unsourced_statements_since_May_2008" title="Category:Articles with unsourced statements since May 2008">Articles with unsourced statements since May 2008</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Recursion_(computer_science)" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Recursion_(computer_science)" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Recursion_(computer_science)&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Recursion_(computer_science)&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Recursion_(computer_science)" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Recursion_(computer_science)" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Recursion_(computer_science)" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Recursion_(computer_science)&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Recursion_(computer_science)&amp;oldid=281278816" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Recursion_(computer_science)&amp;id=281278816">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Rekursive_Programmierung">Deutsch</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Algorithme_r%C3%A9cursif">Français</a></li>
				<li class="interwiki-pt"><a href="http://pt.wikipedia.org/wiki/Recursividade_(ci%C3%AAncia_da_computa%C3%A7%C3%A3o)">Português</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E9%81%9E%E6%AD%B8_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 2 April 2009, at 12:24 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv182 in 0.057 secs. --></body></html>
