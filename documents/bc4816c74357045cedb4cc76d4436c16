<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Reference counting,Reference counting,.NET Framework,ACM SIGPLAN Notices,Atomic operation,CPU cache,Cocoa (API),Component Object Model,Computer science,Context switch,Core Foundation" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Reference_counting&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Reference_counting&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Reference counting - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Reference_counting";
		var wgTitle = "Reference counting";
		var wgAction = "view";
		var wgArticleId = "26490";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 283142900;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Reference_counting skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Reference counting</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>reference counting</b> is a technique of storing the number of references, pointers, or handles to a resource such as an object or block of memory. It is typically used as a means of deallocating objects which are no longer referenced.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Use_in_garbage_collection"><span class="tocnumber">1</span> <span class="toctext">Use in garbage collection</span></a></li>
<li class="toclevel-1"><a href="#Advantages_and_disadvantages"><span class="tocnumber">2</span> <span class="toctext">Advantages and disadvantages</span></a></li>
<li class="toclevel-1"><a href="#Graph_interpretation"><span class="tocnumber">3</span> <span class="toctext">Graph interpretation</span></a></li>
<li class="toclevel-1"><a href="#Dealing_with_inefficiency_of_updates"><span class="tocnumber">4</span> <span class="toctext">Dealing with inefficiency of updates</span></a></li>
<li class="toclevel-1"><a href="#Dealing_with_reference_cycles"><span class="tocnumber">5</span> <span class="toctext">Dealing with reference cycles</span></a></li>
<li class="toclevel-1"><a href="#Variants_of_reference_counting"><span class="tocnumber">6</span> <span class="toctext">Variants of reference counting</span></a>
<ul>
<li class="toclevel-2"><a href="#Weighted_reference_counting"><span class="tocnumber">6.1</span> <span class="toctext">Weighted reference counting</span></a></li>
<li class="toclevel-2"><a href="#Indirect_reference_counting"><span class="tocnumber">6.2</span> <span class="toctext">Indirect reference counting</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Examples_of_use"><span class="tocnumber">7</span> <span class="toctext">Examples of use</span></a>
<ul>
<li class="toclevel-2"><a href="#COM"><span class="tocnumber">7.1</span> <span class="toctext">COM</span></a></li>
<li class="toclevel-2"><a href="#Cocoa"><span class="tocnumber">7.2</span> <span class="toctext">Cocoa</span></a></li>
<li class="toclevel-2"><a href="#Delphi"><span class="tocnumber">7.3</span> <span class="toctext">Delphi</span></a></li>
<li class="toclevel-2"><a href="#GObject"><span class="tocnumber">7.4</span> <span class="toctext">GObject</span></a></li>
<li class="toclevel-2"><a href="#PHP"><span class="tocnumber">7.5</span> <span class="toctext">PHP</span></a></li>
<li class="toclevel-2"><a href="#Python"><span class="tocnumber">7.6</span> <span class="toctext">Python</span></a></li>
<li class="toclevel-2"><a href="#Squirrel"><span class="tocnumber">7.7</span> <span class="toctext">Squirrel</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Use_in_garbage_collection" id="Use_in_garbage_collection"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=1" title="Edit section: Use in garbage collection">edit</a>]</span> <span class="mw-headline">Use in garbage collection</span></h2>
<p>Reference counting is often known as a <a href="/wiki/Garbage_collection_(computer_science)" title="Garbage collection (computer science)">garbage collection</a> algorithm where each object contains a count of the number of <a href="/wiki/Reference" title="Reference">references</a> to it held by other objects. If an object's reference count reaches zero, the object has become inaccessible, and it is put on a list of objects to be destroyed.</p>
<p>Simple reference counts require frequent updates. Whenever a reference is destroyed or overwritten, the reference count of the object it references is decremented, and whenever one is created or copied, the reference count of the object it references is incremented.</p>
<p>Reference counting is also used in disk operating systems and distributed systems, where full non-incremental tracing garbage collection is too time consuming because of the size of the object graph and slow access speed.</p>
<p><a name="Advantages_and_disadvantages" id="Advantages_and_disadvantages"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=2" title="Edit section: Advantages and disadvantages">edit</a>]</span> <span class="mw-headline">Advantages and disadvantages</span></h2>
<p>The main advantage of reference counting over <a href="/wiki/Tracing_garbage_collection" title="Tracing garbage collection" class="mw-redirect">tracing garbage collection</a> is that objects are reclaimed <i>as soon as</i> they can no longer be referenced, and in an incremental fashion, without long pauses for collection cycles and with clearly defined lifetime of every object. In real-time applications or systems with limited memory, this is important to maintain responsiveness. Reference counting is also among the simplest forms of garbage collection to implement. It also allows for effective management of non-memory resources such as operating system objects, which are often much scarcer than memory (tracing GC systems use finalizers for this, but the delayed reclamation may cause problems). <a href="/wiki/Reference_counting#Weighted_reference_counting" title="Reference counting">Weighted reference counts</a> are a good solution for garbage collecting a distributed system.</p>
<p>Reference counts are also useful information to use as input to other runtime optimizations. For example, systems that depend heavily on <a href="/wiki/Immutable_object" title="Immutable object">immutable objects</a> such as many <a href="/wiki/Functional_programming_language" title="Functional programming language" class="mw-redirect">functional programming languages</a> can suffer an efficiency penalty due to frequent copies. However, if we know an object has only one reference (as most do in many systems), and that reference is lost at the same time that a similar new object is created (as in the string append statement <code>str ← str + "a"</code>), we can replace the operation with a mutation on the original object.</p>
<p>Reference counting in naive form has two main disadvantages over the <a href="/wiki/Tracing_garbage_collection" title="Tracing garbage collection" class="mw-redirect">tracing garbage collection</a>, both of which require additional mechanisms to ameliorate:</p>
<ul>
<li>The frequent updates it involves are a source of inefficiency. While tracing garbage collectors can impact efficiency severely via <a href="/wiki/Context_switch" title="Context switch">context switching</a> and cache line faults, they collect relatively infrequently, while accessing objects is done continually. Also, less importantly, reference counting requires every memory-managed object to reserve space for a reference count. In tracing garbage collectors, this information is stored implicitly in the references that refer to that object, saving space, although tracing garbage collectors, particularly incremental ones, can require additional space for other purposes.</li>
<li>The naive algorithm described above can't handle reference cycles, an object which refers directly or indirectly to itself. A mechanism relying purely on reference counts will never consider cyclic chains of objects for deletion, since their reference count is guaranteed to stay nonzero. Methods for dealing with this issue exist but can also increase the overhead and complexity of reference counting — on the other hand, these methods need only be applied to data that might form cycles, often a small subset of all data. One such method is the use of <a href="/wiki/Weak_reference" title="Weak reference">weak references</a>.</li>
</ul>
<p><a name="Graph_interpretation" id="Graph_interpretation"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=3" title="Edit section: Graph interpretation">edit</a>]</span> <span class="mw-headline">Graph interpretation</span></h2>
<p>When dealing with garbage collection schemes, it's often helpful to think of the <b>reference graph</b>, which is a <a href="/wiki/Directed_graph" title="Directed graph">directed graph</a> where the <a href="/wiki/Vertex_(graph_theory)" title="Vertex (graph theory)">vertices</a> are objects and there is an edge from an object&#160;A to an object&#160;B if A holds a reference to&#160;B. We also have a special vertex or vertices representing the local variables and references held by the runtime system, and no edges ever go to these nodes, although edges can go from them to other nodes.</p>
<p>In this context, the simple reference count of an object is the <a href="/wiki/In-degree" title="In-degree" class="mw-redirect">in-degree</a> of its vertex. Deleting a vertex is like collecting an object. It can only be done when the vertex has no incoming edges, so it does not affect the out-degree of any other vertices, but it can affect the in-degree of other vertices, causing their corresponding objects to be collected as well.</p>
<p>The connected component containing the special vertex contains the objects that can't be collected, while other connected components of the graph only contain garbage. By the nature of reference counting, each of these garbage components must contain at least one cycle.</p>
<p><a name="Dealing_with_inefficiency_of_updates" id="Dealing_with_inefficiency_of_updates"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=4" title="Edit section: Dealing with inefficiency of updates">edit</a>]</span> <span class="mw-headline">Dealing with inefficiency of updates</span></h2>
<p>Incrementing and decrementing reference counts every time a reference is created or destroyed can significantly impede performance. Not only do the operations take time, but they damage <a href="/wiki/CPU_cache" title="CPU cache">cache</a> performance and can lead to <a href="/wiki/Pipeline_bubble" title="Pipeline bubble" class="mw-redirect">pipeline bubbles</a>. Even read-only operations like calculating the length of a list require a large number of reads and writes for reference updates with naive reference counting.</p>
<p>One simple technique is for the compiler to combine a number of nearby reference updates into one. This is especially effective for references which are created and quickly destroyed. Care must be taken, however, to put the combined update at the right position so that a premature free is avoided.</p>
<p>The Deutsch-Bobrow method of reference counting capitalizes on the fact that most reference count updates are in fact generated by references stored in local variables. It ignores these references, only counting references in data structures, but before an object with reference count zero can be deleted, the system must verify with a scan of the stack and registers that no other reference to it still exists.</p>
<p>Another technique devised by <a href="/wiki/Henry_Baker_(computer_scientist)" title="Henry Baker (computer scientist)">Henry Baker</a> involves <b>deferred increments</b>,<sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup> in which references which are stored in local variables do not immediately increment the corresponding reference count, but instead defer this until it is necessary. If such a reference is destroyed quickly, then there is no need to update the counter. This eliminates a large number of updates associated with short-lived references. However, if such a reference is copied into a data structure, then the deferred increment must be performed at that time. It is also critical to perform the deferred increment before the object's count drops to zero, resulting in a premature free.</p>
<p>A dramatic decrease in the overhead on counter updates was obtained by <a href="http://www.cs.technion.ac.il/~levanoni/" class="external text" title="http://www.cs.technion.ac.il/~levanoni/" rel="nofollow">Levanoni</a> and <a href="http://www.cs.technion.ac.il/~erez/" class="external text" title="http://www.cs.technion.ac.il/~erez/" rel="nofollow">Petrank</a>. Their update coalescing method eliminates more than 99% of the counter updates for typical Java benchmarks. In addition, they eliminate the need for atomic operations during pointer updates on parallel processors. Finally, they present an enhanced algorithm that may run concurrently with multithreaded applications employing only fine synchronization. See the <a href="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.pdf" class="external text" title="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.pdf" rel="nofollow">paper</a> for more.</p>
<p>Blackburn and McKinley's ulterior reference counting<sup id="cite_ref-1" class="reference"><a href="#cite_note-1" title=""><span>[</span>2<span>]</span></a></sup> combines deferred reference counting with a copying nursery, observing that the majority of pointer mutations occur in young objects. This algorithm achieves throughput comparable with the fastest generational copying collectors with the low bounded pause times of reference counting.</p>
<p>More work on improving performance of reference counting collectors can be found in <a href="http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2006/PHD/PHD-2006-10.ps" class="external text" title="http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2006/PHD/PHD-2006-10.ps" rel="nofollow">Paz's Ph.D thesis</a>. In particular, he advocates the use of <a href="http://www.cs.technion.ac.il/~erez/Papers/ao-cc.pdf" class="external text" title="http://www.cs.technion.ac.il/~erez/Papers/ao-cc.pdf" rel="nofollow">age oriented collectors</a> and <a href="http://www.cs.technion.ac.il/~erez/Papers/rc-prefetch-cc07.pdf" class="external text" title="http://www.cs.technion.ac.il/~erez/Papers/rc-prefetch-cc07.pdf" rel="nofollow">prefetching</a>.</p>
<p><a name="Dealing_with_reference_cycles" id="Dealing_with_reference_cycles"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=5" title="Edit section: Dealing with reference cycles">edit</a>]</span> <span class="mw-headline">Dealing with reference cycles</span></h2>
<p>There are a variety of ways of handling the problem of <a href="/wiki/Cycle_detection" title="Cycle detection">detecting</a> and collecting reference cycles. One is that a system may explicitly forbid reference cycles. In some systems like filesystems this is a common solution. Cycles are also sometimes ignored in systems with short lives and a small amount of cyclic garbage, particularly when the system was developed using a methodology of avoiding cyclic data structures wherever possible, typically at the expense of efficiency.</p>
<p>Another solution is to periodically use a <a href="/wiki/Tracing_garbage_collection" title="Tracing garbage collection" class="mw-redirect">tracing garbage collector</a> to reclaim cycles. Since cycles typically constitute a relatively small amount of reclaimed space, the collection cycles can be spaced much farther apart than with an ordinary tracing garbage collector.</p>
<p>Bacon describes a cycle-collection algorithm for reference counting systems with some similarities to tracing systems, including the same theoretical time bounds, but that takes advantage of reference count information to run much more quickly and with less cache damage. It's based on the observation that an object cannot appear in a cycle until its reference count is decremented to a nonzero value. All objects which this occurs to are put on a <i>roots</i> list, and then periodically the program searches through the objects reachable from the roots for cycles. It knows it has found a cycle when decrementing all the reference counts on a cycle of references brings them all down to zero. An enhanced version of this algorithm by Paz et al. is able to run concurrently with other operations and improve its efficiency by using the update coalescing method of Levanoni and Petrank. See the <a href="http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf" class="external text" title="http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf" rel="nofollow">paper</a> for more.</p>
<p><a name="Variants_of_reference_counting" id="Variants_of_reference_counting"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=6" title="Edit section: Variants of reference counting">edit</a>]</span> <span class="mw-headline">Variants of reference counting</span></h2>
<p>Although it's possible to augment simple reference counts in a variety of ways, often a better solution can be found by performing reference counting in a fundamentally different way. Here we describe some of the variants on reference counting and their benefits and drawbacks.</p>
<p><a name="Weighted_reference_counting" id="Weighted_reference_counting"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=7" title="Edit section: Weighted reference counting">edit</a>]</span> <span class="mw-headline">Weighted reference counting</span></h3>
<p>In weighted reference counting, we assign each reference a <i>weight</i>, and each object tracks not the number of references referring to it, but the total weight of the references referring to it. The initial reference to a newly-created object has a large weight, such as 2<sup>16</sup>. Whenever this reference is copied, half of the weight goes to the new reference, and half of the weight stays with the old reference. Because the total weight does not change, the object's reference count does not need to be updated.</p>
<p>Destroying a reference decrements the total weight by the weight of that reference. When the total weight becomes equal to the partial weight, all references have been destroyed. If an attempt is made to copy a reference with a weight of 1, we have to "get more weight" by adding to the total weight and then adding this new weight to our reference, and then split it.</p>
<p>The property of not needing to access a reference count when a reference is copied is particularly helpful when the object's reference count is expensive to access, for example because it is in another process, on disk, or even across a network. It can also help increase concurrency by avoiding many threads locking a reference count to increase it. Thus, weighted reference counting is most useful in parallel, multiprocess, database, or distributed applications.</p>
<p>The primary problem with simple weighted reference counting is that destroying a reference still requires accessing the reference count, and if many references are destroyed this can cause the same bottlenecks we seek to avoid. Some adaptations of weighted reference counting seek to avoid this by attempting to give weight back from a dying reference to one which is still active.</p>
<p>Weighted reference counting was independently devised by Bevan, in the paper <i>Distributed garbage collection using reference counting</i>, and Watson, in the paper <i>An efficient garbage collection scheme for parallel computer architectures</i>, both in 1987.</p>
<p><a name="Indirect_reference_counting" id="Indirect_reference_counting"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=8" title="Edit section: Indirect reference counting">edit</a>]</span> <span class="mw-headline">Indirect reference counting</span></h3>
<p>In indirect reference counting, it is necessary to keep track of who the reference was obtained from. This means that two references are kept to the object: a direct one which is used for invocations; and an indirect one which forms part of a diffusion tree, such as in the <a href="/wiki/Dijkstra-Scholten_algorithm" title="Dijkstra-Scholten algorithm">Dijkstra-Scholten algorithm</a>, which allows a garbage collector to identify dead objects. This approach prevents an object from being discarded prematurely.</p>
<p><a name="Examples_of_use" id="Examples_of_use"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=9" title="Edit section: Examples of use">edit</a>]</span> <span class="mw-headline">Examples of use</span></h2>
<p><a name="COM" id="COM"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=10" title="Edit section: COM">edit</a>]</span> <span class="mw-headline">COM</span></h3>
<p>Microsoft's <a href="/wiki/Component_Object_Model" title="Component Object Model">Component Object Model</a> (COM) makes pervasive use of reference counting. In fact, the three methods that all COM objects must provide (in the <a href="/wiki/IUnknown" title="IUnknown">IUnknown</a> interface) all increment or decrement the reference count. Much of the <a href="/wiki/Windows_Shell" title="Windows Shell">Windows Shell</a> and many Windows applications (including <a href="/wiki/Microsoft_Internet_Explorer" title="Microsoft Internet Explorer" class="mw-redirect">MS Internet Explorer</a>, <a href="/wiki/Microsoft_Office" title="Microsoft Office">MS Office</a>, and countless third-party products) are built on COM, demonstrating the viability of reference counting in large-scale systems.</p>
<p>One primary motivation for reference counting in COM is to enable interoperability across different programming languages and runtime systems. A client need only know how to invoke object methods in order to manage object life cycle; thus, the client is completely abstracted from whatever memory allocator the implementation of the COM object uses. As a typical example, a <a href="/wiki/Visual_Basic" title="Visual Basic">Visual Basic</a> program using a COM object is agnostic towards whether that object was allocated (and must later be deallocated) by a C++ allocator or another Visual Basic component.</p>
<p>However, this support for heterogeneity has a major cost: it requires correct reference count management by all parties involved. While high-level languages like Visual Basic manage reference counts automatically, C/C++ programmers are entrusted to increment and decrement reference counts at the appropriate time. C++ programs can and should avoid the task of managing reference counts manually by using <a href="/wiki/Smart_pointer" title="Smart pointer">smart pointers</a>. Bugs caused by incorrect reference counting in COM systems are notoriously hard to resolve, especially because the error may occur in an opaque, third-party component.</p>
<p>Microsoft has abandoned reference counting in favor of tracing garbage collection for the <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>.</p>
<p><a name="Cocoa" id="Cocoa"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=11" title="Edit section: Cocoa">edit</a>]</span> <span class="mw-headline">Cocoa</span></h3>
<p>Apple's <a href="/wiki/Cocoa_(API)" title="Cocoa (API)">Cocoa</a> framework (and related frameworks, such as <a href="/wiki/Core_Foundation" title="Core Foundation">Core Foundation</a>) use manual reference counting, much like <a href="/wiki/Component_Object_Model" title="Component Object Model">COM</a>. However, as of <a href="/wiki/Mac_OS_X_v10.5" title="Mac OS X v10.5">Mac OS X v10.5</a>, Cocoa when used with Objective C 2.0 also has automatic garbage collection.</p>
<p><a name="Delphi" id="Delphi"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=12" title="Edit section: Delphi">edit</a>]</span> <span class="mw-headline">Delphi</span></h3>
<p>One language that uses reference counting for garbage collection is <a href="/wiki/Delphi_programming_language" title="Delphi programming language" class="mw-redirect">Delphi</a>. Delphi is not a completely garbage collected language, in that user-defined types must still be manually allocated and deallocated. It does provide automatic collection, however, for a few built-in types, such as strings, dynamic arrays, and interfaces, for ease of use and to simplify the generic database functionality. It is important to note that it is up to the programmer to decide whether to use the built-in types or not; Delphi programmers have complete access to low-level memory management like in C/C++. So all potential cost of Delphi's reference counting can, if desired, be easily circumvented.</p>
<p>Some of the reasons reference counting may have been preferred to other forms of garbage collection in Delphi include:</p>
<ul>
<li>The general benefits of reference counting, such as prompt collection.</li>
<li>Cycles either cannot occur or do not occur in practice using only the small set of garbage-collected built-in types.</li>
<li>The overhead in code size required for reference counting is very small (typically a single LOCK INC or LOCK DEC instruction, which ensures atomicity in any environment), and no separate thread of control is needed for collection as would be needed for a tracing garbage collector.</li>
<li>Many instances of the most commonly used garbage-collected type, the string, have a short lifetime, since they are typically intermediate values in string manipulation.</li>
<li>The reference count of a string is checked before mutating a string. This allows reference count 1 strings to be mutated directly whilst higher reference count strings are copied before mutation. This allows the general behaviour of old style pascal strings to be preserved whilst eliminating the cost of copying the string on every assignment.</li>
<li>Because garbage-collection is only done on built-in types, reference counting can be efficiently integrated into the library routines used to manipulate each datatype, keeping the overhead needed for updating of reference counts low.</li>
</ul>
<p><a name="GObject" id="GObject"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=13" title="Edit section: GObject">edit</a>]</span> <span class="mw-headline">GObject</span></h3>
<p>The <a href="/wiki/GObject" title="GObject">GObject</a> object-oriented programming framework implements reference counting on its base types, including <a href="/wiki/Weak_reference" title="Weak reference">weak references</a>. Reference incrementing and decrementing uses <a href="/wiki/Atomic_operation" title="Atomic operation">atomic operations</a> for thread safety. A significant amount of the work in writing bindings to GObject from high-level languages lies in adapting GObject reference counting to work with the language's own memory management system.</p>
<p><a name="PHP" id="PHP"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=14" title="Edit section: PHP">edit</a>]</span> <span class="mw-headline">PHP</span></h3>
<p><a href="/wiki/PHP" title="PHP">PHP</a> uses a reference counting mechanism for its internal variable management. Since PHP 5.3, it implements the algorithm from Bacon's above mentioned paper. PHP allows you to turn on and off the cycle collection with user-level functions. It also allows you to manually force the purging mechanism to be run.</p>
<p><a name="Python" id="Python"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=15" title="Edit section: Python">edit</a>]</span> <span class="mw-headline">Python</span></h3>
<p><a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a> also uses reference counting and offers cycle detection as well. See <a href="http://www.python.org/doc/2.4.2/ext/refcounts.html" class="external text" title="http://www.python.org/doc/2.4.2/ext/refcounts.html" rel="nofollow">Extending and Embedding the Python Interpreter</a>.</p>
<p><a name="Squirrel" id="Squirrel"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=16" title="Edit section: Squirrel">edit</a>]</span> <span class="mw-headline">Squirrel</span></h3>
<p><a href="/wiki/Squirrel_programming_language" title="Squirrel programming language" class="mw-redirect">Squirrel</a> also uses reference counting and offers cycle detection as well. This tiny language is relatively unknown outside the video game industry; however, it is a concrete example of how reference counting can be practical and efficient (especially in realtime environments).</p>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=17" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<div class="references-small">
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> <cite style="font-style:normal" class="" id="CITEREF.5B.5BHenry_Baker_.28computer_scientist.29.7CHenry_Baker.5D.5D1994"><a href="/wiki/Henry_Baker_(computer_scientist)" title="Henry Baker (computer scientist)">Henry Baker</a> (September 1994). "<a href="http://citeseer.ist.psu.edu/baker94minimizing.html" class="external text" title="http://citeseer.ist.psu.edu/baker94minimizing.html" rel="nofollow">Minimizing Reference Count Updating with Deferred and Anchored Pointers for Functional Data Structures</a>". <i><a href="/wiki/ACM_SIGPLAN_Notices" title="ACM SIGPLAN Notices" class="mw-redirect">ACM SIGPLAN Notices</a></i> <b>29</b> (9): 38–43. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<span class="neverexpand"><a href="http://dx.doi.org/10.1145%2F185009.185016" class="external text" title="http://dx.doi.org/10.1145%2F185009.185016" rel="nofollow">10.1145/185009.185016</a></span><span class="printonly">. <a href="http://citeseer.ist.psu.edu/baker94minimizing.html" class="external free" title="http://citeseer.ist.psu.edu/baker94minimizing.html" rel="nofollow">http://citeseer.ist.psu.edu/baker94minimizing.html</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Minimizing+Reference+Count+Updating+with+Deferred+and+Anchored+Pointers+for+Functional+Data+Structures&amp;rft.jtitle=%5B%5BACM+SIGPLAN+Notices%5D%5D&amp;rft.aulast=%5B%5BHenry+Baker+%28computer+scientist%29%7CHenry+Baker%5D%5D&amp;rft.au=%5B%5BHenry+Baker+%28computer+scientist%29%7CHenry+Baker%5D%5D&amp;rft.date=September+1994&amp;rft.volume=29&amp;rft.issue=9&amp;rft.pages=38%E2%80%9343&amp;rft_id=info:doi/10.1145%2F185009.185016&amp;rft_id=http%3A%2F%2Fciteseer.ist.psu.edu%2Fbaker94minimizing.html&amp;rfr_id=info:sid/en.wikipedia.org:Reference_counting"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-1"><b><a href="#cite_ref-1" title="">^</a></b> <cite style="font-style:normal">Stephen Blackburn, Kathryn McKinley (2003). "<a href="http://cs.anu.edu.au/~Steve.Blackburn/pubs/abstracts.html#urc-oopsla-2003" class="external text" title="http://cs.anu.edu.au/~Steve.Blackburn/pubs/abstracts.html#urc-oopsla-2003" rel="nofollow">Ulterior Reference Counting: Fast Garbage Collection without a Long Wait</a>" in <i><a href="/wiki/OOPSLA" title="OOPSLA">OOPSLA</a> 2003</i>. <i>Proceedings of the 18th annual ACM SIGPLAN conference on Object-oriented programing, systems, languages, and applications</i>: 344–358. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<a href="http://dx.doi.org/10.1145/949305.949336" class="external text" title="http://dx.doi.org/10.1145/949305.949336" rel="nofollow">10.1145/949305.949336</a>. <a href="/wiki/Special:BookSources/1581137125" class="internal">ISBN 1-58113-712-5</a>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=proceeding&amp;rft.btitle=Proceedings+of+the+18th+annual+ACM+SIGPLAN+conference+on+Object-oriented+programing%2C+systems%2C+languages%2C+and+applications&amp;rft.atitle=Ulterior+Reference+Counting%3A+Fast+Garbage+Collection+without+a+Long+Wait&amp;rft.au=Stephen+Blackburn%2C+Kathryn+McKinley&amp;rft.date=2003&amp;rft.pages=344%E2%80%93358&amp;rft_id=info:doi/10.1145%2F949305.949336&amp;rft_id=http%3A%2F%2Fcs.anu.edu.au%2F%7ESteve.Blackburn%2Fpubs%2Fabstracts.html%23urc-oopsla-2003"><span style="display: none;">&#160;</span></span></li>
</ol>
</div>
<p><span class="boilerplate" id="foldoc"><i>This article was originally based on material from the <a href="/wiki/Free_On-line_Dictionary_of_Computing" title="Free On-line Dictionary of Computing">Free On-line Dictionary of Computing</a>, which is <a href="/wiki/Wikipedia:Foldoc_license" title="Wikipedia:Foldoc license">licensed</a> under the <a href="/wiki/GNU_Free_Documentation_License" title="GNU Free Documentation License">GFDL</a>.</i></span></p>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Reference_counting&amp;action=edit&amp;section=18" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://www.memorymanagement.org/articles/recycle.html#reference" class="external text" title="http://www.memorymanagement.org/articles/recycle.html#reference" rel="nofollow">The Memory Manager Reference: Beginner's Guide: Recycling: Reference Counts</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.955" class="external text" title="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.955" rel="nofollow"><i>Minimizing Reference Count Updating with Deferred and Anchored Pointers for Functional Data Structures</i>, Henry G. Baker</a></li>
<li><a href="http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf" class="external text" title="http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf" rel="nofollow"><i>Concurrent Cycle Collection in Reference Counted Systems</i>, David F. Bacon</a></li>
<li><a href="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.pdf" class="external text" title="http://www.cs.technion.ac.il/%7Eerez/Papers/refcount.pdf" rel="nofollow"><i>An On-the-Fly Reference-Counting Garbage Collector for Java</i>, Yossi Levanoni and Erez Petrank</a></li>
<li><a href="http://www.sdmagazine.com/documents/s=9730/cuj0412f/" class="external text" title="http://www.sdmagazine.com/documents/s=9730/cuj0412f/" rel="nofollow"><i>Atomic Reference Counting Pointers: A lock-free, async-free, thread-safe, multiprocessor-safe reference counting pointer</i>, Kirk Reinholtz</a></li>
<li><a href="http://www.python.org/doc/2.4.2/ext/refcounts.html" class="external text" title="http://www.python.org/doc/2.4.2/ext/refcounts.html" rel="nofollow"><i>Extending and Embedding the Python Interpreter: Extending Python with C or C++: Reference Counts</i>, Guido van Rossum</a></li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 728/1000000
Post-expand include size: 8555/2048000 bytes
Template argument size: 3414/2048000 bytes
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:26490-0!1!0!default!!en!2 and timestamp 20090411085318 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Reference_counting">http://en.wikipedia.org/wiki/Reference_counting</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Garbage_collection_(computer_science)" title="Category:Garbage collection (computer science)">Garbage collection (computer science)</a></span> | <span dir='ltr'><a href="/wiki/Category:Memory_management" title="Category:Memory management">Memory management</a></span></div><div id="mw-hidden-catlinks" class="mw-hidden-cats-hidden">Hidden categories:&#32;<span dir='ltr'><a href="/wiki/Category:Wikipedia_articles_incorporating_text_from_FOLDOC" title="Category:Wikipedia articles incorporating text from FOLDOC">Wikipedia articles incorporating text from FOLDOC</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Reference_counting" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Reference_counting" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Reference_counting&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Reference_counting&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Reference_counting" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Reference_counting" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Reference_counting" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Reference_counting&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Reference_counting&amp;oldid=283142900" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Reference_counting&amp;id=283142900">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Referenzz%C3%A4hlung">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Conteo_de_referencias">Español</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Reference_counting">Italiano</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Reference_counting">Polski</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D1%81%D1%87%D1%91%D1%82_%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA">Русский</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 11 April 2009, at 08:53 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv133 in 0.048 secs. --></body></html>
