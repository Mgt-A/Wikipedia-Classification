<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Microcode,AMD Am2900,Ad hoc,Allen Newell,Analytical engine,Arithmetic and logic unit,Arithmetic logic unit,Assembly,Assembly language,B1700,Backwards compatibility" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Microcode&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Microcode&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Microcode - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Microcode";
		var wgTitle = "Microcode";
		var wgAction = "view";
		var wgArticleId = "19999";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 279429072;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Microcode skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Microcode</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p><b>Microcode</b> is a layer of lowest-level instructions involved in the implementation of <a href="/wiki/Machine_code" title="Machine code">machine code</a> instructions in many computers and other processors; it resides in a special high-speed memory and translates machine instructions into sequences of detailed circuit-level operations. It helps separate the machine instructions from the underlying electronics so that instructions can be designed and altered more freely. It also makes it feasible to build complex multi-step instructions while still reducing the complexity of the electronic circuitry compared to other methods. Writing microcode is called <b>microprogramming</b> and the microcode for a given processor is often called a <b>microprogram</b>.</p>
<p>The microcode is normally written by the CPU engineer during the design phase. It is generally not meant to be visible or changeable by a normal programmer, nor even an <a href="/wiki/Assembly" title="Assembly">assembly</a> programmer. Unlike machine code which often retains <a href="/wiki/Backwards_compatibility" title="Backwards compatibility" class="mw-redirect">backwards compatibility</a>, microcode only runs on the exact CPU model for which it's designed. Microcode can be used to let one <a href="/wiki/Microarchitecture" title="Microarchitecture">microarchitecture</a> <a href="/wiki/Emulator" title="Emulator">emulate</a> another, usually more powerful, architecture.</p>
<p>Some hardware vendors, especially <a href="/wiki/IBM" title="IBM">IBM</a>, also use the term <i>microcode</i> as a synonym for <i><a href="/wiki/Firmware" title="Firmware">firmware</a></i>, whether or not it actually implements the microprogramming of a processor.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup> Even simple firmware, such as the one used in a <a href="/wiki/Hard_drive" title="Hard drive" class="mw-redirect">hard drive</a>, is sometimes described as microcode.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1" title=""><span>[</span>2<span>]</span></a></sup> Such use is not discussed here.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1"><a href="#The_reason_for_microprogramming"><span class="tocnumber">2</span> <span class="toctext">The reason for microprogramming</span></a>
<ul>
<li class="toclevel-2"><a href="#Other_benefits"><span class="tocnumber">2.1</span> <span class="toctext">Other benefits</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#History"><span class="tocnumber">3</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1"><a href="#Examples_of_microprogrammed_systems"><span class="tocnumber">4</span> <span class="toctext">Examples of microprogrammed systems</span></a></li>
<li class="toclevel-1"><a href="#Implementation"><span class="tocnumber">5</span> <span class="toctext">Implementation</span></a>
<ul>
<li class="toclevel-2"><a href="#Horizontal_microcode"><span class="tocnumber">5.1</span> <span class="toctext">Horizontal microcode</span></a></li>
<li class="toclevel-2"><a href="#Vertical_microcode"><span class="tocnumber">5.2</span> <span class="toctext">Vertical microcode</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Writable_control_stores"><span class="tocnumber">6</span> <span class="toctext">Writable control stores</span></a></li>
<li class="toclevel-1"><a href="#Risks"><span class="tocnumber">7</span> <span class="toctext">Risks</span></a></li>
<li class="toclevel-1"><a href="#Microcode_versus_VLIW_and_RISC"><span class="tocnumber">8</span> <span class="toctext">Microcode versus VLIW and RISC</span></a></li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">9</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">10</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#Further_reading"><span class="tocnumber">11</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">12</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Overview" id="Overview"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a>]</span> <span class="mw-headline">Overview</span></h2>
<p>The elements composing a microprogram exist on a lower conceptual level than a normal application program. Each element is differentiated by the "micro" prefix to avoid confusion: microinstruction, microassembler, microprogrammer, microarchitecture, etc.</p>
<p>The microcode usually does not reside in the <a href="/wiki/Main_memory" title="Main memory" class="mw-redirect">main memory</a>, but in a special high speed memory, called the <a href="/wiki/Control_store" title="Control store">control store</a>. It might be either <a href="/wiki/Read-only_memory" title="Read-only memory">read-only</a> or <a href="/wiki/Read-write_memory" title="Read-write memory">read-write memory</a>. In the latter case the microcode would be loaded into the control store from some other storage medium as part of the initialization of the CPU, and it could be altered to correct bugs in the instruction set, or to implement new machine instructions.</p>
<p>Microprograms consist of series of microinstructions. These microinstructions control the CPU at a very fundamental level of hardware circuitry. For example, a single typical microinstruction might specify the following operations:</p>
<ul>
<li>Connect Register 1 to the "A" side of the <a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">ALU</a></li>
<li>Connect Register 7 to the "B" side of the <a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">ALU</a></li>
<li>Set the ALU to perform two's-complement addition</li>
<li>Set the ALU's carry input to zero</li>
<li>Store the result value in Register 8</li>
<li>Update the "condition codes" with the ALU status flags ("Negative", "Zero", "Overflow", and "Carry")</li>
<li>Microjump to MicroPC nnn for the next microinstruction</li>
</ul>
<p>To simultaneously control all processor's features in one cycle, the microinstruction is often as wide as 50 or more bits. Microprograms are carefully designed and optimized for the fastest possible execution, since a slow microprogram would yield a slow machine instruction which would in turn cause all programs using that instruction to be slow.</p>
<p><a name="The_reason_for_microprogramming" id="The_reason_for_microprogramming"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=2" title="Edit section: The reason for microprogramming">edit</a>]</span> <span class="mw-headline">The reason for microprogramming</span></h2>
<p>Microcode was originally developed as a simpler method of developing the control logic for a computer. Initially CPU <a href="/wiki/Instruction_set" title="Instruction set">instruction sets</a> were "<a href="/wiki/Hardwired_control" title="Hardwired control">hard wired</a>". Each step needed to fetch, decode and execute the machine instructions (including any operand address calculations, reads and writes) was controlled directly by <a href="/wiki/Combinatorial_logic" title="Combinatorial logic" class="mw-redirect">combinatorial logic</a> and rather minimal <a href="/wiki/Sequential_circuit" title="Sequential circuit" class="mw-redirect">sequential</a> state machine circuitry. While very efficient, the need for powerful instruction sets with multi-step addressing and complex operations (<i>see below</i>) made such "hard-wired" processors difficult to design and debug; highly encoded and varied-length instructions can contribute to this as well, especially when very irregular encodings are used.</p>
<p>Microcode simplified the job by allowing much of the processor's behaviour and programming model be defined via microprogram routines rather than by dedicated circuitry. Even late in the design process, microcode could easily be changed, whereas hard wired CPU designs were very cumbersome to change, so this greatly facilitated CPU design.</p>
<p>In the 1940s through the late 1970s, much programming was done in <a href="/wiki/Assembly_language" title="Assembly language">assembly language</a>; higher level instructions meant greater programmer productivity, so an important advantage of microcode was the relative ease by which powerful machine instructions could be defined. <sup id="cite_ref-2" class="reference"><a href="#cite_note-2" title=""><span>[</span>3<span>]</span></a></sup> During the 1970s, CPU speeds grew more quickly than memory speeds and numerous techniques such as <a href="/w/index.php?title=Memory_block_transfer&amp;action=edit&amp;redlink=1" class="new" title="Memory block transfer (page does not exist)">memory block transfer</a>, <a href="/w/index.php?title=Memory_pre-fetch&amp;action=edit&amp;redlink=1" class="new" title="Memory pre-fetch (page does not exist)">memory pre-fetch</a> and <a href="/wiki/Memory_hierarchy" title="Memory hierarchy">multi-level caches</a> were used to alleviate this. High level machine instructions, made possible by microcode, helped further, as fewer more complex machine instructions require less memory bandwidth. For example, an operation on a character string could be done as a single machine instruction, thus avoiding multiple instruction fetches.</p>
<p>Architectures with instruction sets implemented by complex microprograms included the <a href="/wiki/IBM" title="IBM">IBM</a> <a href="/wiki/System/360" title="System/360" class="mw-redirect">System/360</a> and <a href="/wiki/Digital_Equipment_Corporation" title="Digital Equipment Corporation">Digital Equipment Corporation</a> <a href="/wiki/VAX" title="VAX">VAX</a>. The approach of increasingly complex microcode-implemented instruction sets was later called <a href="/wiki/Complex_instruction_set_computer" title="Complex instruction set computer">CISC</a>. A middle way, used in many <a href="/wiki/Microprocessor" title="Microprocessor">microprocessors</a>, is to use <a href="/wiki/Programmable_logic_array" title="Programmable logic array">PLAs</a> and/or <a href="/wiki/Read-only_memory" title="Read-only memory">ROMs</a> (instead of combinatorial logic) mainly for instruction decoding, and let a simple state machine (without much, or any, microcode) do most of the sequencing. The various practical uses of microcode and related techniques (such as PLAs) have been numerous over the years, as well as approaches to where, and to which extent, it should be used. It is still used in modern CPU designs.</p>
<p><a name="Other_benefits" id="Other_benefits"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=3" title="Edit section: Other benefits">edit</a>]</span> <span class="mw-headline">Other benefits</span></h3>
<p>A processor's microprograms operate on a more primitive, totally different and much more hardware-oriented architecture than the assembly instructions visible to normal programmers. In coordination with the hardware, the microcode implements the programmer-visible architecture. The underlying hardware need not have a fixed relationship to the visible architecture. This makes it possible to implement a given instruction set architecture on a wide variety of underlying hardware micro-architectures.</p>
<p>Doing so is important if binary program compatibility is a priority. That way previously existing programs can run on totally new hardware without requiring revision and recompilation. However there may be a performance penalty for this approach. The tradeoffs between application backward compatibility vs CPU performance are hotly debated by CPU design engineers.</p>
<p>The IBM System/360 has a 32-bit architecture with 16 general-purpose registers, but most of the System/360 implementations actually use hardware that implemented a much simpler underlying microarchitecture; for example, the System/360 Model 30 had 8-bit data paths to the <a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">arithmetic logic unit</a> (ALU) and main memory and implemented the general-purpose registers in a special unit of higher-speed <a href="/wiki/Core_memory" title="Core memory" class="mw-redirect">core memory</a>, and the System/360 Model 40 had 8-bit data paths to the ALU and 16-bit data paths to main memory and also implemented the general-purpose registers in a special unit of higher-speed core memory. The Model 50 and Model 65 had full 32-bit data paths and implemented the general-purpose registers in faster transistor circuits. In this way, microprogramming enabled IBM to design many System/360 models with substantially different hardware and spanning a wide range of cost and performance, while making them all architecturally compatible. This dramatically reduced the amount of unique system software that had to be written for each model.</p>
<p>A similar approach was used by Digital Equipment Corporation in their VAX family of computers. Initially a 32-bit <a href="/wiki/Transistor-transistor_logic" title="Transistor-transistor logic" class="mw-redirect">TTL</a> processor in conjunction with supporting microcode implemented the programmer-visible architecture. Later VAX versions used different microarchitectures, yet the programmer-visible architecture didn't change.</p>
<p>Microprogramming also reduced the cost of field changes to correct defects (<a href="/wiki/Computer_bug" title="Computer bug" class="mw-redirect">bugs</a>) in the processor; a bug could often be fixed by replacing a portion of the microprogram rather than by changes being made to hardware logic and wiring.</p>
<p><a name="History" id="History"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=4" title="Edit section: History">edit</a>]</span> <span class="mw-headline">History</span></h2>
<p>In 1947, the design of the <a href="/wiki/Whirlwind_(computer)" title="Whirlwind (computer)">MIT Whirlwind</a> introduced the concept of a <a href="/wiki/Control_store" title="Control store">control store</a> as a way to simplify computer design and move beyond <i><a href="/wiki/Ad_hoc" title="Ad hoc">ad hoc</a></i> methods. The control store was a two-dimensional lattice: one dimension accepted "control time pulses" from the CPU's internal clock, and the other connected to control signals on gates and other circuits. A "pulse distributor" would take the pulses generated by the CPU clock and break them up into eight separate time pulses, each of which would activate a different row of the lattice. When the row was activated, it would activate the control signals connected to it.</p>
<p>Described another way, the signals transmitted by the control store are being played much like a <a href="/wiki/Player_piano" title="Player piano">player piano</a> roll. That is, they are controlled by a sequence of very wide words constructed of <a href="/wiki/Bit" title="Bit">bits</a>, and they are "played" sequentially. In a control store, however, the "song" is short and repeated continuously.</p>
<p>In 1951 <a href="/wiki/Maurice_Wilkes" title="Maurice Wilkes">Maurice Wilkes</a> enhanced this concept by adding <i>conditional execution</i>, a concept akin to a <a href="/wiki/Conditional_statement" title="Conditional statement" class="mw-redirect">conditional</a> in computer software. His initial implementation consisted of a pair of matrices, the first one generated signals in the manner of the Whirlwind control store, while the second matrix selected which row of signals (the microprogram instruction word, as it were) to invoke on the next cycle. Conditionals were implemented by providing a way that a single line in the control store could choose from alternatives in the second matrix. This made the control signals conditional on the detected internal signal. Wilkes coined the term <b>microprogramming</b> to describe this feature and distinguish it from a simple control store.</p>
<p><a name="Examples_of_microprogrammed_systems" id="Examples_of_microprogrammed_systems"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=5" title="Edit section: Examples of microprogrammed systems">edit</a>]</span> <span class="mw-headline">Examples of microprogrammed systems</span></h2>
<ul>
<li>In common with many other complex mechanical devices, <a href="/wiki/Charles_Babbage" title="Charles Babbage">Charles Babbage's</a> <a href="/wiki/Analytical_engine" title="Analytical engine">analytical engine</a> used banks of cams to control each operation, i.e. it had a read-only control store. As such it deserves to be recognised as the first microprogrammed computer to be designed, even if it has not yet been realised in hardware.</li>
<li>Most models of the IBM System/360 series were microprogrammed:</li>
</ul>
<dl>
<dd>
<ul>
<li>The Model 25 was unique among System/360 models in using the top 16k bytes of core storage to hold the control storage for the microprogram. The 2025 used a 16-bit microarchitecture with seven control words (or microinstructions). At power up, or full system reset, the microcode was loaded from the card reader. The IBM 1410 emulation for this model was loaded this way.</li>
<li>The <a href="/wiki/IBM_2030" title="IBM 2030">Model 30</a>, the slowest model in the line, used an 8-bit microarchitecture with only a few hardware registers; everything that the programmer saw was emulated by the microprogram. The microcode for this model was also held on special punched cards, which were stored inside the machine in a dedicated reader per card, called "CROS" units (Capacitor Read-Only Storage). A second CROS reader was installed for machines ordered with 1620 emulation.</li>
<li>The Model 40 used 56-bit control words. The 2040 box implements both the System/360 main processor and the multiplex channel (the I/O processor). This model used "TROS" dedicated readers similar to "CROS" units, but with an inductive pickup (Transformer Read-only Store).</li>
<li>The Model 50 had two internal datapaths which operated in parallel: a 32-bit datapath used for arithmetic operations, and an 8-bit data path used in some logical operations. The control store used 90-bit microinstructions.</li>
<li>The Model 85 had separate instruction fetch (I-unit) and execution (E-unit) to provide high performance. The I-unit is hardware controlled. The E-unit is microprogrammed with 108-bit control words.</li>
</ul>
</dd>
</dl>
<ul>
<li>The <a href="/wiki/NCR_315" title="NCR 315">NCR 315</a> was microprogrammed with hand wired ferrite cores (a <a href="/wiki/ROM" title="ROM" class="mw-redirect">ROM</a>) pulsed by a sequencer with conditional execution. Wires routed through the cores were enables for various data and logic elements in the processor.</li>
<li>The Digital Equipment Corporation <a href="/wiki/PDP-11" title="PDP-11">PDP-11</a> processors, with the exception of the PDP-11/20, were microprogrammed<sup id="cite_ref-3" class="reference"><a href="#cite_note-3" title=""><span>[</span>4<span>]</span></a></sup>.</li>
<li>Many systems from the <a href="/wiki/Burroughs_Corporation" title="Burroughs Corporation">Burroughs</a> were microprogrammed:</li>
</ul>
<dl>
<dd>
<ul>
<li>The B700 "microprocessor" executed application-level opcodes using sequences of 16-bit microinstructions stored in main memory, each of these was either a register-load operation or mapped to a single 56-bit "nanocode" instruction stored in read-only memory. This allowed comparatively simple hardware to act either as a mainframe peripheral controller or to be packaged as a standalone computer.</li>
<li>The <a href="/wiki/B1700" title="B1700" class="mw-redirect">B1700</a> was implemented with radically different hardware including bit-addressable main memory but had a similar multi-layer organisation. The operating system would preload the interpreter for whatever language was required. These interpreters presented different virtual machines for COBOL, Fortran, etc.</li>
</ul>
</dd>
</dl>
<ul>
<li><a href="/wiki/Microdata" title="Microdata">Microdata</a> produced computers in which the microcode was accessible to the user; this allowed the creation of custom assembler level instructions. Microdata's <a href="/wiki/Pick_operating_system" title="Pick operating system">Reality</a> operating system design made extensive use of this capability.</li>
<li>The VU0 and VU1 vector units in the Sony Playstation 2 are microprogrammable; in fact, VU1 was <i>only</i> accessible via microcode for the first several generations of the SDK.</li>
</ul>
<p><a name="Implementation" id="Implementation"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=6" title="Edit section: Implementation">edit</a>]</span> <span class="mw-headline">Implementation</span></h2>
<p>Each microinstruction in a microprogram provides the bits which control the functional elements that internally compose a CPU. The advantage over a hard-wired CPU is that internal CPU control becomes a specialized form of a computer program. Microcode thus transforms a complex electronic design challenge (the control of a CPU) into a less-complex programming challenge.</p>
<p>To take advantage of this, computers were divided into several parts:</p>
<p>A <a href="/wiki/Microsequencer" title="Microsequencer">microsequencer</a> picked the next word of the <a href="/wiki/Control_store" title="Control store">control store</a>. A sequencer is mostly a counter, but usually also has some way to jump to a different part of the control store depending on some data, usually data from the <a href="/wiki/Instruction_register" title="Instruction register">instruction register</a> and always some part of the control store. The simplest sequencer is just a register loaded from a few bits of the control store.</p>
<p>A <a href="/wiki/Processor_register" title="Processor register">register</a> set is a fast memory containing the data of the central processing unit. It may include the program counter, stack pointer, and other numbers that are not easily accessible to the application programmer. Often the register set is a triple-ported <a href="/wiki/Register_file" title="Register file">register file</a>, that is, two registers can be read, and a third written at the same time.</p>
<p>An <a href="/wiki/Arithmetic_and_logic_unit" title="Arithmetic and logic unit" class="mw-redirect">arithmetic and logic unit</a> performs calculations, usually addition, logical negation, a right shift, and logical AND. It often performs other functions, as well.</p>
<p>There may also be a <a href="/wiki/Memory_address_register" title="Memory address register">memory address register</a> and a <a href="/wiki/Memory_data_register" title="Memory data register">memory data register</a>, used to access the main <a href="/wiki/Computer_storage" title="Computer storage" class="mw-redirect">computer storage</a>.</p>
<p>Together, these elements form an "<a href="/wiki/Execution_unit" title="Execution unit">execution unit</a>." Most modern <a href="/wiki/Central_processing_unit" title="Central processing unit">CPUs</a> have several execution units. Even simple computers usually have one unit to read and write memory, and another to execute user code.</p>
<p>These elements could often be bought together as a single chip. This chip came in a fixed width which would form a 'slice' through the execution unit. These were known as '<a href="/wiki/Bit_slicing" title="Bit slicing">bit slice</a>' chips. The <a href="/wiki/AMD_Am2900" title="AMD Am2900">AMD Am2900</a> family is one of the best known examples of bit slice elements.</p>
<p>The parts of the execution units, and the execution units themselves are interconnected by a bundle of wires called a <a href="/wiki/Computer_bus" title="Computer bus" class="mw-redirect">bus</a>.</p>
<p>Programmers develop microprograms. The basic tools are software: A <a href="/wiki/Microassembler" title="Microassembler">microassembler</a> allows a programmer to define the table of bits symbolically. A <a href="/wiki/Simulator" title="Simulator" class="mw-redirect">simulator</a> program executes the bits in the same way as the electronics (hopefully), and allows much more freedom to debug the microprogram.</p>
<p>After the microprogram is finalized, and extensively tested, it is sometimes used as the input to a computer program that constructs logic to produce the same data. This program is similar to those used to optimize a <a href="/wiki/Programmable_logic_device" title="Programmable logic device">programmable logic array</a>. No known computer program can produce optimal logic, but even pretty good logic can vastly reduce the number of transistors from the number required for a ROM control store. This reduces the cost and power used by a CPU.</p>
<p>Microcode can be characterized as <b>horizontal</b> or <b>vertical</b>. This refers primarily to whether each microinstruction directly controls CPU elements (horizontal microcode), or requires subsequent decoding by <a href="/wiki/Combinational_logic" title="Combinational logic">combinational logic</a> before doing so (vertical microcode). Consequently each horizontal microinstruction is wider (contains more bits) and occupies more storage space than a vertical microinstruction.</p>
<p><a name="Horizontal_microcode" id="Horizontal_microcode"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=7" title="Edit section: Horizontal microcode">edit</a>]</span> <span class="mw-headline">Horizontal microcode</span></h3>
<p>Horizontal microcode is typically contained in a fairly wide control store, it is not uncommon for each word to be 56 bits or more. On each tick of a sequencer clock a microcode word is read, decoded, and used to control the functional elements which make up the CPU.</p>
<p>In a typical implementation a horizontal microprogram word comprises fairly tightly defined groups of bits. For example, one simple arrangement might be:</p>
<table class="wikitable">
<tr>
<td>register source A</td>
<td>register source B</td>
<td>destination register</td>
<td><a href="/wiki/Arithmetic_and_logic_unit" title="Arithmetic and logic unit" class="mw-redirect">arithmetic and logic unit</a> operation</td>
<td>type of jump</td>
<td>jump address</td>
</tr>
</table>
<p>For this type of micromachine to implement a JUMP instruction with the address following the opcode, the microcode might require two clock ticks; the engineer designing it would write microassembler source code looking something like this:</p>
<pre>
   # Any line starting with a number-sign is a comment
   # This is just a label, the ordinary way assemblers symbolically represent a 
   # memory address.
InstructionJUMP:
      # To prepare for the next instruction, the instruction-decode microcode has already
      # moved the program counter to the memory address register.  This instruction fetches
      # the target address of the jump instruction from the memory word following the
      # jump opcode, by copying from the memory data register to the memory address register.
      # This gives the memory system two clock ticks to fetch the next 
      # instruction to the memory data register for use by the instruction decode.
      # The sequencer instruction "next" means just add 1 to the control word address.
   MDR, NONE, MAR,  COPY, NEXT, NONE
      # This places the address of the next instruction into the PC.
      # This gives the memory system a clock tick to finish the fetch started on the
      # previous microinstruction.
      # The sequencer instruction is to jump to the start of the instruction decode.
   MAR, 1, PC, ADD,  JMP,  InstructionDecode
      # The instruction decode is not shown, because it's usually a mess, very particular
      # to the exact processor being emulated.  Even this example is simplified.
      # Many CPUs have several ways to calculate the address, rather than just fetching
      # it from the word following the op-code. Therefore, rather than just one
      # jump instruction, those CPUs have a family of related jump instructions.
</pre>
<p>For each tick it is common to find that only some portions of the CPU are used, with the remaining groups of bits in the microinstruction being no-ops. With careful design of hardware and microcode this property can be exploited to parallelise operations which use different areas of the CPU, for example in the case above the ALU is not required during the first tick so it could potentially be used to complete an earlier arithmetic instruction.</p>
<p><a name="Vertical_microcode" id="Vertical_microcode"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=8" title="Edit section: Vertical microcode">edit</a>]</span> <span class="mw-headline">Vertical microcode</span></h3>
<p>In vertical microcode, each microinstruction is encoded -- that is, the bit fields may pass through intermediate combinatory logic which in turn generates the actual control signals for internal CPU elements (ALU, registers, etc.). In contrast, with horizontal microcode the bit fields themselves directly produce the control signals. Consequently vertical microcode requires smaller instruction lengths and less storage, but requires more time to decode, resulting in a slower CPU clock.</p>
<p>Some vertical microcodes are just the assembly language of a simple conventional computer that is emulating a more complex computer. This technique was popular in the time of the <a href="/wiki/PDP-8" title="PDP-8">PDP-8</a>. Another form of vertical microcode has two fields:</p>
<table class="wikitable">
<tr>
<td>field select</td>
<td>field value</td>
</tr>
</table>
<p>The "field select" selects which part of the CPU will be controlled by this word of the control store. The "field value" actually controls that part of the CPU. With this type of microcode, a designer explicitly chooses to make a slower CPU to save money by reducing the unused bits in the control store; however, the reduced complexity may increase the CPU's clock frequency, which lessens the effect of an increased number of cycles per instruction.</p>
<p>As transistors became cheaper, horizontal microcode came to dominate the design of CPUs using microcode, with vertical microcode no longer being used.</p>
<p><a name="Writable_control_stores" id="Writable_control_stores"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=9" title="Edit section: Writable control stores">edit</a>]</span> <span class="mw-headline">Writable control stores</span></h2>
<p>A few computers were built using "writable microcode" -- rather than storing the microcode in ROM or hard-wired logic, the microcode was stored in a RAM called a <i>Writable Control Store</i> or <i>WCS</i>. Such a computer is sometimes called a <i>Writable Instruction Set Computer</i> or <i>WISC</i>.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4" title=""><span>[</span>5<span>]</span></a></sup> Many of these machines were experimental laboratory prototypes, such as the WISC CPU/16<sup id="cite_ref-5" class="reference"><a href="#cite_note-5" title=""><span>[</span>6<span>]</span></a></sup> and the RTX 32P<sup id="cite_ref-6" class="reference"><a href="#cite_note-6" title=""><span>[</span>7<span>]</span></a></sup>.</p>
<p>There were also commercial machines that used writable microcode, such as early <a href="/wiki/Xerox_PARC" title="Xerox PARC" class="mw-redirect">Xerox</a> workstations, the <a href="/wiki/Digital_Equipment_Corporation" title="Digital Equipment Corporation">DEC</a> <a href="/wiki/VAX" title="VAX">VAX</a> 8800 ("Nautilus") family, the <a href="/wiki/Symbolics" title="Symbolics">Symbolics</a> L- and G-machines, and a number of <a href="/wiki/IBM" title="IBM">IBM</a> <a href="/wiki/System/370" title="System/370" class="mw-redirect">System/370</a> implementations. Some DEC <a href="/wiki/PDP-10" title="PDP-10">PDP-10</a> machines stored their microcode in SRAM chips (about 80 bits wide x 2 Kwords), which was typically loaded on power-on through some other front-end CPU<a href="http://pdp10.nocrew.org/cpu/kl10-ucode.txt" class="external autonumber" title="http://pdp10.nocrew.org/cpu/kl10-ucode.txt" rel="nofollow">[1]</a>. Many more machines offered user-programmable writeable control stores as an option (including the <a href="/wiki/Hewlett-Packard" title="Hewlett-Packard">HP</a> <a href="/wiki/HP_2100" title="HP 2100">2100</a> and DEC <a href="/wiki/PDP-11" title="PDP-11">PDP-11/60</a> <a href="/wiki/Minicomputer" title="Minicomputer">minicomputers</a>). WCS offered several advantages including the ease of patching the microprogram and, for certain hardware generations, faster access than ROMs could provide. User-programmable WCS allowed the user to optimize the machine for specific purposes.</p>
<p>Some CPU designs compile the instruction set to a writable <a href="/wiki/RAM" title="RAM" class="mw-redirect">RAM</a> or <a href="/wiki/Flash_memory" title="Flash memory">FLASH</a> inside the CPU (such as the <a href="/wiki/Rekursiv" title="Rekursiv">Rekursiv</a> processor and the <a href="/w/index.php?title=Imsys&amp;action=edit&amp;redlink=1" class="new" title="Imsys (page does not exist)">Imsys</a> <a href="/w/index.php?title=Cjip&amp;action=edit&amp;redlink=1" class="new" title="Cjip (page does not exist)">Cjip</a>)<a href="http://cpushack.net/CPU/cpu7.html" class="external autonumber" title="http://cpushack.net/CPU/cpu7.html" rel="nofollow">[2]</a>, or an FPGA (<a href="/wiki/Reconfigurable_computing" title="Reconfigurable computing">reconfigurable computing</a>). The <a href="/wiki/Western_Digital" title="Western Digital">Western Digital</a> <a href="/wiki/MCP-1600" title="MCP-1600">MCP-1600</a> is an older example, using a dedicated, separate ROM for microcode.</p>
<p>A CPU that uses microcode generally takes several clock cycles to execute a single instruction, one clock cycle for each step in the microprogram for that instruction. Some <a href="/wiki/Complex_instruction_set_computer" title="Complex instruction set computer">CISC</a> processors include instructions that can take a very long time to execute. Such variations interfere with both <a href="/wiki/Interrupt" title="Interrupt">interrupt</a> <a href="/wiki/Latency_(engineering)" title="Latency (engineering)">latency</a> and, what is far more important in modern systems, <a href="/wiki/Pipelining" title="Pipelining" class="mw-redirect">pipelining</a>.</p>
<p>Several Intel CPUs in the IA32 architecture family have writable microcode<sup id="cite_ref-7" class="reference"><a href="#cite_note-7" title=""><span>[</span>8<span>]</span></a></sup>. This has allowed bugs in the <a href="/wiki/Intel_Core_2" title="Intel Core 2">Intel Core 2</a> microcode and <a href="/wiki/Intel_Xeon" title="Intel Xeon" class="mw-redirect">Intel Xeon</a> microcode to be fixed in software, rather than requiring the entire chip to be replaced. Such fixes can be installed by Linux<sup id="cite_ref-8" class="reference"><a href="#cite_note-8" title=""><span>[</span>9<span>]</span></a></sup>, Microsoft Windows<sup id="cite_ref-9" class="reference"><a href="#cite_note-9" title=""><span>[</span>10<span>]</span></a></sup>, or the motherboard BIOS<sup id="cite_ref-10" class="reference"><a href="#cite_note-10" title=""><span>[</span>11<span>]</span></a></sup>.</p>
<p><a name="Risks" id="Risks"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=10" title="Edit section: Risks">edit</a>]</span> <span class="mw-headline">Risks</span></h2>
<p>Linux (on x86 PCs) has a patch program that fixes botched CPU microcode. Of all UNIX (and UNIX-like) operating systems on Intel (and Intel x86-compatible) PCs there has been an ongoing requirement to patch erroneous microcode since the <a href="/wiki/Pentium_FDIV_bug" title="Pentium FDIV bug">FPU multiplier problem</a> that was endemic to some Pentiums.</p>
<ul>
<li>Microsoft Windows also has similar patches, but does generally not label them as such since Windows XP.</li>
<li>So far only x86 CPUs have microcode patches. This is unknown with RISC CPUs as well as general purpose DSPs.</li>
</ul>
<p><a name="Microcode_versus_VLIW_and_RISC" id="Microcode_versus_VLIW_and_RISC"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=11" title="Edit section: Microcode versus VLIW and RISC">edit</a>]</span> <span class="mw-headline">Microcode versus VLIW and RISC</span></h2>
<p>The design trend toward heavily microcoded processors with complex instructions began in the early 1960s and continued until roughly the mid-1980s. At that point the <a href="/wiki/RISC" title="RISC" class="mw-redirect">RISC</a> design philosophy started becoming more prominent. This included the points:</p>
<ul>
<li>Analysis shows complex instructions are rarely used, hence the machine resources devoted to them are largely wasted.</li>
<li>Programming has largely moved away from assembly level, so it's no longer worthwhile to provide complex instructions for productivity reasons.</li>
<li>The machine resources devoted to rarely-used complex instructions are better used for expediting performance of simpler, commonly-used instructions.</li>
<li>Complex microcoded instructions requiring many, varying clock cycles are difficult to pipeline for increased performance.</li>
<li>Simpler instruction sets allow direct execution by hardware, avoiding the performance penalty of microcoded execution.</li>
</ul>
<p>It should be mentioned that there are counter-points as well:</p>
<ul>
<li>The complex instructions in heavily microcoded implementations may not take much extra machine resources (except microcode space); for instance, the same ALU is often used to calculate an effective address as well as computing the result from the actual operands.</li>
<li>Non-RISC instructions, i.e. involving direct memory <a href="/wiki/Operand" title="Operand">operands</a> are frequently used by modern compilers, even immediate to stack (i.e. memory result) arithmetic operations are commonly employed. Although such memory operations, often with varying length encodings (i.e. the "CISC" characteristics), are more difficult to pipeline, it is still fully feasible, clearly exemplified by the <a href="/wiki/Intel_486" title="Intel 486" class="mw-redirect">Intel 486</a>, <a href="/wiki/Cyrix_6x86" title="Cyrix 6x86">Cyrix 6x86</a>, etc.</li>
<li>Non-RISC instructions inherently perform more work per instruction (on average), and are also normally highly encoded, so they enable smaller overall size of the same program, and thus better use of limited cache memories.</li>
<li>Modern CISC implementations, most notably the <a href="/wiki/X86" title="X86">x86</a>, implement most instructions and all addressing modes "in hardware"; microcode is still used however, for some really complex, or very special, instructions (such as <a href="/wiki/CPUID" title="CPUID">CPUID</a>), as well as for internal "housekeeping".</li>
</ul>
<p>Many <a href="/wiki/RISC" title="RISC" class="mw-redirect">RISC</a> and <a href="/wiki/Very_long_instruction_word" title="Very long instruction word">VLIW</a> processors are designed to execute every instruction (as long as it is in the cache) in a single cycle. This is very similar to the way CPUs with microcode execute one microinstruction per cycle. <a href="/wiki/Very_long_instruction_word" title="Very long instruction word">VLIW</a> processors have instructions that behave similarly to very wide horizontal microcode, although typically without such fine-grained control over the hardware as provided by microcode. RISC instructions are sometimes similar to the narrow vertical microcode.</p>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=12" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/Firmware" title="Firmware">Firmware</a></li>
<li><a href="/wiki/Control_unit" title="Control unit">Control unit</a></li>
<li><a href="/wiki/Finite_state_machine" title="Finite state machine">Finite state machine</a></li>
<li><a href="/wiki/Microsequencer" title="Microsequencer">Microsequencer</a></li>
<li><a href="/wiki/Microassembler" title="Microassembler">Microassembler</a></li>
<li><a href="/wiki/Control_store" title="Control store">Control store</a></li>
<li><a href="/wiki/Execution_unit" title="Execution unit">Execution unit</a></li>
<li><a href="/wiki/Arithmetic_logic_unit" title="Arithmetic logic unit">Arithmetic logic unit</a></li>
<li><a href="/wiki/Floating_point_unit" title="Floating point unit" class="mw-redirect">Floating point unit</a></li>
<li><a href="/wiki/Instruction_pipeline" title="Instruction pipeline">Instruction pipeline</a></li>
<li><a href="/wiki/Superscalar" title="Superscalar">Superscalar</a></li>
<li><a href="/wiki/Microarchitecture" title="Microarchitecture">Microarchitecture</a></li>
<li><a href="/wiki/CPU_design" title="CPU design">CPU design</a></li>
</ul>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=13" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<div class="references-small">
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> <a href="http://www14.software.ibm.com/webapp/set2/firmware/gjsn" class="external free" title="http://www14.software.ibm.com/webapp/set2/firmware/gjsn" rel="nofollow">http://www14.software.ibm.com/webapp/set2/firmware/gjsn</a> IBM "Microcode downloads" (showing use of the term "microcode")</li>
<li id="cite_note-1"><b><a href="#cite_ref-1" title="">^</a></b> <a href="http://download.boulder.ibm.com/ibmdl/pub/software/server/firmware/73lzx.html" class="external free" title="http://download.boulder.ibm.com/ibmdl/pub/software/server/firmware/73lzx.html" rel="nofollow">http://download.boulder.ibm.com/ibmdl/pub/software/server/firmware/73lzx.html</a> "Microcode Update for SCSI Hard Disk"</li>
<li id="cite_note-2"><b><a href="#cite_ref-2" title="">^</a></b> The ultimate extension of this were "Directly Executable High Level Language" designs. In these each statement of a high level language such as <a href="/wiki/PL/I" title="PL/I">PL/I</a> would be entirely and directly executed by microcode, without compilation. The <a href="/wiki/IBM_Future_Systems_project" title="IBM Future Systems project">IBM Future Systems project</a> and <a href="/wiki/Data_General" title="Data General">Data General</a> Fountainhead Processor were examples of this.</li>
<li id="cite_note-3"><b><a href="#cite_ref-3" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFDaniel_P._Siewiorek.2C_.5B.5BC._Gordon_Bell.5D.5D.2C_.5B.5BAllen_Newell.5D.5D1982">Daniel P. Siewiorek, <a href="/wiki/C._Gordon_Bell" title="C. Gordon Bell" class="mw-redirect">C. Gordon Bell</a>, <a href="/wiki/Allen_Newell" title="Allen Newell">Allen Newell</a> (1982). <i>Computer Structures: Principles and Examples</i>. <a href="/wiki/New_York,_NY" title="New York, NY" class="mw-redirect">New York, NY</a>: <a href="/wiki/McGraw-Hill" title="McGraw-Hill">McGraw-Hill Book Company</a>. <a href="/wiki/Special:BookSources/0070573026" class="internal">ISBN 0-07-057302-6</a>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Computer+Structures%3A+Principles+and+Examples&amp;rft.aulast=Daniel+P.+Siewiorek%2C+%5B%5BC.+Gordon+Bell%5D%5D%2C+%5B%5BAllen+Newell%5D%5D&amp;rft.au=Daniel+P.+Siewiorek%2C+%5B%5BC.+Gordon+Bell%5D%5D%2C+%5B%5BAllen+Newell%5D%5D&amp;rft.date=1982&amp;rft.place=%5B%5BNew+York%2C+NY%5D%5D&amp;rft.pub=%5B%5BMcGraw-Hill%7CMcGraw-Hill+Book+Company%5D%5D&amp;rft.isbn=0-07-057302-6&amp;rfr_id=info:sid/en.wikipedia.org:Microcode"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-4"><b><a href="#cite_ref-4" title="">^</a></b> <a href="http://www.ece.cmu.edu/~koopman/forth/rochester_87.pdf" class="external text" title="http://www.ece.cmu.edu/~koopman/forth/rochester_87.pdf" rel="nofollow">"Writable instruction set, stack oriented computers: The WISC Concept"</a> article by Philip Koopman Jr. 1987</li>
<li id="cite_note-5"><b><a href="#cite_ref-5" title="">^</a></b> <a href="http://www.ece.cmu.edu/~koopman/stack_computers/sec4_2.html" class="external text" title="http://www.ece.cmu.edu/~koopman/stack_computers/sec4_2.html" rel="nofollow">"Architecture of the WISC CPU/16"</a> by Phil Koopman 1989</li>
<li id="cite_note-6"><b><a href="#cite_ref-6" title="">^</a></b> <a href="http://www.ece.cmu.edu/~koopman/stack_computers/sec5_3.html" class="external text" title="http://www.ece.cmu.edu/~koopman/stack_computers/sec5_3.html" rel="nofollow">"Architecture of the RTX 32P"</a> by Philip Koopman 1989</li>
<li id="cite_note-7"><b><a href="#cite_ref-7" title="">^</a></b> <a href="http://www.intel.com/design/processor/manuals/253669.pdf" class="external text" title="http://www.intel.com/design/processor/manuals/253669.pdf" rel="nofollow">"Intel(R) 64 and IA-32 Architectures Software Developer’s Manual"</a>, chapter 26.4: "Microcode update facility"</li>
<li id="cite_note-8"><b><a href="#cite_ref-8" title="">^</a></b> <a href="http://urbanmyth.org/microcode/" class="external text" title="http://urbanmyth.org/microcode/" rel="nofollow">"Intel Microcode Update Utility for Linux"</a></li>
<li id="cite_note-9"><b><a href="#cite_ref-9" title="">^</a></b> <a href="http://support.microsoft.com/kb/936357" class="external text" title="http://support.microsoft.com/kb/936357" rel="nofollow">"A microcode reliability update is available that improves the reliability of systems that use Intel processors"</a></li>
<li id="cite_note-10"><b><a href="#cite_ref-10" title="">^</a></b> <a href="http://www.intel.com/support/motherboards/server/sb/cs-021619.htm" class="external text" title="http://www.intel.com/support/motherboards/server/sb/cs-021619.htm" rel="nofollow">"BIOS Update required when Missing Microcode message is seen during POST"</a></li>
</ol>
</div>
<ul>
<li><cite style="font-style:normal" class="" id="CITEREFEverett.2C_R.R..2C_and_Swain.2C_F.E.1947">Everett, R.R., and Swain, F.E. (1947) (PDF). <i><a href="http://www.cs.stthomas.edu/faculty/resmith/papers/WhirlwindR-127.pdf" class="external text" title="http://www.cs.stthomas.edu/faculty/resmith/papers/WhirlwindR-127.pdf" rel="nofollow">Whirlwind I Computer Block Diagrams</a></i>. Report R-127. MIT Servomechanisms Laboratory<span class="printonly">. <a href="http://www.cs.stthomas.edu/faculty/resmith/papers/WhirlwindR-127.pdf" class="external free" title="http://www.cs.stthomas.edu/faculty/resmith/papers/WhirlwindR-127.pdf" rel="nofollow">http://www.cs.stthomas.edu/faculty/resmith/papers/WhirlwindR-127.pdf</a></span><span class="reference-accessdate">. Retrieved on 2006-06-21</span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Whirlwind+I+Computer+Block+Diagrams&amp;rft.aulast=Everett%2C+R.R.%2C+and+Swain%2C+F.E.&amp;rft.au=Everett%2C+R.R.%2C+and+Swain%2C+F.E.&amp;rft.date=1947&amp;rft.series=Report+R-127&amp;rft.pub=MIT+Servomechanisms+Laboratory&amp;rft_id=http%3A%2F%2Fwww.cs.stthomas.edu%2Ffaculty%2Fresmith%2Fpapers%2FWhirlwindR-127.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Microcode"><span style="display: none;">&#160;</span></span></li>
<li><cite style="font-style:normal" class="" id="CITEREFSmith.2C_Richard_E.1988">Smith, Richard E. (1988). "<a href="http://doi.ieeecomputersociety.org/10.1109/MAHC.1988.10039" class="external text" title="http://doi.ieeecomputersociety.org/10.1109/MAHC.1988.10039" rel="nofollow">A Historical Overview of Computer Architecture</a>". <i>Annals of the History of Computing</i> <b>10</b> (4): 277–303. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<span class="neverexpand"><a href="http://dx.doi.org/10.1109%2FMAHC.1988.10039" class="external text" title="http://dx.doi.org/10.1109%2FMAHC.1988.10039" rel="nofollow">10.1109/MAHC.1988.10039</a></span><span class="printonly">. <a href="http://doi.ieeecomputersociety.org/10.1109/MAHC.1988.10039" class="external free" title="http://doi.ieeecomputersociety.org/10.1109/MAHC.1988.10039" rel="nofollow">http://doi.ieeecomputersociety.org/10.1109/MAHC.1988.10039</a></span><span class="reference-accessdate">. Retrieved on 2006-06-21</span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=A+Historical+Overview+of+Computer+Architecture&amp;rft.jtitle=Annals+of+the+History+of+Computing&amp;rft.aulast=Smith%2C+Richard+E.&amp;rft.au=Smith%2C+Richard+E.&amp;rft.date=1988&amp;rft.volume=10&amp;rft.issue=4&amp;rft.pages=277%26ndash%3B303&amp;rft_id=info:doi/10.1109%2FMAHC.1988.10039&amp;rft_id=http%3A%2F%2Fdoi.ieeecomputersociety.org%2F10.1109%2FMAHC.1988.10039&amp;rfr_id=info:sid/en.wikipedia.org:Microcode"><span style="display: none;">&#160;</span></span></li>
<li><cite style="font-style:normal" class="" id="CITEREFSmotherman.2C_Mark2005">Smotherman, Mark (2005). <i><a href="http://www.cs.clemson.edu/~mark/uprog.html" class="external text" title="http://www.cs.clemson.edu/~mark/uprog.html" rel="nofollow">A Brief History of Microprogramming</a></i><span class="printonly">. <a href="http://www.cs.clemson.edu/~mark/uprog.html" class="external free" title="http://www.cs.clemson.edu/~mark/uprog.html" rel="nofollow">http://www.cs.clemson.edu/~mark/uprog.html</a></span><span class="reference-accessdate">. Retrieved on 2006-07-30</span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=A+Brief+History+of+Microprogramming&amp;rft.aulast=Smotherman%2C+Mark&amp;rft.au=Smotherman%2C+Mark&amp;rft.date=2005&amp;rft_id=http%3A%2F%2Fwww.cs.clemson.edu%2F%7Emark%2Fuprog.html&amp;rfr_id=info:sid/en.wikipedia.org:Microcode"><span style="display: none;">&#160;</span></span></li>
<li><cite style="font-style:normal" class="" id="CITEREFWilkes.2C_M.V.1986">Wilkes, M.V. (1986). "<a href="http://doi.ieeecomputersociety.org/10.1109/MAHC.1986.10035" class="external text" title="http://doi.ieeecomputersociety.org/10.1109/MAHC.1986.10035" rel="nofollow">The Genesis of Microprogramming</a>". <i>Annals of the History of Computing</i> <b>8</b> (2): 116–126. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<span class="neverexpand"><a href="http://dx.doi.org/10.1109%2FMAHC.1986.10035" class="external text" title="http://dx.doi.org/10.1109%2FMAHC.1986.10035" rel="nofollow">10.1109/MAHC.1986.10035</a></span><span class="printonly">. <a href="http://doi.ieeecomputersociety.org/10.1109/MAHC.1986.10035" class="external free" title="http://doi.ieeecomputersociety.org/10.1109/MAHC.1986.10035" rel="nofollow">http://doi.ieeecomputersociety.org/10.1109/MAHC.1986.10035</a></span><span class="reference-accessdate">. Retrieved on 2006-08-07</span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=The+Genesis+of+Microprogramming&amp;rft.jtitle=Annals+of+the+History+of+Computing&amp;rft.aulast=Wilkes%2C+M.V.&amp;rft.au=Wilkes%2C+M.V.&amp;rft.date=1986&amp;rft.volume=8&amp;rft.issue=2&amp;rft.pages=116%26ndash%3B126&amp;rft_id=info:doi/10.1109%2FMAHC.1986.10035&amp;rft_id=http%3A%2F%2Fdoi.ieeecomputersociety.org%2F10.1109%2FMAHC.1986.10035&amp;rfr_id=info:sid/en.wikipedia.org:Microcode"><span style="display: none;">&#160;</span></span></li>
<li><cite style="font-style:normal" class="" id="CITEREFWilkes.2C_M.V..2C_and_Stringer.2C_J._B.1953">Wilkes, M.V., and Stringer, J. B. (April 1953). "<a href="http://research.microsoft.com/~gbell/Computer_Structures_Principles_and_Examples/csp0174.htm" class="external text" title="http://research.microsoft.com/~gbell/Computer_Structures_Principles_and_Examples/csp0174.htm" rel="nofollow">Microprogramming and the Design of the Control Circuits in an Electronic Digital Computer</a>". <i>Proc. Cambridge Phil. Soc</i> <b>49</b> (pt. 2): 230–238. <a href="/wiki/Digital_object_identifier" title="Digital object identifier">doi</a>:<span class="neverexpand"><a href="http://dx.doi.org/10.1017%2FS0305004100028322" class="external text" title="http://dx.doi.org/10.1017%2FS0305004100028322" rel="nofollow">10.1017/S0305004100028322</a></span><span class="printonly">. <a href="http://research.microsoft.com/~gbell/Computer_Structures_Principles_and_Examples/csp0174.htm" class="external free" title="http://research.microsoft.com/~gbell/Computer_Structures_Principles_and_Examples/csp0174.htm" rel="nofollow">http://research.microsoft.com/~gbell/Computer_Structures_Principles_and_Examples/csp0174.htm</a></span><span class="reference-accessdate">. Retrieved on 2006-08-23</span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Microprogramming+and+the+Design+of+the+Control++Circuits+in+an+Electronic+Digital+Computer&amp;rft.jtitle=Proc.+Cambridge+Phil.+Soc&amp;rft.aulast=Wilkes%2C+M.V.%2C+and+Stringer%2C+J.+B.&amp;rft.au=Wilkes%2C+M.V.%2C+and+Stringer%2C+J.+B.&amp;rft.date=April+1953&amp;rft.volume=49&amp;rft.issue=pt.+2&amp;rft.pages=230%E2%80%93238&amp;rft_id=info:doi/10.1017%2FS0305004100028322&amp;rft_id=http%3A%2F%2Fresearch.microsoft.com%2F%7Egbell%2FComputer_Structures_Principles_and_Examples%2Fcsp0174.htm&amp;rfr_id=info:sid/en.wikipedia.org:Microcode"><span style="display: none;">&#160;</span></span></li>
<li><cite style="font-style:normal" class="book" id="CITEREFHusson.2C_S.S1970">Husson, S.S (1970). <i>Microprogramming Principles and Practices</i>. Prentice-Hall. <a href="/wiki/Special:BookSources/0135814545" class="internal">ISBN 0-13-581454-5</a>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Microprogramming+Principles+and+Practices&amp;rft.aulast=Husson%2C+S.S&amp;rft.au=Husson%2C+S.S&amp;rft.date=1970&amp;rft.pub=Prentice-Hall&amp;rft.isbn=0-13-581454-5&amp;rfr_id=info:sid/en.wikipedia.org:Microcode"><span style="display: none;">&#160;</span></span></li>
</ul>
<p><a name="Further_reading" id="Further_reading"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=14" title="Edit section: Further reading">edit</a>]</span> <span class="mw-headline">Further reading</span></h2>
<ul>
<li>Tucker, S. G., <a href="http://domino.research.ibm.com/tchjr/journalindex.nsf/a3807c5b4823c53f85256561006324be/758c1e6a8a3e5d0285256bfa00685a2f?OpenDocument" class="external text" title="http://domino.research.ibm.com/tchjr/journalindex.nsf/a3807c5b4823c53f85256561006324be/758c1e6a8a3e5d0285256bfa00685a2f?OpenDocument" rel="nofollow">"Microprogram control for SYSTEM/360"</a> <i>IBM Systems Journal</i>, Volume 6, Number 4, pp.222-241 (1967)</li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Microcode&amp;action=edit&amp;section=15" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://c2.com/cgi/wiki?WritableInstructionSetComputer" class="external text" title="http://c2.com/cgi/wiki?WritableInstructionSetComputer" rel="nofollow">Writable Instruction Set Computer</a></li>
<li><a href="http://www.research.ibm.com/journal/rd/102/ibmrd1002F.pdf" class="external text" title="http://www.research.ibm.com/journal/rd/102/ibmrd1002F.pdf" rel="nofollow">Capacitor Read-only Store</a></li>
<li><a href="http://www-03.ibm.com/ibm/history/exhibits/attic3/attic3_016.html" class="external text" title="http://www-03.ibm.com/ibm/history/exhibits/attic3/attic3_016.html" rel="nofollow">Transformer Read-only Store</a></li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 3659/1000000
Post-expand include size: 28124/2048000 bytes
Template argument size: 9586/2048000 bytes
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:19999-0!1!0!default!!en!2 and timestamp 20090403232650 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Microcode">http://en.wikipedia.org/wiki/Microcode</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Instruction_processing" title="Category:Instruction processing">Instruction processing</a></span> | <span dir='ltr'><a href="/wiki/Category:Firmware" title="Category:Firmware">Firmware</a></span> | <span dir='ltr'><a href="/wiki/Category:Central_processing_unit" title="Category:Central processing unit">Central processing unit</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Microcode" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Microcode" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Microcode&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Microcode&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Microcode" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Microcode" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Microcode" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Microcode&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Microcode&amp;oldid=279429072" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Microcode&amp;id=279429072">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-bs"><a href="http://bs.wikipedia.org/wiki/Mikroprogram">Bosanski</a></li>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Mikroprogrammsteuerwerk">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Microc%C3%B3digo">Español</a></li>
				<li class="interwiki-fa"><a href="http://fa.wikipedia.org/wiki/%D8%B1%DB%8C%D8%B2%D8%A8%D8%B1%D9%86%D8%A7%D9%85%D9%87%E2%80%8C%D8%B3%D8%A7%D8%B2%DB%8C">فارسی</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Microcode">Français</a></li>
				<li class="interwiki-ko"><a href="http://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%BD%94%EB%93%9C">한국어</a></li>
				<li class="interwiki-hr"><a href="http://hr.wikipedia.org/wiki/Mikroprogramiranje">Hrvatski</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Microprogrammazione">Italiano</a></li>
				<li class="interwiki-nl"><a href="http://nl.wikipedia.org/wiki/Microcode">Nederlands</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E6%96%B9%E5%BC%8F">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Mikroprogram">Polski</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D0%BA%D0%BE%D0%B4">Русский</a></li>
				<li class="interwiki-simple"><a href="http://simple.wikipedia.org/wiki/Microprogram">Simple English</a></li>
				<li class="interwiki-sr"><a href="http://sr.wikipedia.org/wiki/%D0%9C%D0%B8%D0%BA%D1%80%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC">Српски / Srpski</a></li>
				<li class="interwiki-sh"><a href="http://sh.wikipedia.org/wiki/Mikroprogramiranje">Srpskohrvatski / Српскохрватски</a></li>
				<li class="interwiki-fi"><a href="http://fi.wikipedia.org/wiki/Mikro-ohjelma">Suomi</a></li>
				<li class="interwiki-sv"><a href="http://sv.wikipedia.org/wiki/Mikroprogram">Svenska</a></li>
				<li class="interwiki-tr"><a href="http://tr.wikipedia.org/wiki/Mikroprogramlama">Türkçe</a></li>
				<li class="interwiki-uk"><a href="http://uk.wikipedia.org/wiki/%D0%9C%D1%96%D0%BA%D1%80%D0%BE%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%B0">Українська</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E5%BE%AE%E7%A8%8B%E5%BA%8F">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 24 March 2009, at 19:57.</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv190 in 0.060 secs. --></body></html>
