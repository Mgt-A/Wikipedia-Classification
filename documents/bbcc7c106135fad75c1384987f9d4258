<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Tower of Hanoi,Special:Search/Tower of Hanoi,1,000,000,000 (number),Adventure game,Algorithm,Azada (video game),Backup rotation scheme,Backups,Baguenaudier,Binary numeral system,Bit" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Tower of Hanoi - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Tower_of_Hanoi";
		var wgTitle = "Tower of Hanoi";
		var wgAction = "view";
		var wgArticleId = "56990";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 283293370;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
<style type="text/css">/*<![CDATA[*/
.source-pascal {line-height: normal;}
.source-pascal li, .source-pascal pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for pascal
 * CSS class: source-pascal, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-pascal .de1, .source-pascal .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-pascal  {}
.source-pascal .head {}
.source-pascal .foot {}
.source-pascal .imp {font-weight: bold; color: red;}
.source-pascal .ln-xtra {color: #cc0; background-color: #ffc;}
.source-pascal li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-pascal li.li2 {font-weight: bold;}
.source-pascal .kw1 {color: #b1b100;}
.source-pascal .kw2 {color: #000000; font-weight: bold;}
.source-pascal .kw3 {}
.source-pascal .kw4 {color: #993333;}
.source-pascal .co1 {color: #808080; font-style: italic;}
.source-pascal .co2 {color: #339933;}
.source-pascal .coMULTI {color: #808080; font-style: italic;}
.source-pascal .es0 {color: #000099; font-weight: bold;}
.source-pascal .br0 {color: #66cc66;}
.source-pascal .st0 {color: #ff0000;}
.source-pascal .nu0 {color: #cc66cc;}
.source-pascal .me1 {color: #202020;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-scheme {line-height: normal;}
.source-scheme li, .source-scheme pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for scheme
 * CSS class: source-scheme, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-scheme .de1, .source-scheme .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-scheme  {}
.source-scheme .head {}
.source-scheme .foot {}
.source-scheme .imp {font-weight: bold; color: red;}
.source-scheme .ln-xtra {color: #cc0; background-color: #ffc;}
.source-scheme li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-scheme li.li2 {font-weight: bold;}
.source-scheme .kw1 {color: #b1b100;}
.source-scheme .co1 {color: #808080; font-style: italic;}
.source-scheme .coMULTI {color: #808080; font-style: italic;}
.source-scheme .es0 {color: #000099; font-weight: bold;}
.source-scheme .br0 {color: #66cc66;}
.source-scheme .st0 {color: #ff0000;}
.source-scheme .nu0 {color: #cc66cc;}
.source-scheme .me0 {color: #202020;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
</style>		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Tower_of_Hanoi skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Tower of Hanoi</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<div class="thumb tright">
<div class="thumbinner" style="width:302px;"><a href="/wiki/File:Tower_of_Hanoi.jpeg" class="image" title="A model set of the Towers of Hanoi (with 8 disks)"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/0/07/Tower_of_Hanoi.jpeg/300px-Tower_of_Hanoi.jpeg" width="300" height="132" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Tower_of_Hanoi.jpeg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
A model set of the Towers of Hanoi (with 8 disks)</div>
</div>
</div>
<div class="thumb tright">
<div class="thumbinner" style="width:302px;"><a href="/wiki/File:Tower_of_Hanoi_4.gif" class="image" title="An animated solution of the Tower of Hanoi puzzle for T(4,3)."><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/6/60/Tower_of_Hanoi_4.gif" width="300" height="117" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Tower_of_Hanoi_4.gif" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
An animated solution of the <b>Tower of Hanoi</b> puzzle for <i>T(4,3)</i>.</div>
</div>
</div>
<p>The <b>Tower of Hanoi</b> or <b>Towers of <a href="/wiki/Hanoi" title="Hanoi">Hanoi</a></b> (also known as <b>The Towers of <a href="/wiki/Brahma" title="Brahma">Brahma</a></b>) is a <a href="/wiki/Mathematical_game" title="Mathematical game">mathematical game</a> or <a href="/wiki/Puzzle" title="Puzzle">puzzle</a>. It consists of three rods, and a number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks neatly stacked in order of size on one rod, the smallest at the top, thus making a conical shape.</p>
<p>The objective of the puzzle is to move the entire stack to another rod, obeying the following rules:</p>
<ul>
<li>Only one disk may be moved at a time.</li>
<li>Each move consists of taking the upper disk from one of the rods and sliding it onto another rod, on top of the other disks that may already be present on that rod.</li>
<li>No disk may be placed on top of a smaller disk.</li>
</ul>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Origins"><span class="tocnumber">1</span> <span class="toctext">Origins</span></a></li>
<li class="toclevel-1"><a href="#Solution"><span class="tocnumber">2</span> <span class="toctext">Solution</span></a>
<ul>
<li class="toclevel-2"><a href="#Simple_solution"><span class="tocnumber">2.1</span> <span class="toctext">Simple solution</span></a></li>
<li class="toclevel-2"><a href="#Recursive_solution"><span class="tocnumber">2.2</span> <span class="toctext">Recursive solution</span></a></li>
<li class="toclevel-2"><a href="#Logical_analysis_of_the_recursive_solution"><span class="tocnumber">2.3</span> <span class="toctext">Logical analysis of the recursive solution</span></a></li>
<li class="toclevel-2"><a href="#Non-recursive_solution"><span class="tocnumber">2.4</span> <span class="toctext">Non-recursive solution</span></a></li>
<li class="toclevel-2"><a href="#Binary_solutions"><span class="tocnumber">2.5</span> <span class="toctext">Binary solutions</span></a></li>
<li class="toclevel-2"><a href="#Gray_code_solution"><span class="tocnumber">2.6</span> <span class="toctext">Gray code solution</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Long_solutions"><span class="tocnumber">3</span> <span class="toctext">Long solutions</span></a></li>
<li class="toclevel-1"><a href="#Graphical_representation"><span class="tocnumber">4</span> <span class="toctext">Graphical representation</span></a></li>
<li class="toclevel-1"><a href="#Applications"><span class="tocnumber">5</span> <span class="toctext">Applications</span></a></li>
<li class="toclevel-1"><a href="#Four_pegs_and_beyond"><span class="tocnumber">6</span> <span class="toctext">Four pegs and beyond</span></a>
<ul>
<li class="toclevel-2"><a href="#Frame-Stewart_algorithm"><span class="tocnumber">6.1</span> <span class="toctext">Frame-Stewart algorithm</span></a></li>
<li class="toclevel-2"><a href="#Two_stacks_and_more_stacks"><span class="tocnumber">6.2</span> <span class="toctext">Two stacks and more stacks</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#In_popular_culture"><span class="tocnumber">7</span> <span class="toctext">In popular culture</span></a>
<ul>
<li class="toclevel-2"><a href="#In_video_games"><span class="tocnumber">7.1</span> <span class="toctext">In video games</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#Notes"><span class="tocnumber">9</span> <span class="toctext">Notes</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Origins" id="Origins"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=1" title="Edit section: Origins">edit</a>]</span> <span class="mw-headline">Origins</span></h2>
<div class="thumb tright">
<div class="thumbinner" style="width:182px;"><a href="/wiki/File:Hanoi_Flagtower.jpg" class="image" title="Flag Tower of Hanoi"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/96/Hanoi_Flagtower.jpg/180px-Hanoi_Flagtower.jpg" width="180" height="240" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Hanoi_Flagtower.jpg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Flag Tower of Hanoi</div>
</div>
</div>
<p>The puzzle was invented by the <a href="/wiki/French_people" title="French people">French</a> <a href="/wiki/Mathematician" title="Mathematician">mathematician</a> <a href="/wiki/%C3%89douard_Lucas" title="Édouard Lucas">Édouard Lucas</a> in 1883. There is a legend about a <a href="/wiki/Vietnam" title="Vietnam">Vietnamese</a> or <a href="/wiki/India" title="India">Indian</a> temple which contains a large room with three time-worn posts in it surrounded by 64 golden disks. The priests of <a href="/wiki/Brahma" title="Brahma">Brahma</a>, acting out the command of an ancient prophecy, have been moving these disks, in accordance with the rules of the puzzle, since that time. The puzzle is therefore also known as the Tower of <a href="/wiki/Brahma" title="Brahma">Brahma</a> puzzle. According to the legend, when the last move of the puzzle is completed, the world will end. It is not clear whether Lucas invented this legend or was inspired by it.</p>
<p>If the legend were true, and if the priests were able to move disks at a rate of one per second, using the smallest number of moves, it would take them 2<sup>64</sup>−1 seconds or roughly 600 <a href="/wiki/1,000,000,000_(number)" title="1,000,000,000 (number)" class="mw-redirect">billion</a> years<sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup>; it would take 18,446,744,073,709,551,615 turns to finish.</p>
<p>There are many variations on this legend. For instance, in some tellings, the temple is a <a href="/wiki/Monastery" title="Monastery">monastery</a> and the priests are <a href="/wiki/Monk" title="Monk">monks</a>. The temple or monastery may be said to be in different parts of the world — including <a href="/wiki/Hanoi" title="Hanoi">Hanoi</a>, <a href="/wiki/Vietnam" title="Vietnam">Vietnam</a>, and may be associated with any <a href="/wiki/Religion" title="Religion">religion</a>. In some versions, other elements are introduced, such as the fact that the tower was created at the beginning of the world, or that the priests or monks may make only one move per day.</p>
<p>However in recent years, experts have disputed Lucas' claim to inventing the puzzle. Instead, it is widely attributed to Harrison Heath, the famous pioneer of disc based puzzles. This new evidence was uncovered after allegations of fraud on behalf of Lucas, who many believe copied Heath's original idea for the game. <sup id="cite_ref-1" class="reference"><a href="#cite_note-1" title=""><span>[</span>2<span>]</span></a></sup></p>
<p>The <a href="/wiki/Flag_Tower_of_Hanoi" title="Flag Tower of Hanoi">Flag Tower of Hanoi</a> may have served as the inspiration for the name.</p>
<p><a name="Solution" id="Solution"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=2" title="Edit section: Solution">edit</a>]</span> <span class="mw-headline">Solution</span></h2>
<p>Most toy versions of the puzzle have 8 disks. The game seems impossible to many novices, yet is solvable with a simple <a href="/wiki/Algorithm" title="Algorithm">algorithm</a>.</p>
<p><a name="Simple_solution" id="Simple_solution"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=3" title="Edit section: Simple solution">edit</a>]</span> <span class="mw-headline">Simple solution</span></h3>
<p>The following solution is a simple solution for the toy puzzle.</p>
<p>Alternate moves between the smallest piece and a non-smallest piece. When moving the smallest piece, always move it in the same direction (to the right if the starting number of pieces is even, to the left if the starting number of pieces is odd). If there is no tower in the chosen direction, move the piece to the opposite end, but then continue to move in the correct direction. For example, if you started with three pieces, you would move the smallest piece to the opposite end, then continue in the left direction after that. When the turn is to move the non-smallest piece, there is only one legal move. Doing this should complete the puzzle using the least amount of moves to do so.</p>
<p><a name="Recursive_solution" id="Recursive_solution"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=4" title="Edit section: Recursive solution">edit</a>]</span> <span class="mw-headline">Recursive solution</span></h3>
<p>A key to solving this puzzle is to recognize that it can be solved by breaking the problem down into a collection of smaller problems and further breaking those problems down into even smaller problems until a solution is reached. The following procedure demonstrates this approach.</p>
<ul>
<li>label the pegs A, B, C -- these labels may move at different steps</li>
<li>let <i>n</i> be the total number of discs</li>
<li>number the discs from 1 (smallest, topmost) to <i>n</i> (largest, bottommost)</li>
</ul>
<p>To move n discs from peg A to peg B:</p>
<ol>
<li>move n−1 discs from A to C. This leaves disc #n alone on peg A</li>
<li>move disc #n from A to B</li>
<li>move n−1 discs from C to B so they sit on disc #n</li>
</ol>
<p>The above is a <a href="/wiki/Recursion#Recursive_algorithms" title="Recursion">recursive algorithm</a>: to carry out steps 1 and 3, apply the same algorithm again for <i>n</i>−1. The entire procedure is a finite number of steps, since at some point the algorithm will be required for <i>n</i> = 1. This step, moving a single disc from peg A to peg B, is trivial.</p>
<p>The Tower of Hanoi is often used as an example of a simple <a href="/wiki/Recursion" title="Recursion">recursive algorithm</a> when teaching introductory programming. Recursive solutions typically resemble the following <a href="/wiki/Pascal_(programming_language)" title="Pascal (programming language)">Pascal</a> code:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-pascal">
<span class="kw2">procedure</span> Hanoi<span class="br0">(</span>n: <span class="kw4">integer</span>; source, dest, by: <span class="kw4">char</span><span class="br0">)</span>;
<span class="kw1">Begin</span>
    <span class="kw1">if</span> <span class="br0">(</span>n=<span class="nu0">1</span><span class="br0">)</span> <span class="kw1">then</span>
        <span class="kw3">writeln</span><span class="br0">(</span><span class="st0">'Move the plate from '</span>, source, <span class="st0">' to '</span>, dest<span class="br0">)</span>
    <span class="kw1">else</span> <span class="kw1">begin</span>
        Hanoi<span class="br0">(</span>n<span class="nu0">-1</span>, source, by, dest<span class="br0">)</span>;
        Hanoi<span class="br0">(</span><span class="nu0">1</span>, source, dest, by<span class="br0">)</span>;
        Hanoi<span class="br0">(</span>n<span class="nu0">-1</span>, by, dest, source<span class="br0">)</span>;
    <span class="kw1">end</span>;
<span class="kw1">End</span>;
</pre></div>
<p>Implementations in many other languages may be found at the <a href="http://www.kernelthread.com/hanoi/" class="external text" title="http://www.kernelthread.com/hanoi/" rel="nofollow">Hanoimania!</a> website.</p>
<p><a name="Logical_analysis_of_the_recursive_solution" id="Logical_analysis_of_the_recursive_solution"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=5" title="Edit section: Logical analysis of the recursive solution">edit</a>]</span> <span class="mw-headline">Logical analysis of the recursive solution</span></h3>
<p>As in many mathematical puzzles, finding a solution is made easier by solving a slightly more general problem: how to move a tower of h (h=height) disks from a starting peg <b>f</b> (f=from) onto a destination peg <b>t</b> (t=to), <b>r</b> being the remaining third peg and assuming <img class="tex" alt="t\ne f" src="http://upload.wikimedia.org/math/e/d/6/ed6395f422ae11de70f368d138030bee.png" /> (<img class="tex" alt="1\le t,f\le 3" src="http://upload.wikimedia.org/math/0/7/3/073c3d11d86a883cf72d34136d27a98c.png" />). First, observe that the problem is symmetric for permutations of the names of the pegs (<a href="/wiki/Symmetric_group" title="Symmetric group">symmetric group S<sub><i>3</i></sub></a>). If a solution is known moving from peg <b>f</b> to peg <b>t</b>, then, by renaming the pegs, the same solution can be used for every other choice of starting and destination peg. If there is only one disk (or even none at all), the problem is trivial. If h=1, then simply move the disk from peg <b>f</b> to peg <b>t</b>. If h&gt;1, then somewhere along the sequence of moves, the largest disk must be moved from peg <b>f</b> to another peg, preferably to peg <b>t</b>. The only situation that allows this move is when all smaller h-1 disks are on peg <b>r</b>. Hence, first all h-1 smaller disks must go from <b>f</b> to <b>r</b>. Subsequently move the largest disk and finally move the h-1 smaller disks from peg <b>r</b> to peg <b>t</b>. The presence of the largest disk does not impede any move of the h-1 smaller disks and can temporarily be ignored. Now the problem is reduced to moving h-1 disks from one peg to another one, first from <b>f</b> to <b>r</b> and subsequently from <b>r</b> to <b>t</b>, but the same method can be used both times by renaming the pegs. The same strategy can be used to reduce the h-1 problem to h-2, h-3, and so on until only one disk is left. This is called <a href="/wiki/Recursion" title="Recursion">recursion</a>. This algorithm can be schematized as follows. Identify the disks in order of increasing size by the natural numbers from 0 up to but not including h. Hence disk 0 is the smallest one and disk h-1 the largest one.</p>
<p>The following is a procedure for moving a tower of h disks from a peg <b>f</b> onto a peg <b>t</b>, with <b>r</b> being the remaining third peg:</p>
<ul>
<li>Step 1: If h&gt;1 then first use this procedure to move the h-1 smaller disks from peg <b>f</b> to peg <b>r</b>.</li>
<li>Step 2: Now the largest disk, i.e. disk h-1 can be moved from peg <b>f</b> to peg <b>t</b>.</li>
<li>Step 3: If h&gt;1 then again use this procedure to move the h-1 smaller disks from peg <b>r</b> to peg <b>t</b>.</li>
</ul>
<p>By means of <a href="/wiki/Mathematical_induction" title="Mathematical induction">mathematical induction</a>, it is easily proven that the above procedure requires the minimal number of moves possible, and that the produced solution is the only one with this minimal number of moves. Using <a href="/wiki/Recurrence_relation" title="Recurrence relation">recurrence relations</a>, the exact number of moves that this solution requires can be calculated by: <span class="texhtml">2<sup><i>h</i></sup> − 1</span>. This result is obtained by noting that steps 1 and 3 take <span class="texhtml"><i>T</i><sub><i>h</i> − 1</sub></span> moves, and step 2 takes one move, giving <span class="texhtml"><i>T</i><sub><i>h</i></sub> = 2<i>T</i><sub><i>h</i> − 1</sub> + 1</span>.</p>
<p><a name="Non-recursive_solution" id="Non-recursive_solution"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=6" title="Edit section: Non-recursive solution">edit</a>]</span> <span class="mw-headline">Non-recursive solution</span></h3>
<p>The list of moves for a tower being carried from one peg onto another one, as produced by the recursive algorithm has many regularities. When counting the moves starting from 1, the ordinal of the disk to be moved during move <i>m</i> is the number of times <i>m</i> can be divided by 2. Hence every odd move involves the smallest disk. It can also be observed that the smallest disk traverses the pegs f, t, r, f, t, r, etc. for odd height of the tower and traverses the pegs f, r, t, f, r, t, etc. for even height of the tower. This provides the following algorithm, which is easier, carried out by hand, than the recursive algorithm.</p>
<p>In alternate moves:</p>
<ul>
<li>move the smallest disk to the peg it has not recently come from.</li>
<li>move another disk legally (there will be one possibility only)</li>
</ul>
<p>For the very first move, the smallest disk goes to peg t if h is odd and to peg r if h is even.</p>
<p>So if the number of disks is even the solution will start:</p>
<ol>
<li>Move disk 0 from peg f to peg r ignoring peg t.</li>
<li>Move disk 1 from peg f to peg t ignoring peg r.</li>
<li>Move disk 0 from peg r to peg t ignoring peg f.</li>
<li>Move disk 2 from peg f to peg r ignoring peg t.</li>
<li>Move disk 0 from peg t to peg f ignoring peg r.</li>
<li>Move disk 1 from peg t to peg r ignoring peg f.</li>
<li>Move disk 0 from peg f to peg r ignoring peg t.</li>
<li>Move disk 3 from peg f to peg t ignoring peg r.</li>
<li>Move disk 0 from peg r to peg t ignoring peg f.</li>
<li>Move disk 1 from peg r to peg f ignoring peg t.</li>
<li>Move disk 0 from peg t to peg f ignoring peg r.</li>
<li>Move disk 2 from peg r to peg t ignoring peg f.</li>
<li>Move disk 0 from peg f to peg r ignoring peg t.</li>
<li>Move disk 1 from peg f to peg t ignoring peg r.</li>
<li>Move disk 0 from peg r to peg t ignoring peg f.</li>
<li>Move disk 4 from peg f to peg r ignoring peg t.</li>
</ol>
<p>etc.</p>
<p>Also observe that:</p>
<ul>
<li>Disks whose ordinals have even parity move in the same sense as the smallest disk.</li>
<li>Disks whose ordinals have odd parity move in opposite sense.</li>
<li>If h is even, the remaining third peg during successive moves is t, r, f, t, r, f, etc.</li>
<li>If h is odd, the remaining third peg during successive moves is r, t, f, r, t, f, etc.</li>
</ul>
<p>With this knowledge, a set of disks in the middle of an optimal solution can be recovered with no more state information than the positions of each disk:</p>
<ul>
<li>Call the moves detailed above a disk's 'natural' move.</li>
<li>Examine the smallest top disk that is not disk 0, and note what it's only (legal) move would be: (if there is no such disc, then we are either at the first or last move).</li>
<li>If that move is the disk's 'natural' move, then the disc has not been moved since the last disc 0 move, and that move should be taken.</li>
<li>If that move is not the disk's 'natural' move, then move disk 0.</li>
</ul>
<p><a name="Binary_solutions" id="Binary_solutions"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=7" title="Edit section: Binary solutions">edit</a>]</span> <span class="mw-headline">Binary solutions</span></h3>
<p>Disk positions may be determined more directly from the <a href="/wiki/Binary_numeral_system" title="Binary numeral system">binary</a> (base 2) representation of the move number (the initial state being move #0, with all digits 0, and the final state being #2<sup><i>n</i></sup>−1, with all digits 1), using the following rules:</p>
<ul>
<li>There is one binary digit (<a href="/wiki/Bit" title="Bit">bit</a>) for each disk</li>
<li>The most significant (leftmost) bit represents the largest disk. A value of 0 indicates that the largest disk is on the initial peg, while a 1 indicates that it's on the final peg.</li>
<li>The bitstring is read from left to right, and each bit can be used to determine the location of the corresponding disk.</li>
<li>A bit with the same value as the previous one means that the corresponding disk is stacked on top the previous disk on the same peg.
<ul>
<li>(That is to say: a straight sequence of 1's or 0's means that the corresponding disks are all on the same peg).</li>
</ul>
</li>
<li>A bit with a different value to the previous one means that the corresponding disk is one position to the left or right of the previous one. Whether it is left or right is determined by this rule:
<ul>
<li>Assume that the initial peg is on the left and the final peg is on the right.</li>
<li>Also assume "wrapping" - so the right peg counts as one peg "left" of the left peg, and vice versa.</li>
<li>Let n be the number of greater disks that are located on the same peg as their first greater disk and add 1 if the largest disk is on the left peg. If n is even, the disk is located one peg to the left, if n is odd, the disk located one peg to the right.</li>
</ul>
</li>
</ul>
<p>For example, in an 8-disk Hanoi:</p>
<ul>
<li>Move #0)
<ul>
<li>The largest disk is 0, so it is on the left (initial) peg.</li>
<li>All other disks are 0 as well, so they are stacked on top of it. Hence all disks are on the initial peg.</li>
</ul>
</li>
<li>Move #2^8-1)
<ul>
<li>The largest disk is 1, so it is on the right (final) peg.</li>
<li>All other disks are 1 as well, so they are stacked on top of it. Hence all disks are on the final peg and the puzzle is complete.</li>
</ul>
</li>
<li>Move #0b11011000)
<ul>
<li>The largest disk is 1, so it is on the right (final) peg.</li>
<li>Disk two is also 1, so it is stacked on top of it, on the right peg.</li>
<li>Disk three is 0, so it is on another peg. Since n is odd, it is one peg to the right, i.e. on the left peg.</li>
<li>Disk four is 1, so it is on another peg. Since n is still even, it is one peg to the left, i.e. on the right peg.</li>
<li>Disk five is also 1, so it is stacked on top of it, on the right peg.</li>
<li>Disk six is 0, so it is on another peg. Since n is even, the disk is one peg to the left, i.e. on the middle peg.</li>
<li>Disks seven and eight are also 0, so they are stacked on top of it, on the middle peg.</li>
</ul>
</li>
</ul>
<p>The above algorithm can be coded in Scheme as follows:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-scheme">
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>conf m h <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="co1">; m=move number, h=height of tower, f=starting peg, t=destination peg</span>
  <span class="co1">; Identify the pegs by the numbers 0, 1 and 2.</span>
  <span class="br0">(</span><span class="kw1">let</span> loop <span class="br0">(</span><span class="br0">(</span>prev-<span class="kw1">zero?</span> #t<span class="br0">)</span> <span class="br0">(</span>mask <span class="br0">(</span>arithmetic-shift <span class="nu0">1</span> <span class="br0">(</span>sub1 h<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span>rotation <span class="br0">(</span>- <span class="kw1">t</span> <span class="kw1">f</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span><span class="kw1">f</span> <span class="kw1">f</span><span class="br0">)</span><span class="br0">)</span>
   <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">zero?</span> mask<span class="br0">)</span> <span class="br0">(</span><span class="br0">)</span>
    <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>zero-bit? <span class="br0">(</span><span class="kw1">zero?</span> <span class="br0">(</span>bitwise-<span class="kw1">and</span> mask m<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span>mask <span class="br0">(</span>arithmetic-shift mask <span class="nu0">-1</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
     <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">eq?</span> prev-<span class="kw1">zero?</span> zero-bit?<span class="br0">)</span> <span class="br0">(</span><span class="kw1">cons</span> <span class="kw1">f</span> <span class="br0">(</span>loop zero-bit? mask <span class="br0">(</span>- rotation<span class="br0">)</span> <span class="kw1">f</span><span class="br0">)</span><span class="br0">)</span>
      <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span><span class="kw1">f</span> <span class="br0">(</span><span class="kw1">modulo</span> <span class="br0">(</span>+ <span class="kw1">f</span> rotation<span class="br0">)</span> <span class="nu0">3</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
       <span class="br0">(</span><span class="kw1">cons</span> <span class="kw1">f</span> <span class="br0">(</span>loop zero-bit? mask rotation <span class="kw1">f</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre></div>
<p>This procedure produces a list of the positions of the disks in order of decreasing size. Example:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-scheme">
&gt; <span class="br0">(</span>conf #e6022e20 <span class="nu0">80</span> <span class="nu0">0</span> <span class="nu0">2</span><span class="br0">)</span>
<span class="br0">(</span><span class="nu0">01111111100001201201221111201112012000</span><span class="br0">)</span>
</pre></div>
<p>The source and destination pegs for the <i>m</i>th move can also be found elegantly from the binary representation of <i>m</i> using <a href="/wiki/Bitwise_operation" title="Bitwise operation">bitwise operations</a>. To use the syntax of the <a href="/wiki/C_(programming_language)" title="C (programming language)">C programming language</a>, the <i>m</i>th move is from peg <code>(m&amp;m-1)%3</code> to peg <code>((m|m-1)+1)%3</code>, where the disks begin on peg 0 and finish on peg 1 or 2 according as whether the number of disks is even or odd. Furthermore the disk to be moved is determined by the number of times the move count (m) can be divided by 2 (i.e. the number of zero bits at the right), counting the first move as 1 and identifying the disks by the numbers 0, 1, 2 etc in order of increasing size. This permits a very fast non-recursive computer implementation to find the positions of the disks after m moves without reference to any previous move or distribution of disks:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-scheme">
 <span class="co1">; h : total number of disks</span>
 <span class="co1">; m : move counter, starting with 1 for the first move.</span>
 <span class="co1">; f : starting peg; the pegs are identified by the numbers 0, 1 and 2.</span>
 <span class="co1">; t : destination peg</span>
 <span class="co1">; d : disk (numbered 0, 1, 2, etc in order of increasing size)</span>
 <span class="co1">; Function =quotient= takes two integer numbers and computes their quotient rounded to integer towards zero.</span>
 <span class="co1">; (rot3 m) : sense of rotation of the remaining third peg during move m.</span>
 <span class="co1">; (rotd d) : sense of rotation of disk d.</span>
 <span class="co1">; mcnt : number of moves disk d has made after a total of m moves.</span>
 <span class="co1">; from : the peg a disk is taken from during move m.</span>
 <span class="co1">; onto : the peg a disk is put onto during move m.</span>
 <span class="co1">; thrd : the remaining third peg. (- 3 from onto)</span>
 <span class="co1">; disk : disk being moved.</span>
 <span class="co1">; conf : position of disk d after a total of m moves.</span>
 
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>exp2 n        <span class="br0">)</span> <span class="br0">(</span><span class="kw1">expt</span>   <span class="nu0">2</span> n<span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>mod2 n        <span class="br0">)</span> <span class="br0">(</span><span class="kw1">modulo</span> n <span class="nu0">2</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>mod3 n        <span class="br0">)</span> <span class="br0">(</span><span class="kw1">modulo</span> n <span class="nu0">3</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>pari n        <span class="br0">)</span> <span class="br0">(</span>add1 <span class="br0">(</span>mod2 <span class="br0">(</span>add1 n<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>rotd   h <span class="kw1">d</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>mod3 <span class="br0">(</span>* <span class="br0">(</span>- <span class="kw1">t</span> <span class="kw1">f</span><span class="br0">)</span> <span class="br0">(</span>pari <span class="br0">(</span>- h <span class="kw1">d</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>rot3   h   <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>rotd h <span class="nu0">0</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>mcnt m   <span class="kw1">d</span>    <span class="br0">)</span> <span class="br0">(</span><span class="kw1">quotient</span> <span class="br0">(</span>+ m <span class="br0">(</span>exp2 <span class="kw1">d</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span>exp2 <span class="br0">(</span>add1 <span class="kw1">d</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>thrd m h   <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>mod3 <span class="br0">(</span>- <span class="kw1">f</span> <span class="br0">(</span>* m <span class="br0">(</span>rot3 h <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>onto m h   <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>mod3 <span class="br0">(</span>- <span class="br0">(</span>thrd m h <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>rotd h <span class="br0">(</span>disk m<span class="br0">)</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>from m h   <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>mod3 <span class="br0">(</span>+ <span class="br0">(</span>thrd m h <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>rotd h <span class="br0">(</span>disk m<span class="br0">)</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>conf m h <span class="kw1">d</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>mod3 <span class="br0">(</span>+ <span class="kw1">f</span> <span class="br0">(</span>* <span class="br0">(</span>rotd h <span class="kw1">d</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>mcnt m <span class="kw1">d</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>disk m        <span class="br0">)</span> <span class="br0">(</span>sub1 <span class="br0">(</span>bit-count <span class="br0">(</span>bitwise-xor m <span class="br0">(</span>sub1 m<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre></div>
<p><a name="Gray_code_solution" id="Gray_code_solution"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=8" title="Edit section: Gray code solution">edit</a>]</span> <span class="mw-headline">Gray code solution</span></h3>
<p>The <a href="/wiki/Binary_numeral_system" title="Binary numeral system">binary numeral system</a> of <a href="/wiki/Gray_code" title="Gray code">Gray codes</a> gives an alternative way of solving the puzzle. In the Gray system, numbers are expressed in a binary combination of 0s and 1s, but rather than being a standard <a href="/wiki/Numeral_system" title="Numeral system">positional numeral system</a>, Gray code operates on the premise that each value differs from its predecessor by only one (and exactly one) bit changed. The number of bits present in Gray code is important, and leading zeros are not optional, unlike in positional systems.</p>
<p>If one counts in Gray code of a bit size equal to the number of disks in a particular Tower of Hanoi, begins at zero, and counts up, then the bit changed each move corresponds to the disk to move, where the least-significant-bit is the smallest disk and the most-significant-bit is the largest.</p>
<dl>
<dd>Counting moves from 1 and identifying the disks by numbers starting from 0 in order of increasing size, the ordinal of the disk to be moved during move m is the number of times m can be divided by 2.</dd>
</dl>
<p>This technique identifies which disk to move, but not where to move it to. For the smallest disk there are always two possibilities. For the other disks there is always one possibility, except when all disks are on the same peg, but in that case either it is the smallest disk that must be moved or the objective has already been achieved. Luckily, there is a rule which does say where to move the smallest disk to. Let f be the starting peg, t the destination peg and r the remaining third peg. If the number of disks is odd, the smallest disk cycles along the pegs in the order f-&gt;t-&gt;r-&gt;f-&gt;t-&gt;r, etc. If the number of disks is even, this must be reversed: f-&gt;r-&gt;t-&gt;f-&gt;r-&gt;t etc. <a href="http://occawlonline.pearsoned.com/bookbind/pubbooks/miller2_awl/chapter4/essay1/deluxe-content.html#tower" class="external autonumber" title="http://occawlonline.pearsoned.com/bookbind/pubbooks/miller2_awl/chapter4/essay1/deluxe-content.html#tower" rel="nofollow">[1]</a></p>
<p><a name="Long_solutions" id="Long_solutions"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=9" title="Edit section: Long solutions">edit</a>]</span> <span class="mw-headline">Long solutions</span></h2>
<p>A modification of the game can be to move the tower from one peg to another peg using as many moves as possible without ever producing the same distribution of disks more than once. A simple algorithm (written in Scheme) is:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-scheme">
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>long-move-tower h <span class="kw1">f</span> <span class="kw1">t</span> r<span class="br0">)</span>
  <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">positive?</span> h<span class="br0">)</span>
   <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>h <span class="br0">(</span>sub1 h<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
    <span class="br0">(</span>long-move-tower h <span class="kw1">f</span> <span class="kw1">t</span> r<span class="br0">)</span>
    <span class="br0">(</span>move-disk       h <span class="kw1">f</span> r <span class="kw1">t</span><span class="br0">)</span>
    <span class="br0">(</span>long-move-tower h <span class="kw1">t</span> <span class="kw1">f</span> r<span class="br0">)</span>
    <span class="br0">(</span>move-disk       h r <span class="kw1">t</span> <span class="kw1">f</span><span class="br0">)</span>
    <span class="br0">(</span>long-move-tower h <span class="kw1">f</span> <span class="kw1">t</span> r<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre></div>
<p>Where procedure (move-disk d f t r) moves disk d from peg f onto peg t, ignoring peg r. The number of moves of this uniquely defined solution is 3<sup>height</sup>-1 and all 3<sup>height</sup> different distributions of disks are traversed (when including the starting and final distribution). This is called a <a href="/wiki/Hamilton_path" title="Hamilton path" class="mw-redirect">Hamilton path</a>. For this solution the disk to be moved can be found with a ternary gray code in a similar way as explained for the shortest solution. In fact there is a ternary Gray code starting with all digits 0 and ending with all digits equal 2, that lists the successive distributions of disks of a Hamilton path from peg 0 to peg 2 for a tower of h disks, each code showing the positions of the disks in decreasing order of size when read from left to right. This Gray code is uniquely defined by imposing the extra condition that each digit is switched more often than each more significant digit on the left. This is the code needed for the Tower of Hanoi.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-scheme">
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>number-&gt;p-ary-gray-code n h p<span class="br0">)</span> <span class="co1">; n h p --&gt; n-th h digit p-ary gray-code</span>
  <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>2p <span class="br0">(</span>* <span class="nu0">2</span> p<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
   <span class="br0">(</span><span class="kw1">let</span> loop <span class="br0">(</span><span class="br0">(</span>n n<span class="br0">)</span> <span class="br0">(</span>h h<span class="br0">)</span> <span class="br0">(</span>gc <span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
    <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">zero?</span> h<span class="br0">)</span> gc
     <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>q <span class="br0">(</span><span class="kw1">quotient</span> n p<span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span>r <span class="br0">(</span><span class="kw1">modulo</span> n 2p<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
      <span class="br0">(</span>loop q <span class="br0">(</span>sub1 h<span class="br0">)</span> <span class="br0">(</span><span class="kw1">cons</span> <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span>&gt;= r p<span class="br0">)</span> <span class="br0">(</span>- 2p r <span class="nu0">1</span><span class="br0">)</span> r<span class="br0">)</span> gc<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>p-ary-gray-code-&gt;number gc p<span class="br0">)</span> <span class="co1">; n-th p-ary gray-code --&gt; n</span>
  <span class="br0">(</span><span class="kw1">let</span> loop <span class="br0">(</span><span class="br0">(</span>gc gc<span class="br0">)</span> <span class="br0">(</span>significance <span class="br0">(</span><span class="kw1">expt</span> p <span class="br0">(</span>sub1 <span class="br0">(</span><span class="kw1">length</span> gc<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
   <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">null?</span> gc<span class="br0">)</span> <span class="nu0">0</span>
    <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>digit <span class="br0">(</span><span class="kw1">car</span> gc<span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span>gc <span class="br0">(</span><span class="kw1">cdr</span> gc<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
     <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>n <span class="br0">(</span>loop gc <span class="br0">(</span><span class="kw1">quotient</span> significance p<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
      <span class="br0">(</span>+ <span class="br0">(</span>* digit significance<span class="br0">)</span>
       <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">odd?</span> digit<span class="br0">)</span> <span class="br0">(</span>- significance n <span class="nu0">1</span><span class="br0">)</span> n<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>number-&gt;hanoian-gray-code n h<span class="br0">)</span> <span class="br0">(</span>number-&gt;p-ary-gray-code n h <span class="nu0">3</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>hanoian-gray-code-&gt;number gc<span class="br0">)</span> <span class="br0">(</span>p-ary-gray-code-&gt;number gc <span class="nu0">3</span><span class="br0">)</span><span class="br0">)</span>
</pre></div>
<p>The disk to be moved is determined by the number of times the move counter can be divided by 3. Where the disk is to be moved to can easily be determined too. For every triplet of moves, move the smallest disk twice in succession in the same direction, followed by a move of one of the larger disks (only one direction possible) Between every triplet of moves reverse the direction of the smallest disk. The very first move of the smallest disk is to be made from the starting peg onto the remaining third peg. Also observe that the unused peg of each move alternates between the starting and destination peg. These statements are easily proven by mathematical induction.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-scheme">
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>exp3 n        <span class="br0">)</span> <span class="br0">(</span><span class="kw1">expt</span>   <span class="nu0">3</span> n<span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>mod3 n        <span class="br0">)</span> <span class="br0">(</span><span class="kw1">modulo</span> n <span class="nu0">3</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>mod4 n        <span class="br0">)</span> <span class="br0">(</span><span class="kw1">modulo</span> n <span class="nu0">4</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>mcnt m   <span class="kw1">d</span>    <span class="br0">)</span> <span class="br0">(</span>+ <span class="br0">(</span>* <span class="nu0">2</span> <span class="br0">(</span><span class="kw1">quotient</span> m <span class="br0">(</span>exp3 <span class="br0">(</span>add1 <span class="kw1">d</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span>mod3 <span class="br0">(</span><span class="kw1">quotient</span> m <span class="br0">(</span>exp3 <span class="kw1">d</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>thrd m h   <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">odd?</span> m<span class="br0">)</span> <span class="kw1">t</span> <span class="kw1">f</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>onto m h   <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>posi m h <span class="br0">(</span>disk m<span class="br0">)</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>from m h   <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>- <span class="nu0">3</span> <span class="br0">(</span>onto m h <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span>thrd m h <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>posi m h <span class="kw1">d</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="br0">(</span><span class="kw1">vector-ref</span> <span class="br0">(</span><span class="kw1">vector</span> <span class="kw1">f</span> <span class="br0">(</span>- <span class="nu0">3</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span> <span class="kw1">t</span> <span class="br0">(</span>- <span class="nu0">3</span> <span class="kw1">f</span> <span class="kw1">t</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span>mod4 <span class="br0">(</span>mcnt m <span class="kw1">d</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>disk m<span class="br0">)</span> <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">zero?</span> <span class="br0">(</span>mod3 m<span class="br0">)</span><span class="br0">)</span> <span class="br0">(</span>add1 <span class="br0">(</span>disk <span class="br0">(</span><span class="kw1">quotient</span> m <span class="nu0">3</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span> <span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span>
</pre></div>
<p>Another modification is to move a tower from a peg back to the same peg while traversing all distributions of disks. (circular Hamilton path) There are exactly two solutions, but they mirror each other in the sense that there is in fact one path that can be traversed in both directions. Obviously, the length of the path is 3<sup>height</sup>. A simple algorithm for the circular Hamilton path is:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-scheme">
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>circular-hamilton-move-tower h a b c<span class="br0">)</span> <span class="co1">; h=height. a, b and c are the three pegs.</span>
  <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">positive?</span> h<span class="br0">)</span> <span class="co1">; start with a tower at peg a, move tower to peg b, then to peg c and finally return to peg a.</span>
   <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>h<span class="nu0">-1</span> <span class="br0">(</span>sub1 h<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
    <span class="br0">(</span>hamilton-start  h<span class="nu0">-1</span> a c b<span class="br0">)</span>   <span class="co1">; The largest disk is moved three times.</span>
    <span class="br0">(</span>move-disk       h<span class="nu0">-1</span> a b c<span class="br0">)</span>   <span class="co1">; Between these moves the longest non selfcrossing path is used in order to move the</span>
    <span class="br0">(</span>long-move-tower h<span class="nu0">-1</span> c a b<span class="br0">)</span>   <span class="co1">; partial tower consisting of the h-1 smaller disks from one peg onto another one.</span>
    <span class="br0">(</span>move-disk       h<span class="nu0">-1</span> b c a<span class="br0">)</span>   <span class="co1">; Together the procedures hamilton-start and hamilton-finish make such a longest</span>
    <span class="br0">(</span>long-move-tower h<span class="nu0">-1</span> a b c<span class="br0">)</span>   <span class="co1">; non selfcrossing path too. The moves made by hamiton-finish followed by</span>
    <span class="br0">(</span>move-disk       h<span class="nu0">-1</span> c a b<span class="br0">)</span>   <span class="co1">; those of hamilton-start form a longest non selfcrossing path for the same</span>
    <span class="br0">(</span>hamilton-finish h<span class="nu0">-1</span> b a c<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="co1">; partial tower from peg b to peg c.</span>
 
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>hamilton-start h a b c<span class="br0">)</span>
  <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">positive?</span> h<span class="br0">)</span>
   <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>h<span class="nu0">-1</span> <span class="br0">(</span>sub1 h<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
    <span class="br0">(</span>hamilton-start  h<span class="nu0">-1</span> a c b<span class="br0">)</span>
    <span class="br0">(</span>move-disk       h<span class="nu0">-1</span> a b c<span class="br0">)</span>
    <span class="br0">(</span>long-move-tower h<span class="nu0">-1</span> c b a<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
 
 <span class="br0">(</span><span class="kw1">define</span> <span class="br0">(</span>hamilton-finish h a b c<span class="br0">)</span>
  <span class="br0">(</span><span class="kw1">if</span> <span class="br0">(</span><span class="kw1">positive?</span> h<span class="br0">)</span>
   <span class="br0">(</span><span class="kw1">let</span> <span class="br0">(</span><span class="br0">(</span>h<span class="nu0">-1</span> <span class="br0">(</span>sub1 h<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
    <span class="br0">(</span>long-move-tower h<span class="nu0">-1</span> a c b<span class="br0">)</span>
    <span class="br0">(</span>move-disk       h<span class="nu0">-1</span> a b c<span class="br0">)</span>
    <span class="br0">(</span>hamilton-finish h<span class="nu0">-1</span> c b a<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
</pre></div>
<p><a name="Graphical_representation" id="Graphical_representation"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=10" title="Edit section: Graphical representation">edit</a>]</span> <span class="mw-headline">Graphical representation</span></h2>
<p>The game can be represented by an undirected <a href="/wiki/Graph_(mathematics)" title="Graph (mathematics)">graph</a>, the nodes representing distributions of disks and the branches representing moves. For one disk, the graph is a triangle:</p>
<div class="center">
<div class="floatnone"><a href="/wiki/File:Tower_of_Hanoi-1.svg" class="image" title="Tower of Hanoi-1.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/Tower_of_Hanoi-1.svg/91px-Tower_of_Hanoi-1.svg.png" width="91" height="82" border="0" /></a></div>
</div>
<p>The graph for 2 disks is 3 triangles arranged in a larger triangle:</p>
<div class="center">
<div class="floatnone"><a href="/wiki/File:Tower_of_Hanoi-2.svg" class="image" title="Tower of Hanoi-2.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Tower_of_Hanoi-2.svg/255px-Tower_of_Hanoi-2.svg.png" width="255" height="192" border="0" /></a></div>
</div>
<p>The nodes at the vertices of the outermost triangle represent distributions with all disks on the same peg.</p>
<p>For h+1 disks, take the graph of h disks and replace each small triangle with the graph for 2 disks.</p>
<p>For 3 disks the graph is:</p>
<div class="center">
<div class="floatnone"><a href="/wiki/File:Tower_of_Hanoi-3.svg" class="image" title="Tower of Hanoi-3.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/Tower_of_Hanoi-3.svg/440px-Tower_of_Hanoi-3.svg.png" width="440" height="373" border="0" /></a></div>
</div>
<ul>
<li>call the pegs a, b and c</li>
<li>list disk positions from left to right in order of increasing size</li>
</ul>
<p>The sides of the outermost triangle represent the shortest ways of moving a tower from one peg to another one. The branch in the middle of the sides of the largest triangle represents a move of the largest disk. The branch in the middle of the sides of each next smaller triangle represents a move of each next smaller disk. The sides of the smallest triangles represent moves of the smallest disk.</p>
<div class="thumb tright">
<div class="thumbinner" style="width:182px;"><a href="/wiki/File:Hanoi-Graph-7.svg" class="image" title="The game graph of level 7 shows the relatedness to the Sierpiński Triangle"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/8/80/Hanoi-Graph-7.svg/180px-Hanoi-Graph-7.svg.png" width="180" height="156" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Hanoi-Graph-7.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
The game graph of level 7 shows the relatedness to the <a href="/wiki/Sierpi%C5%84ski_Triangle" title="Sierpiński Triangle" class="mw-redirect">Sierpiński Triangle</a></div>
</div>
</div>
<p>In general, for a puzzle with <i>n</i> disks, there are 3<sup><i>n</i></sup> nodes in the graph; every node has three branches to other nodes, except the three corner nodes, which have two: it is always possible to move the smallest disk to the one of the two other pegs; and it is possible to move one disk between those two pegs <i>except</i> in the situation where all disks are stacked on one peg. The corner nodes represent the three cases where all the disks are stacked on one peg. The diagram for <i>n</i>+1 disks is obtained by taking three copies of the <i>n</i>-disk diagram -- each one representing all the states and moves of the smaller disks for one particular position of the new largest disk -- and joining them at the corners with three new branches, representing the only three opportunities to move the largest disk. The resulting figure thus has 3<sup><i>n</i>+1</sup> nodes and still has three corners remaining with only two branches.</p>
<p>As more disks are added, the graph representation of the game will resemble the <a href="/wiki/Fractal" title="Fractal">Fractal</a> figure, <a href="/wiki/Sierpi%C5%84ski_triangle" title="Sierpiński triangle" class="mw-redirect">Sierpiński triangle</a>. It is clear that the great majority of positions in the puzzle will never be reached when using the shortest possible solution; indeed, if the priests of the legend are using the longest possible solution (without re-visiting any position) it will take them 3<sup>64</sup>-1 moves, or more than 10<sup>23</sup> years.</p>
<p>The longest non-repetitive way for three disks can be visualized by erasing the unused branches:</p>
<div class="center">
<div class="floatnone"><a href="/wiki/File:Tower_of_Hanoi-3_Longest_Path.svg" class="image" title="Tower of Hanoi-3 Longest Path.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Tower_of_Hanoi-3_Longest_Path.svg/440px-Tower_of_Hanoi-3_Longest_Path.svg.png" width="440" height="373" border="0" /></a></div>
</div>
<p>The circular <a href="/wiki/Hamiltonian_path" title="Hamiltonian path">Hamiltonian path</a> for three disks is:</p>
<div class="center">
<div class="floatnone"><a href="/wiki/File:Tower_of_Hanoi-4_Longest_Cycle.svg" class="image" title="Tower of Hanoi-4 Longest Cycle.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/e/e8/Tower_of_Hanoi-4_Longest_Cycle.svg/440px-Tower_of_Hanoi-4_Longest_Cycle.svg.png" width="440" height="373" border="0" /></a></div>
</div>
<p>The graphs clearly show that:</p>
<ul>
<li>From every arbitrary distribution of disks, there is exactly one shortest way to move all disks onto one of the three pegs.</li>
<li>Between every pair of arbitrary distributions of disks there are one or two different shortest paths.</li>
<li>From every arbitrary distribution of disks, there are one or two different longest non selfcrossing paths to move all disks to one of the three pegs.</li>
<li>Between every pair of arbitrary distributions of disks there are one or two different longest non selfcrossing paths.</li>
<li>Let N<sub>h</sub> be the number of non selfcrossing paths for moving a tower of h disks from one peg to another one. Then:
<ul>
<li>N<sub>1</sub>=2</li>
<li>N<sub>h+1</sub>=(N<sub>h</sub>)<sup>2</sup>+(N<sub>h</sub>)<sup>3</sup>.</li>
<li>For example: N<sub>8</sub>≈1.5456x10<sup>795</sup></li>
</ul>
</li>
</ul>
<p><a name="Applications" id="Applications"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=11" title="Edit section: Applications">edit</a>]</span> <span class="mw-headline">Applications</span></h2>
<p>The Tower of Hanoi is frequently used in psychological research on <a href="/wiki/Problem_solving" title="Problem solving">problem solving</a>. There also exists a variant of this task called <a href="/wiki/Tower_of_London_Test" title="Tower of London Test">Tower of London</a> for neuropsychological diagnosis and treatment of executive functions.</p>
<p>The Tower of Hanoi is also used as <a href="/wiki/Backup_rotation_scheme" title="Backup rotation scheme">Backup rotation scheme</a> when performing computer data <a href="/wiki/Backups" title="Backups" class="mw-redirect">Backups</a> where multiple tapes/media are involved.</p>
<p>As mentioned above, the Tower of Hanoi is popular for teaching recursive algorithms to beginning programming students. A pictorial version of this puzzle is programmed into the <a href="/wiki/Emacs" title="Emacs">emacs</a> editor, accessed by typing M-x hanoi. There is also a sample algorithm written in <a href="/wiki/Prolog" title="Prolog">Prolog</a>.</p>
<p>The Tower of Hanoi is also used as a <a href="/wiki/Memory" title="Memory">memory</a> test by neuropsychologists trying to evaluate amnesia.</p>
<p><a name="Four_pegs_and_beyond" id="Four_pegs_and_beyond"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=12" title="Edit section: Four pegs and beyond">edit</a>]</span> <span class="mw-headline">Four pegs and beyond</span></h2>
<p>Although the three-peg version has a simple recursive solution as outlined above, the <i>optimal</i> solution for the Tower of Hanoi problem with four pegs (called <b>Reve's puzzle</b>), let alone more pegs, is still an <a href="/wiki/Open_problem" title="Open problem">open problem</a>. This is a good example of how a simple, solvable problem can be made dramatically more difficult by slightly loosening one of the problem constraints.</p>
<p>The fact that the problem with four or more pegs is an open problem does not imply that no algorithm exists for finding (all of) the optimal solutions. Simply represent the game by an undirected graph, the nodes being distributions of disks and the edges being moves (of length 1) and use <a href="/wiki/Dijkstra%27s_algorithm" title="Dijkstra's algorithm">Dijkstra's algorithm</a> to find one (or all) shortest paths moving a tower from one peg onto another one. However, even smartly implemented on the fastest computer now available, this algorithm provides no way of effectively computing solutions for large numbers of disks; the program would require more time and memory than available. Hence, even having an algorithm, it remains unknown how many moves an optimal solution requires and how many optimal solutions exist for 1000 disks and 10 pegs.</p>
<p>Though it is not known exactly how many moves must be made, there are some asymptotic results. There is also a "presumed-optimal solution" given by the <b>Frame-Stewart algorithm</b>. The related open <a href="/w/index.php?title=Frame-Stewart_conjecture&amp;action=edit&amp;redlink=1" class="new" title="Frame-Stewart conjecture (page does not exist)">Frame-Stewart conjecture</a> claims that the Frame-Stewart algorithm always gives an optimal solution. The optimality of the Frame-Stewart algorithm has been computationally verified for up to 30 disks. <sup id="cite_ref-2" class="reference"><a href="#cite_note-2" title=""><span>[</span>3<span>]</span></a></sup></p>
<p>For other variants of the four-peg Tower of Hanoi problem, see Paul Stockmeyer's survey paper. <sup id="cite_ref-3" class="reference"><a href="#cite_note-3" title=""><span>[</span>4<span>]</span></a></sup></p>
<p><a name="Frame-Stewart_algorithm" id="Frame-Stewart_algorithm"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=13" title="Edit section: Frame-Stewart algorithm">edit</a>]</span> <span class="mw-headline">Frame-Stewart algorithm</span></h3>
<p>The Frame-Stewart algorithm, giving a <i>presumably-optimal solution</i> for four (or even more) pegs, is described below:</p>
<ul>
<li>Let <span class="texhtml"><i>n</i></span> be the number of disks.</li>
<li>Let <span class="texhtml"><i>r</i></span> be the number of pegs.</li>
<li>Define <span class="texhtml"><i>T</i>(<i>n</i>,<i>r</i>)</span> to be the number of moves required to transfer n disks using r pegs</li>
</ul>
<p>The algorithm can be described recursively:</p>
<ol>
<li>For some <span class="texhtml"><i>k</i></span>, <img class="tex" alt="1 \leq k &lt; n" src="http://upload.wikimedia.org/math/1/2/6/126ad00cd3add463506cb6b8f7848a82.png" />, transfer the top <span class="texhtml"><i>k</i></span> disks to a single other peg, taking <span class="texhtml"><i>T</i>(<i>k</i>,<i>r</i>)</span> moves.</li>
<li>Without disturbing the peg that now contains the top <span class="texhtml"><i>k</i></span> disks, transfer the remaining <span class="texhtml"><i>n</i> − <i>k</i></span> disks to the destination peg, using only the remaining <span class="texhtml"><i>r</i> − 1</span> pegs, taking <span class="texhtml"><i>T</i>(<i>n</i> − <i>k</i>,<i>r</i> − 1)</span> moves.</li>
<li>Finally, transfer the top <span class="texhtml"><i>k</i></span> disks to the destination peg, taking <span class="texhtml"><i>T</i>(<i>k</i>,<i>r</i>)</span> moves.</li>
</ol>
<p>The entire process takes <span class="texhtml">2<i>T</i>(<i>k</i>,<i>r</i>) + <i>T</i>(<i>n</i> − <i>k</i>,<i>r</i> − 1)</span> moves. Therefore, the count <span class="texhtml"><i>k</i></span> should be picked for which this quantity is minimum.<br />
This algorithm (with the above choice for <span class="texhtml"><i>k</i></span>) is presumed to be optimal, and no counterexamples are known.</p>
<p><a name="Two_stacks_and_more_stacks" id="Two_stacks_and_more_stacks"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=14" title="Edit section: Two stacks and more stacks">edit</a>]</span> <span class="mw-headline">Two stacks and more stacks</span></h3>
<p>A 2007 U.S. patent application discloses multistack Tower of Hanoi puzzles [Feb. 1, 2007, Serial No.11/701,454] with two or more stacks and twice as many pegs as stacks. After beginning on a particular peg, each stack displaces and is displaced by a different colored stack on another peg when the puzzle is solved. Disks of one color also have another peg that excludes all other colors, so that there are three pegs available for each color disk, two that are shared with other colors and one that is not shared. On the shared pegs, a disk may not be placed on a different colored disk of the same size, a possibility that does not arise in the standard puzzle.</p>
<p>The simplest multistack game (2 x 4) has two stacks and four pegs, and it requires 3[T(n)] moves to solve where T(n) is the number of moves needed to solve a single stack classic of n disks. The game proceeds in seesaw fashion with longer and longer series of moves that alternate between colors. It concludes in reverse seesaw fashion with shorter and shorter such series of moves. Starting with the second series of three moves, these alternate series of moves double in length for the first half of the game, and the lengths are halved as the game concludes. The solution involves nesting an algorithm suitable for Tower of Hanoi into an algorithm that indicates when to switch between colors. When there are k stacks of n disks apiece in a game, and k &gt; 2, it requires k[T(n)] + T(n-1) + 1 moves to relocate them.</p>
<p>The addition of a centrally located universal peg open to disks from all stacks converts these multistack Tower of Hanoi puzzles to multistack Reve's puzzles as described in the preceding section. In these games each stack may move among four pegs, the same combination of three in the 2 x 4 game plus the central universal peg. The simplest game of this kind (2 x 5) has two stacks and five pegs. A solution conjectured to be optimal interlocks the optimal solution of the 2 x 4 puzzle with the presumed optimal solution to Reve's puzzle. It takes R(n) + 2R(n-1) + 2 moves, where R(n) is the number of moves in the presumed optimal Reve's solution for a stack of n disks.</p>
<p><a name="In_popular_culture" id="In_popular_culture"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=15" title="Edit section: In popular culture">edit</a>]</span> <span class="mw-headline">In popular culture</span></h2>
<p>In the classic science fiction story <i>Now Inhale</i>, by <a href="/wiki/Eric_Frank_Russell" title="Eric Frank Russell">Eric Frank Russell</a> (<i>Astounding Science Fiction</i> April 1959, and in various anthologies), the human hero is a prisoner on a planet where the local custom is to make the prisoner play a game until it is won or lost, and then execution is immediate. The hero is told the game can be one of his own species', as long as it can be played in his cell with simple equipment strictly according to rules which are written down before and cannot change after play starts, and it has a finite endpoint. The game and execution are televised planet-wide, and watching the desperate prisoner try to spin the game out as long as possible is very popular entertainment; the record is sixteen days. The hero knows a rescue ship might take a year or more to arrive, so chooses to play Towers of Hanoi with 64 disks until rescue arrives. When the locals realize they've been had, they are angry, but under their own rules there is nothing they can do about it. They do change the rules, which will apply to any <i>future</i> prisoners. This story makes reference to the legend about the Buddhist monks playing the game until the end of the world, and refers to the game as <b>arkymalarky</b>. (The slang term "malarky", meaning nonsense, pre-dates this story by at least 30 years. <a href="http://www.phrases.org.uk/bulletin_board/7/messages/555.html" class="external autonumber" title="http://www.phrases.org.uk/bulletin_board/7/messages/555.html" rel="nofollow">[2]</a>)</p>
<p>In the movie <a href="/wiki/Stranger_than_Fiction_(film)" title="Stranger than Fiction (film)">Stranger than Fiction</a>, a miniature Towers of Hanoi puzzle can be seen on the cluttered desk of Professor Jules Hilbert.</p>
<p>In the <i><a href="/wiki/Doctor_Who" title="Doctor Who">Doctor Who</a></i> serial "<a href="/wiki/The_Celestial_Toymaker" title="The Celestial Toymaker">The Celestial Toymaker</a>", the Toymaker challenges the Doctor to complete the "Trilogic Game" (ten disk Hanoi) in exactly 1,023 (2<sup>10</sup> − 1) moves.</p>
<p><a name="In_video_games" id="In_video_games"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=16" title="Edit section: In video games">edit</a>]</span> <span class="mw-headline">In video games</span></h3>
<p>The puzzle is featured regularly in <a href="/wiki/Adventure_game" title="Adventure game">adventure</a> and <a href="/wiki/Computer_puzzle_game" title="Computer puzzle game" class="mw-redirect">puzzle</a> games. Since it is easy to implement, and easily-recognised, it is well-suited to use as a puzzle in a larger graphical game. Some implementations use straight disks, but others disguise the puzzle in some other form. What follows is a partial list of games which use the puzzle:</p>
<ul>
<li><a href="/wiki/Black_%26_White_(game)" title="Black &amp; White (game)" class="mw-redirect">Black &amp; White</a></li>
<li><a href="/wiki/The_Island_of_Dr._Brain" title="The Island of Dr. Brain">The Island of Dr. Brain</a></li>
<li><a href="/wiki/The_Secret_Island_of_Dr._Quandary" title="The Secret Island of Dr. Quandary">The Secret Island of Dr. Quandary</a></li>
<li><a href="/wiki/Star_Wars:_Knights_of_the_Old_Republic" title="Star Wars: Knights of the Old Republic">Star Wars: Knights of the Old Republic</a></li>
<li><a href="/wiki/Zork_Zero" title="Zork Zero">Zork Zero</a></li>
<li><a href="/wiki/The_Legend_of_Kyrandia" title="The Legend of Kyrandia">The Legend of Kyrandia: Hand of Fate</a></li>
<li><a href="/w/index.php?title=Escape_from_Paradise_(game)&amp;action=edit&amp;redlink=1" class="new" title="Escape from Paradise (game) (page does not exist)">Escape from Paradise</a></li>
<li><a href="/wiki/ECHO:_Secrets_of_the_Lost_Cavern" title="ECHO: Secrets of the Lost Cavern" class="mw-redirect">ECHO: Secrets of the Lost Cavern</a></li>
<li><a href="/wiki/Clan_Lord" title="Clan Lord">Clan Lord</a></li>
<li><a href="/wiki/Mass_Effect" title="Mass Effect">Mass Effect</a></li>
<li><a href="/wiki/Azada_(video_game)" title="Azada (video game)">Azada</a></li>
<li><a href="/wiki/Layton-ky%C5%8Dju_to_Akuma_no_Hako" title="Layton-kyōju to Akuma no Hako" class="mw-redirect">Professor Layton and Pandora's Box</a></li>
<li><a href="/wiki/Stay_Tuned_for_Danger" title="Stay Tuned for Danger">Nancy Drew: Stay Tuned for Danger</a></li>
<li><a href="/wiki/Jumpstart" title="Jumpstart" class="mw-redirect">Jumpstart Fifth Grade</a></li>
</ul>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=17" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/Baguenaudier" title="Baguenaudier">Baguenaudier</a></li>
<li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursion (computer science)</a></li>
<li><a href="/wiki/The_Nine_Billion_Names_of_God" title="The Nine Billion Names of God">The Nine Billion Names of God</a>, a short story possibly inspired by this puzzle</li>
</ul>
<p><a name="Notes" id="Notes"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit&amp;section=18" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline">Notes</span></h2>
<div class="references-small">
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> <i>1000 Play Thinks</i>.</li>
<li id="cite_note-1"><b><a href="#cite_ref-1" title="">^</a></b> <i>1000 Play Thinks</i>.</li>
<li id="cite_note-2"><b><a href="#cite_ref-2" title="">^</a></b> <cite style="font-style:normal" class="" id="CITEREFKorf.2C_Richard_E..2C_and_Ariel_Felner2007">Korf, Richard E., and Ariel Felner (2007). "<a href="http://www.ijcai.org/papers07/Papers/IJCAI07-374.pdf" class="external text" title="http://www.ijcai.org/papers07/Papers/IJCAI07-374.pdf" rel="nofollow">Recent Progress in Heuristic Search: a Case Study of the Four-Peg Towers of Hanoi Problem</a>". <i><a href="/wiki/IJCAI" title="IJCAI" class="mw-redirect">IJCAI</a></i>: 2324-2329<span class="printonly">. <a href="http://www.ijcai.org/papers07/Papers/IJCAI07-374.pdf" class="external free" title="http://www.ijcai.org/papers07/Papers/IJCAI07-374.pdf" rel="nofollow">http://www.ijcai.org/papers07/Papers/IJCAI07-374.pdf</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Recent+Progress+in+Heuristic+Search%3A+a+Case+Study+of+the+Four-Peg+Towers+of+Hanoi+Problem&amp;rft.jtitle=%5B%5BIJCAI%5D%5D&amp;rft.aulast=Korf%2C+Richard+E.%2C+and+Ariel+Felner&amp;rft.au=Korf%2C+Richard+E.%2C+and+Ariel+Felner&amp;rft.date=2007&amp;rft.pages=2324-2329&amp;rft_id=http%3A%2F%2Fwww.ijcai.org%2Fpapers07%2FPapers%2FIJCAI07-374.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Tower_of_Hanoi"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-3"><b><a href="#cite_ref-3" title="">^</a></b> <cite style="font-style:normal" class="" id="CITEREFPaul_Stockmeyer1994">Paul Stockmeyer (1994). "<a href="http://www.cs.wm.edu/~pkstoc/boca.ps" class="external text" title="http://www.cs.wm.edu/~pkstoc/boca.ps" rel="nofollow">Variations on the Four-Post Tower of Hanoi Puzzle</a>". <i>Congressus Numerantium</i> <b>102</b>: 3-12<span class="printonly">. <a href="http://www.cs.wm.edu/~pkstoc/boca.ps" class="external free" title="http://www.cs.wm.edu/~pkstoc/boca.ps" rel="nofollow">http://www.cs.wm.edu/~pkstoc/boca.ps</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=Variations+on+the+Four-Post+Tower+of+Hanoi+Puzzle&amp;rft.jtitle=Congressus+Numerantium&amp;rft.aulast=Paul+Stockmeyer&amp;rft.au=Paul+Stockmeyer&amp;rft.date=1994&amp;rft.volume=102&amp;rft.pages=3-12&amp;rft_id=http%3A%2F%2Fwww.cs.wm.edu%2F%7Epkstoc%2Fboca.ps&amp;rfr_id=info:sid/en.wikipedia.org:Tower_of_Hanoi"><span style="display: none;">&#160;</span></span></li>
</ol>
</div>
<p><br /></p>
<table class="metadata plainlinks mbox-small" style="border:1px solid #aaa; background-color:#f9f9f9;">
<tr>
<td class="mbox-image"><a href="http://commons.wikimedia.org/wiki/Special:Search/Tower_of_Hanoi" title="commons:Special:Search/Tower of Hanoi"><img alt="Sister project" src="http://upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/40px-Commons-logo.svg.png" width="40" height="54" border="0" /></a></td>
<td class="mbox-text" style=""><a href="/wiki/Wikimedia_Commons" title="Wikimedia Commons">Wikimedia Commons</a> has media related to: <b><i><a href="http://commons.wikimedia.org/wiki/Category:Tower_of_Hanoi" class="extiw" title="commons:Category:Tower of Hanoi">Tower of Hanoi</a> </i></b></td>
</tr>
</table>
<p><span id="interwiki-he-fa"></span></p>


<!-- 
NewPP limit report
Preprocessor node count: 1232/1000000
Post-expand include size: 9090/2048000 bytes
Template argument size: 3214/2048000 bytes
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:56990-0!1!0!default!!en!2 and timestamp 20090412023640 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Tower_of_Hanoi">http://en.wikipedia.org/wiki/Tower_of_Hanoi</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Mechanical_puzzles" title="Category:Mechanical puzzles">Mechanical puzzles</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_code" title="Category:Articles with example code">Articles with example code</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_Haskell_code" title="Category:Articles with example Haskell code">Articles with example Haskell code</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_Scheme_code" title="Category:Articles with example Scheme code">Articles with example Scheme code</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_Pascal_code" title="Category:Articles with example Pascal code">Articles with example Pascal code</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_C_code" title="Category:Articles with example C code">Articles with example C code</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Tower_of_Hanoi" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Tower_of_Hanoi" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Tower_of_Hanoi&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Tower_of_Hanoi&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Tower_of_Hanoi" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Tower_of_Hanoi" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Tower_of_Hanoi" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Tower_of_Hanoi&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Tower_of_Hanoi&amp;oldid=283293370" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Tower_of_Hanoi&amp;id=283293370">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-bg"><a href="http://bg.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BD%D0%BE%D0%B9%D1%81%D0%BA%D0%B0_%D0%BA%D1%83%D0%BB%D0%B0">Български</a></li>
				<li class="interwiki-ca"><a href="http://ca.wikipedia.org/wiki/Torres_de_Hanoi">Català</a></li>
				<li class="interwiki-cs"><a href="http://cs.wikipedia.org/wiki/Hanojsk%C3%A9_v%C4%9B%C5%BEe">Česky</a></li>
				<li class="interwiki-da"><a href="http://da.wikipedia.org/wiki/Hanois_t%C3%A5rn">Dansk</a></li>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/T%C3%BCrme_von_Hanoi">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Torres_de_Hanoi">Español</a></li>
				<li class="interwiki-eo"><a href="http://eo.wikipedia.org/wiki/Turoj_de_Hanojo">Esperanto</a></li>
				<li class="interwiki-eu"><a href="http://eu.wikipedia.org/wiki/Hanoiko_Dorreak">Euskara</a></li>
				<li class="interwiki-fa"><a href="http://fa.wikipedia.org/wiki/%D8%A8%D8%B1%D8%AC_%D9%87%D8%A7%D9%86%D9%88%DB%8C">فارسی</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">Français</a></li>
				<li class="interwiki-ko"><a href="http://ko.wikipedia.org/wiki/%ED%95%98%EB%85%B8%EC%9D%B4%EC%9D%98_%ED%83%91">한국어</a></li>
				<li class="interwiki-id"><a href="http://id.wikipedia.org/wiki/Menara_Hanoi">Bahasa Indonesia</a></li>
				<li class="interwiki-is"><a href="http://is.wikipedia.org/wiki/Turninn_%C3%AD_Hanoi">Íslenska</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Torre_di_Hanoi">Italiano</a></li>
				<li class="interwiki-he"><a href="http://he.wikipedia.org/wiki/%D7%9E%D7%92%D7%93%D7%9C%D7%99_%D7%94%D7%90%D7%A0%D7%95%D7%99">עברית</a></li>
				<li class="interwiki-lb"><a href="http://lb.wikipedia.org/wiki/Hanoi-Tuerm">Lëtzebuergesch</a></li>
				<li class="interwiki-hu"><a href="http://hu.wikipedia.org/wiki/Hanoi_torony">Magyar</a></li>
				<li class="interwiki-nl"><a href="http://nl.wikipedia.org/wiki/Torens_van_Hanoi">Nederlands</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%8E%E3%82%A4%E3%81%AE%E5%A1%94">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Wie%C5%BCe_Hanoi">Polski</a></li>
				<li class="interwiki-pt"><a href="http://pt.wikipedia.org/wiki/Torre_de_Hanoi">Português</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BD%D0%BE%D0%B9%D1%81%D0%BA%D0%B0%D1%8F_%D0%B1%D0%B0%D1%88%D0%BD%D1%8F">Русский</a></li>
				<li class="interwiki-sl"><a href="http://sl.wikipedia.org/wiki/Hanojski_stolpi">Slovenščina</a></li>
				<li class="interwiki-fi"><a href="http://fi.wikipedia.org/wiki/Hanoin_torni">Suomi</a></li>
				<li class="interwiki-sv"><a href="http://sv.wikipedia.org/wiki/Tornen_i_Hanoi">Svenska</a></li>
				<li class="interwiki-th"><a href="http://th.wikipedia.org/wiki/%E0%B8%AB%E0%B8%AD%E0%B8%84%E0%B8%AD%E0%B8%A2%E0%B9%81%E0%B8%AB%E0%B9%88%E0%B8%87%E0%B8%AE%E0%B8%B2%E0%B8%99%E0%B8%AD%E0%B8%A2">ไทย</a></li>
				<li class="interwiki-vi"><a href="http://vi.wikipedia.org/wiki/Th%C3%A1p_H%C3%A0_N%E1%BB%99i_(b%C3%A0i_to%C3%A1n)">Tiếng Việt</a></li>
				<li class="interwiki-tr"><a href="http://tr.wikipedia.org/wiki/Hanoi_kuleleri">Türkçe</a></li>
				<li class="interwiki-ur"><a href="http://ur.wikipedia.org/wiki/%D8%A8%D8%B1%D8%AC_%D9%87%D8%A7%D9%86%D9%88%DB%8C">اردو</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E6%B1%89%E8%AF%BA%E5%A1%94">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 12 April 2009, at 02:34 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv119 in 0.097 secs. --></body></html>
