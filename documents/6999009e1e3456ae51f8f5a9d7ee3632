<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Selection algorithm,NIST Dictionary of Algorithms and Data Structures,Algorithm,Amortized analysis,Big-O notation,Breadth-first search,C++,C.A.R. Hoare,CPAN,Charles E. Leiserson,Clifford Stein" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Selection_algorithm&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Selection_algorithm&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Selection algorithm - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Selection_algorithm";
		var wgTitle = "Selection algorithm";
		var wgAction = "view";
		var wgArticleId = "552786";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 265806713;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Selection_algorithm skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Selection algorithm</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<table class="metadata plainlinks ambox ambox-content" style="">
<tr>
<td class="mbox-image">
<div style="width: 52px;"><a href="/wiki/File:Ambox_content.png" class="image" title="Ambox content.png"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/f/f4/Ambox_content.png" width="40" height="40" border="0" /></a></div>
</td>
<td class="mbox-text" style="">This article <b>is missing <a href="/wiki/Wikipedia:Citing_sources" title="Wikipedia:Citing sources">citations</a> or needs <a href="/wiki/Wikipedia:Footnotes" title="Wikipedia:Footnotes">footnotes</a></b>. Please help add <a href="/wiki/Wikipedia:Inline_citations" title="Wikipedia:Inline citations" class="mw-redirect">inline citations</a> to guard against copyright violations and factual inaccuracies. <small><i>(December 2008)</i></small></td>
</tr>
</table>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, a <b>selection algorithm</b> is an <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> for finding the <i>k</i>th smallest number in a list (such a number is called the <i>k</i>th <i><a href="/wiki/Order_statistic" title="Order statistic">order statistic</a></i>.) This includes the cases of finding the minimum, maximum, and median elements. There are worst-case linear time selection algorithms. Selection is a subproblem of more complex problems like the <a href="/wiki/Nearest_neighbor_problem" title="Nearest neighbor problem" class="mw-redirect">nearest neighbor problem</a> and <a href="/wiki/Shortest_path" title="Shortest path" class="mw-redirect">shortest path</a> problems.</p>
<p>The term "selection" is used in other contexts in computer science, including the stage of a genetic algorithm in which genomes are chosen from a population for later breeding; see <a href="/wiki/Selection_(genetic_algorithm)" title="Selection (genetic algorithm)">Selection (genetic algorithm)</a>. This article addresses only the problem of determining order statistics.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Selection_by_sorting"><span class="tocnumber">1</span> <span class="toctext">Selection by sorting</span></a></li>
<li class="toclevel-1"><a href="#Linear_minimum.2Fmaximum_algorithms"><span class="tocnumber">2</span> <span class="toctext">Linear minimum/maximum algorithms</span></a></li>
<li class="toclevel-1"><a href="#Nonlinear_general_selection_algorithm"><span class="tocnumber">3</span> <span class="toctext">Nonlinear general selection algorithm</span></a></li>
<li class="toclevel-1"><a href="#Partition-based_general_selection_algorithm"><span class="tocnumber">4</span> <span class="toctext">Partition-based general selection algorithm</span></a></li>
<li class="toclevel-1"><a href="#Linear_general_selection_algorithm_-_.22Median_of_Medians_algorithm.22"><span class="tocnumber">5</span> <span class="toctext">Linear general selection algorithm - "Median of Medians algorithm"</span></a></li>
<li class="toclevel-1"><a href="#Introselect"><span class="tocnumber">6</span> <span class="toctext">Introselect</span></a></li>
<li class="toclevel-1"><a href="#Selection_as_incremental_sorting"><span class="tocnumber">7</span> <span class="toctext">Selection as incremental sorting</span></a></li>
<li class="toclevel-1"><a href="#Using_data_structures_to_select_in_sublinear_time"><span class="tocnumber">8</span> <span class="toctext">Using data structures to select in sublinear time</span></a></li>
<li class="toclevel-1"><a href="#Selecting_k_smallest_or_largest_elements"><span class="tocnumber">9</span> <span class="toctext">Selecting k smallest or largest elements</span></a>
<ul>
<li class="toclevel-2"><a href="#Repeated_application_of_simple_selection_algorithms"><span class="tocnumber">9.1</span> <span class="toctext">Repeated application of simple selection algorithms</span></a></li>
<li class="toclevel-2"><a href="#Direct_application_of_the_quick_sort_based_selection_algorithm"><span class="tocnumber">9.2</span> <span class="toctext">Direct application of the quick sort based selection algorithm</span></a></li>
<li class="toclevel-2"><a href="#Data_structure_based_solutions"><span class="tocnumber">9.3</span> <span class="toctext">Data structure based solutions</span></a></li>
<li class="toclevel-2"><a href="#Optimised_sorting_algorithms"><span class="tocnumber">9.4</span> <span class="toctext">Optimised sorting algorithms</span></a></li>
<li class="toclevel-2"><a href="#Tournament_Algorithm"><span class="tocnumber">9.5</span> <span class="toctext">Tournament Algorithm</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Lower_bounds"><span class="tocnumber">10</span> <span class="toctext">Lower bounds</span></a></li>
<li class="toclevel-1"><a href="#Language_support"><span class="tocnumber">11</span> <span class="toctext">Language support</span></a></li>
<li class="toclevel-1"><a href="#Online_selection_algorithm"><span class="tocnumber">12</span> <span class="toctext">Online selection algorithm</span></a></li>
<li class="toclevel-1"><a href="#Notes"><span class="tocnumber">13</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">14</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">15</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Selection_by_sorting" id="Selection_by_sorting"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=1" title="Edit section: Selection by sorting">edit</a>]</span> <span class="mw-headline">Selection by sorting</span></h2>
<p>Selection can be <a href="/wiki/Reduction_(complexity)" title="Reduction (complexity)">reduced</a> to <a href="/wiki/Sorting_algorithm" title="Sorting algorithm">sorting</a> by sorting the list and then extracting the desired element. This method is efficient when many selections need to be made from a list, in which case only one initial, expensive sort is needed, followed by many cheap extraction operations. In general, this method requires <img class="tex" alt="\mathcal{O}(n~\log~n)" src="http://upload.wikimedia.org/math/5/0/3/503c42963e7b78c5a522505307b0932d.png" /> time, where <i>n</i> is the length of the list.</p>
<p><a name="Linear_minimum.2Fmaximum_algorithms" id="Linear_minimum.2Fmaximum_algorithms"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=2" title="Edit section: Linear minimum/maximum algorithms">edit</a>]</span> <span class="mw-headline">Linear minimum/maximum algorithms</span></h2>
<p>Linear time algorithms to find minimums or maximums work by iterating over the list and keeping track of the minimum or maximum element so far.</p>
<p><a name="Nonlinear_general_selection_algorithm" id="Nonlinear_general_selection_algorithm"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=3" title="Edit section: Nonlinear general selection algorithm">edit</a>]</span> <span class="mw-headline">Nonlinear general selection algorithm</span></h2>
<p>Using the same ideas used in minimum/maximum algorithms, we can construct a simple, but inefficient general algorithm for finding the <i>k</i>th smallest or <i>k</i>th largest item in a list, requiring O(<i>kn</i>) time, which is effective when <i>k</i> is small. To accomplish this, we simply find the most extreme value and move it to the beginning until we reach our desired index. This can be seen as an incomplete <a href="/wiki/Selection_sort" title="Selection sort">selection sort</a>. Here is the minimum-based algorithm:</p>
<pre>
 <b>function</b> select(list[1..n], k)
     <b>for</b> i <b>from</b> 1 <b>to</b> k
         minIndex = i
         minValue = list[i]
         <b>for</b> j <b>from</b> i+1 <b>to</b> n
             <b>if</b> list[j] &lt; minValue
                 minIndex = j
                 minValue = list[j]
         swap list[i] and list[minIndex]
     <b>return</b> list[k]
</pre>
<p>Other advantages of this method are:</p>
<ul>
<li>After locating the <i>j</i>th smallest element, it requires only O(<i>j</i> + (<i>k</i>-<i>j</i>)<sup>2</sup>) time to find the <i>k</i>th smallest element, or only O(<i>k</i>) for <i>k</i> ≤ <i>j</i>.</li>
<li>It can be done with <a href="/wiki/Linked_list" title="Linked list">linked list</a> data structures, whereas the one based on partition requires <a href="/wiki/Random_access" title="Random access">random access</a>.</li>
</ul>
<p><a name="Partition-based_general_selection_algorithm" id="Partition-based_general_selection_algorithm"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=4" title="Edit section: Partition-based general selection algorithm">edit</a>]</span> <span class="mw-headline">Partition-based general selection algorithm</span></h2>
<p>A worst-case linear algorithm for the general case of selecting the <i>k</i>th largest element was published by Blum, Floyd, Pratt, Rivest, and Tarjan in their 1973 paper <i>Time bounds for selection</i>, sometimes called <b>BFPRT</b> after the last names of the authors. The algorithm that it is based on was conceived by the inventor of <a href="/wiki/Quicksort" title="Quicksort">quicksort</a>, <a href="/wiki/C.A.R._Hoare" title="C.A.R. Hoare" class="mw-redirect">C.A.R. Hoare</a>, and is known as <b>Hoare's selection algorithm</b> or <b>quickselect</b>.</p>
<p>In quicksort, there is a subprocedure called partition that can, in linear time, group a list (ranging from indices <code>left</code> to <code>right</code>) into two parts, those less than a certain element, and those greater than or equal to the element. Here is pseudocode that performs a partition about the element <code>list[pivotIndex]</code>:</p>
<pre>
 <b>function</b> partition(list, left, right, pivotIndex)
     pivotValue := list[pivotIndex]
     swap list[pivotIndex] and list[right]  <i>// Move pivot to end</i>
     storeIndex := left
     <b>for</b> i <b>from</b> left <b>to</b> right-1
         <b>if</b> list[i] &lt; pivotValue
             swap list[storeIndex] and list[i]
             storeIndex := storeIndex + 1
     swap list[right] and list[storeIndex]  <i>// Move pivot to its final place</i>
     <b>return</b> storeIndex
</pre>
<p>In quicksort, we recursively sort both branches, leading to best-case <a href="/wiki/Big-O_notation" title="Big-O notation" class="mw-redirect">Ω</a>(<i>n</i> log <i>n</i>) time. However, when doing selection, we already know which partition our desired element lies in, since the pivot is in its final sorted position, with all those preceding it in sorted order preceding it and all those following it in sorted order following it. Thus a single recursive call locates the desired element in the correct partition:</p>
<pre>
 <b>function</b> select(list, left, right, k)
     select pivotIndex between left and right
     pivotNewIndex := partition(list, left, right, pivotIndex)
     <b>if</b> k = pivotNewIndex
         <b>return</b> list[k]
     <b>else if</b> k &lt; pivotNewIndex
         <b>return</b> select(list, left, pivotNewIndex-1, k)
     <b>else</b>
         <b>return</b> select(list, pivotNewIndex+1, right, k)
</pre>
<p>Note the resemblance to quicksort; indeed, just as the minimum-based selection algorithm is a partial selection sort, this is a partial quicksort, generating and partitioning only O(log <i>n</i>) of its O(<i>n</i>) partitions. This simple procedure has expected linear performance, and, like quicksort, has quite good performance in practice. It is also an <a href="/wiki/In-place_algorithm" title="In-place algorithm">in-place algorithm</a>, requiring only constant memory overhead, since the <a href="/wiki/Tail_recursion" title="Tail recursion">tail recursion</a> can be eliminated with a loop like this:</p>
<pre>
 <b>function</b> select(list, left, right, k)
     <b>loop</b>
         select pivotIndex between left and right
         pivotNewIndex := partition(list, left, right, pivotIndex)
         <b>if</b> k = pivotNewIndex
             <b>return</b> list[k]
         <b>else if</b> k &lt; pivotNewIndex
             right := pivotNewIndex-1
         <b>else</b>
             left := pivotNewIndex+1

</pre>
<p>Like quicksort, the performance of the algorithm is sensitive to the pivot that is chosen. If bad pivots are consistently chosen, this degrades to the minimum-based selection described previously, and so can require as much as O(<i>n</i><sup>2</sup>) time. David Musser describes a "median-of-3 killer" sequence that can force the well-known median-of-three pivot selection algorithm to fail with worst-case behavior (see <i><a href="#Introselect" title="">Introselect</a></i> section below).</p>
<p><a name="Linear_general_selection_algorithm_-_.22Median_of_Medians_algorithm.22" id="Linear_general_selection_algorithm_-_.22Median_of_Medians_algorithm.22"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=5" title="Edit section: Linear general selection algorithm - &quot;Median of Medians algorithm&quot;">edit</a>]</span> <span class="mw-headline">Linear general selection algorithm - "Median of Medians algorithm"</span></h2>
<p>The key to making the previous algorithm worst-case linear and the primary contribution of "Time bounds for selection" is the "median of medians algorithm", which consistently finds good pivots.</p>
<p>This algorithm divides the list into groups of five elements. Left over elements are ignored for now. Then, for each group of five, the median is calculated: an operation that can potentially be made very fast if the five values can be loaded into registers and compared. These medians are moved into one contiguous block in the list, <i>select</i> is called recursively on this sublist of <i>n</i>/5 elements to find new median values. Finally, the "median of medians" is the pivot.</p>
<p>The chosen pivot is both less than and greater than half of the elements in the list of medians, which is around <i>n</i>/10 elements for each half. Each of these elements is a median of 5, making it less than 2 other elements and greater than 2 other elements outside the block. Hence, the pivot is less than <span class="texhtml">2(<i>n</i> / 10)</span> elements outside the block, and greater than another <span class="texhtml">2(<i>n</i> / 10)</span> elements outside the block. Thus the chosen median splits the elements somewhere between 30%/70% and 70%/30%, which assures worst-case linear behavior of the algorithm.</p>
<p>The median-calculating recursive call does not exceed worst-case linear behavior because the list of medians is 20% of the size of the list, while the other recursive call recurs on at most 70% of the list, making the running time</p>
<pre>
 T(<i>n</i>) ≤ T(<i>n</i>/5) + T(7<i>n</i>/10) + O(<i>n</i>)
</pre>
<p>The O(<i>n</i>) is for the partitioning work. An induction argument can then show that T(<i>n</i>) is indeed O(<i>n</i>).</p>
<p>Although this approach optimizes quite well, it is typically outperformed in practice by the expected linear algorithm with random pivot choices.</p>
<p>The worst-case algorithm can construct a worst-case <span class="texhtml"><i>O</i>(<i>n</i><i>l</i><i>o</i><i>g</i><i>n</i>)</span> quicksort algorithm, by using it to find the median at every step.</p>
<p><a name="Introselect" id="Introselect"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=6" title="Edit section: Introselect">edit</a>]</span> <span class="mw-headline">Introselect</span></h2>
<p>David Musser's well-known <a href="/wiki/Introsort" title="Introsort">introsort</a> achieves practical performance comparable to quicksort while preserving O(<i>n</i> log <i>n</i>) worst-case behavior by creating a hybrid of quicksort and <a href="/wiki/Heapsort" title="Heapsort">heapsort</a>. In the same paper, Musser introduced an "introspective selection" algorithm, popularly called <b>introselect</b>, which combines Hoare's algorithm with the worst-case linear algorithm described above to achieve worst-case linear selection with performance similar to Hoare's algorithm.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup> It works by optimistically starting out with Hoare's algorithm and only switching to the worst-time linear algorithm if it recurs too many times without making sufficient progress. Simply limiting the recursion to constant depth is not good enough, since this would make the algorithm switch on all sufficiently large lists. Musser discusses a couple of simple approaches:</p>
<ul>
<li>Keep track of the list of sizes of the subpartitions processed so far. If at any point <i>k</i> recursive calls have been made without halving the list size, for some small positive <i>k</i>, switch to the worst-case linear algorithm.</li>
<li>Sum the size of all partitions generated so far. If this exceeds the list size times some small positive constant <i>k</i>, switch to the worst-case linear algorithm. This sum is easy to track in a single scalar variable.</li>
</ul>
<p>Both approaches limit the recursion depth to O(<i>k</i>log <i>n</i>), which is O(log <i>n</i>) since <i>k</i> is a predetermined constant. The paper suggested that more research on introselect was forthcoming, but as of 2007 it has not appeared.</p>
<p><a name="Selection_as_incremental_sorting" id="Selection_as_incremental_sorting"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=7" title="Edit section: Selection as incremental sorting">edit</a>]</span> <span class="mw-headline">Selection as incremental sorting</span></h2>
<p>One of the advantages of the sort-and-index approach, as mentioned, is its ability to <a href="/wiki/Amortized_analysis" title="Amortized analysis">amortize</a> the sorting cost over many subsequent selections. However, sometimes the number of selections that will be done is not known in advance, and may be either small or large. In these cases, we can adapt the algorithms given above to simultaneously select an element while partially sorting the list, thus accelerating future selections.</p>
<p>Both the selection procedure based on minimum-finding and the one based on partitioning can be seen as a form of partial sort. The minimum-based algorithm sorts the list up to the given index, and so clearly speeds up future selections, especially of smaller indexes. The partition-based algorithm does not achieve the same behaviour automatically, but can be adapted to remember its previous pivot choices and reuse them wherever possible, avoiding costly partition operations, particularly the top-level one. The list becomes gradually more sorted as more partition operations are done incrementally; no pivots are ever "lost." If desired, this same pivot list could be passed on to quicksort to reuse, again avoiding many costly partition operations.</p>
<p><a name="Using_data_structures_to_select_in_sublinear_time" id="Using_data_structures_to_select_in_sublinear_time"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=8" title="Edit section: Using data structures to select in sublinear time">edit</a>]</span> <span class="mw-headline">Using data structures to select in sublinear time</span></h2>
<p>Given an unorganized list of data, linear time (Ω(<i>n</i>)) is required to find the minimum element, because we have to examine every element (otherwise, we might miss it). If we organize the list, for example by keeping it sorted at all times, then selecting the <i>k</i>th largest element is trivial, but then insertion requires linear time, as do other operations such as combining two lists.</p>
<p>The strategy to find an order statistic in <a href="/wiki/Sublinear_time" title="Sublinear time" class="mw-redirect">sublinear time</a> is to store the data in an organized fashion using suitable data structures that facilitate the selection. Two such data structures are tree based structures and frequency tables.</p>
<p>When only the minimum (or maximum) is needed, a good approach is to use a <a href="/wiki/Priority_queue" title="Priority queue">priority queue</a>, which is able to find the minimum (or maximum) element in constant time, while all other operations, including insertion, are O(log <i>n</i>) or better. More generally, a <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing binary search tree</a> can easily be augmented to make it possible to both insert an element and find the <i>k</i>th largest element in O(log <i>n</i>) time. We simply store in each node a count of how many descendants it has, and use this to determine which path to follow. The information can be updated efficiently since adding a node only affects the counts of its O(log <i>n</i>) ancestors, and tree rotations only affect the counts of the nodes involved in the rotation.</p>
<p>Another simple strategy is based on some of the same concepts as the <a href="/wiki/Hash_table" title="Hash table">hash table</a>. When we know the range of values beforehand, we can divide that range into <i>h</i> subintervals and assign these to <i>h</i> buckets. When we insert an element, we add it to the bucket corresponding to the interval it falls in. To find the minimum or maximum element, we scan from the beginning or end for the first nonempty bucket and find the minimum or maximum element in that bucket. In general, to find the <i>k</i>th element, we maintain a count of the number of elements in each bucket, then scan the buckets from left to right adding up counts until we find the bucket containing the desired element, then use the expected linear-time algorithm to find the correct element in that bucket.</p>
<p>If we choose <i>h</i> of size roughly sqrt(<i>n</i>), and the input is close to uniformly distributed, this scheme can perform selections in expected O(sqrt(<i>n</i>)) time. Unfortunately, this strategy is also sensitive to clustering of elements in a narrow interval, which may result in buckets with large numbers of elements (clustering can be eliminated through a good hash function, but finding the element with the <i>k</i>th largest hash value isn't very useful). Additionally, like hash tables this structure requires table resizings to maintain efficiency as elements are added and <i>n</i> becomes much larger than <i>h</i><sup>2</sup>. A useful case of this is finding an order statistic or extremum in a finite range of data, like marks limited 1 to 100 numbers for much higher number of students. Using above table with bucket interval 1 and maintaining counts in each bucket is much superior to other methods. Such hash tables are like <a href="/wiki/Frequency_tables" title="Frequency tables" class="mw-redirect">frequency tables</a> used to classify the data in <a href="/wiki/Descriptive_statistics" title="Descriptive statistics">descriptive statistics</a>.</p>
<p><a name="Selecting_k_smallest_or_largest_elements" id="Selecting_k_smallest_or_largest_elements"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=9" title="Edit section: Selecting k smallest or largest elements">edit</a>]</span> <span class="mw-headline">Selecting k smallest or largest elements</span></h2>
<p>Another fundamental selection problem is that of selecting the <i>k</i> smallest or <i>k</i> largest elements, which is particularly useful where we want to present just the "top <i>k</i>" of an unsorted list, such as the top 100 corporations by gross sales.</p>
<p><a name="Repeated_application_of_simple_selection_algorithms" id="Repeated_application_of_simple_selection_algorithms"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=10" title="Edit section: Repeated application of simple selection algorithms">edit</a>]</span> <span class="mw-headline">Repeated application of simple selection algorithms</span></h3>
<p>A number of simple but inefficient solutions are possible. We can use the linear-time solutions discussed above to select each element one at a time, resulting in time O(<i>kn</i>) — we can achieve the same time just by running the first <i>k</i> iterations of <a href="/wiki/Selection_sort" title="Selection sort">selection sort</a>. If log <i>n</i> is much less than <i>k</i>, a better simple strategy is to sort the list and then take the first or last <i>k</i> elements.</p>
<p><a name="Direct_application_of_the_quick_sort_based_selection_algorithm" id="Direct_application_of_the_quick_sort_based_selection_algorithm"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=11" title="Edit section: Direct application of the quick sort based selection algorithm">edit</a>]</span> <span class="mw-headline">Direct application of the quick sort based selection algorithm</span></h3>
<p>The quick sort based selection algorithm can be used to find k smallest or k largest elements. To find k smallest elements find the kth smallest element using the median of medians quick sort based algorithm. After the partition that finds the kth smallest element, all the elements smaller than the kth smaller element will be present left to the kth element and all element larger will be present right to the kth smallest element. Thus all elements from 1st to kth element inclusive constitute the k smallest elements. The time complexity is linear in n, the total number of elements.</p>
<p><a name="Data_structure_based_solutions" id="Data_structure_based_solutions"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=12" title="Edit section: Data structure based solutions">edit</a>]</span> <span class="mw-headline">Data structure based solutions</span></h3>
<p>Another simple method is to add each element of the list into an ordered set data structure, such as a <a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">heap</a> or <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing binary search tree</a>, with at most <i>k</i> elements. Whenever the data structure has more than <i>k</i> elements, we remove the largest element, which can be done in O(log <i>k</i>) time. Each insertion operation also takes O(log <i>k</i>) time, resulting in O(<i>n</i>log <i>k</i>) time overall.</p>
<p>It is possible to transform the list into a <a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">heap</a> in Θ(<i>n</i>) time, and then traverse the heap using a modified <a href="/wiki/Breadth-first_search" title="Breadth-first search">Breadth-first search</a> algorithm that places the elements in a <a href="/wiki/Priority_Queue" title="Priority Queue" class="mw-redirect">Priority Queue</a> (instead of the ordinary queue that is normally used in a BFS), and terminate the scan after traversing exactly k elements. As the queue size remains O(<i>k</i>) throughout the traversal, it would require O(<i>k</i>log <i>k</i>) time to complete, leading to a time bound of O(<i>n</i> + <i>k</i>log <i>k</i>) on this algorithm.</p>
<p><a name="Optimised_sorting_algorithms" id="Optimised_sorting_algorithms"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=13" title="Edit section: Optimised sorting algorithms">edit</a>]</span> <span class="mw-headline">Optimised sorting algorithms</span></h3>
<p>More efficient than any of these are specialized partial sorting algorithms based on <a href="/wiki/Mergesort" title="Mergesort" class="mw-redirect">mergesort</a> and <a href="/wiki/Quicksort" title="Quicksort">quicksort</a>. The simplest is the quicksort variation: there is no need to recursively sort partitions which only contain elements that would fall after the <i>k</i>th place in the end. Thus, if the pivot falls in position <i>k</i> or later, we recur only on the left partition:</p>
<pre>
 <b>function</b> quicksortFirstK(list, left, right, k)
     <b>if</b> right &gt; left
         select pivotIndex between left and right
         pivotNewIndex := partition(list, left, right, pivotIndex)
         quicksortFirstK(list, left, pivotNewIndex-1, k)
         <b>if</b> pivotNewIndex &lt; k
             quicksortFirstK(list, pivotNewIndex+1, right, k)
</pre>
<p>The resulting algorithm requires an expected time of only O(<i>n</i> + <i>k</i>log<i>k</i>), and is quite efficient in practice, especially if we substitute selection sort when <i>k</i> becomes small relative to <i>n</i>.</p>
<p>Even better is if we don't require those <i>k</i> items to be themselves sorted. Losing that requirement means we can ignore all partitions that fall entirely before <b>or</b> after the <i>k</i>th place. We recur only into the partition that actually contains the <i>k</i>th element itself.</p>
<pre>
 <b>function</b> findFirstK(list, left, right, k)
     <b>if</b> right &gt; left
         select pivotIndex between left and right
         pivotNewIndex := partition(list, left, right, pivotIndex)
         <b>if</b> pivotNewIndex &gt; k  <i>// new condition</i>
             findFirstK(list, left, pivotNewIndex-1, k)
         <b>if</b> pivotNewIndex &lt; k
             findFirstK(list, pivotNewIndex+1, right, k)
</pre>
<p>The resulting algorithm requires an expected time of only O(<i>n</i>), which is just about the best any algorithm can hope for.</p>
<p><a name="Tournament_Algorithm" id="Tournament_Algorithm"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=14" title="Edit section: Tournament Algorithm">edit</a>]</span> <span class="mw-headline">Tournament Algorithm</span></h3>
<p>Another method is tournament algorithm. The idea is to conduct a knockout minimal round tournament to decide the ranks. It first organises the games(comparisons) between adjacent pairs and moves the winners to next round until championship(the first best) is decided. It also constructs the tournament tree along the way. Now the second best element must be among the direct losers to winner and these losers can be found out by walking in the binary tree in O(log <i>n</i>) time. It organises another tournament to decide the second best among these potential elements. The third best must be one among the losers of the second best in either of the two tournament trees. The approach continues until we find k elements. This algorithm takes O(n + k log <i>n</i>) complexity, which for any fixed <i>k</i> independent of <i>n</i> is O(<i>n</i>).</p>
<p><a name="Lower_bounds" id="Lower_bounds"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=15" title="Edit section: Lower bounds">edit</a>]</span> <span class="mw-headline">Lower bounds</span></h2>
<p>In his seminal <i><a href="/wiki/The_Art_of_Computer_Programming" title="The Art of Computer Programming">The Art of Computer Programming</a></i>, Donald E. Knuth discussed a number of lower bounds for the number of comparisons required to locate the <i>k</i> smallest entries of an unorganized list of <i>n</i> items (using only comparisons). There's a trivial lower bound of <i>n</i> − 1 for the minimum or maximum entry. To see this, consider a tournament where each game represents one comparison. Since every player except the winner of the tournament must lose a game before we know the winner, we have a lower bound of <i>n</i> − 1 comparisons.</p>
<p>The story becomes more complex for other indexes. To find the <i>k</i> smallest values requires at least this many comparisons:</p>
<dl>
<dd><img class="tex" alt="n - k + \sum_{n+1-k &lt; j \leq n} \lceil{\operatorname{lg}\, j}\rceil." src="http://upload.wikimedia.org/math/b/6/e/b6e53640ba4fe408b6a06e8641915892.png" /></dd>
</dl>
<p>This bound is achievable for <i>k</i>=2 but better, more complex bounds exist for larger <i>k</i>.</p>
<p><a name="Language_support" id="Language_support"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=16" title="Edit section: Language support">edit</a>]</span> <span class="mw-headline">Language support</span></h2>
<p>Very few languages have built-in support for general selection, although many provide facilities for finding the smallest or largest element of a list. A notable exception is <a href="/wiki/C%2B%2B" title="C++">C++</a>, which provides a templated <code>nth_element</code> method with a guarantee of expected linear time. It is implied but not required that it is based on Hoare's algorithm by its requirement of expected linear time. (Ref section 25.3.2 of ISO/IEC 14882:2003(E) and 14882:1998(E), see also <a href="http://www.sgi.com/tech/stl/nth_element.html" class="external text" title="http://www.sgi.com/tech/stl/nth_element.html" rel="nofollow">SGI STL description of nth_element</a>)</p>
<p>C++ also provides the <a href="http://www.sgi.com/tech/stl/partial_sort.html" class="external text" title="http://www.sgi.com/tech/stl/partial_sort.html" rel="nofollow">partial_sort</a> algorithm, which solves the problem of selecting the smallest <i>k</i> elements (sorted), with a time complexity of O(<i>n</i>log <i>k</i>). No algorithm is provided for selecting the greatest <i>k</i> elements, but this can easily be achieved by inverting the ordering <a href="/wiki/Predicate_(computer_programming)" title="Predicate (computer programming)" class="mw-redirect">predicate</a>.</p>
<p>For <a href="/wiki/Perl" title="Perl">Perl</a>, the module <a href="http://search.cpan.org/~salva/Sort-Key-Top" class="external text" title="http://search.cpan.org/~salva/Sort-Key-Top" rel="nofollow">Sort::Key::Top</a>, available from <a href="/wiki/CPAN" title="CPAN">CPAN</a>, provides a set of functions to select the top n elements from a list using several orderings and custom key extraction procedures.</p>
<p>Because <a href="/wiki/Sorting_algorithm#Language_support" title="Sorting algorithm">language support for sorting</a> is more ubiquitous, the simplistic approach of sorting followed by indexing is preferred in many environments despite its disadvantage in speed. Indeed for <a href="/wiki/Lazy_evaluation" title="Lazy evaluation">lazy languages</a>, this simplistic approach can even get you the best complexity possible for the k smallest/greatest sorted (with maximum/minimum as a special case) if your sort is lazy enough.</p>
<p><a name="Online_selection_algorithm" id="Online_selection_algorithm"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=17" title="Edit section: Online selection algorithm">edit</a>]</span> <span class="mw-headline">Online selection algorithm</span></h2>
<p>In certain selection problems, selection must be online, that is, an element can only be selected from a sequential input at the instance of observation and each selection, respectively refusal, is irrevocable. The problem is to select, under these constraints, a	 specific element of the input sequence (as for example the largest or the smallest value)	 with largest probability. This problem can be tackled by the <a href="/wiki/Odds_algorithm" title="Odds algorithm">Odds algorithm</a> which is known to be optimal under an independence condition. The algorithm is also optimal itself	 with the number of operations being linear in the length of input.</p>
<p><a name="Notes" id="Notes"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=18" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline">Notes</span></h2>
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> David R. Musser. Introspective Sorting and Selection Algorithms. <i>Software: Practice and Experience</i>, vol. 27, no. 8, pp.983–993. 1997. Section: Introspective Selection Algorithms.</li>
</ol>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=19" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<ul>
<li><a href="/wiki/Manuel_Blum" title="Manuel Blum">M. Blum</a>, <a href="/wiki/Robert_Floyd" title="Robert Floyd">R.W. Floyd</a>, <a href="/wiki/Vaughan_Ronald_Pratt" title="Vaughan Ronald Pratt" class="mw-redirect">V. Pratt</a>, <a href="/wiki/Ron_Rivest" title="Ron Rivest">R. Rivest</a> and <a href="/wiki/Robert_Tarjan" title="Robert Tarjan">R. Tarjan</a>, "Time bounds for selection," <i>J. Comput. System Sci</i>. 7 (1973) 448-461.</li>
<li><a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a>. <i><a href="/wiki/The_Art_of_Computer_Programming" title="The Art of Computer Programming">The Art of Computer Programming</a></i>, Volume 3: <i>Sorting and Searching</i>, Third Edition. Addison-Wesley, 1997. <a href="/wiki/Special:BookSources/0201896850" class="internal">ISBN 0-201-89685-0</a>. Section 5.3.3: Minimum-Comparison Selection, pp.207–219.</li>
<li><a href="/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Thomas H. Cormen</a>, <a href="/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Charles E. Leiserson</a>, <a href="/wiki/Ronald_L._Rivest" title="Ronald L. Rivest" class="mw-redirect">Ronald L. Rivest</a>, and <a href="/wiki/Clifford_Stein" title="Clifford Stein">Clifford Stein</a>. <i><a href="/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i>, Second Edition. MIT Press and McGraw-Hill, 2001. <a href="/wiki/Special:BookSources/0262032937" class="internal">ISBN 0-262-03293-7</a>. Chapter 9: Medians and Order Statistics, pp.183–196. Section 14.1: Dynamic order statistics, pp.302–308.</li>
<li><a href="/wiki/File:PD-icon.svg" class="image" title="PD-icon.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/62/PD-icon.svg/15px-PD-icon.svg.png" width="15" height="15" border="0" /></a>&#160;<i>This article incorporates <a href="/wiki/Copyright_status_of_work_by_the_U.S._government" title="Copyright status of work by the U.S. government">public domain material</a> from the <a href="/wiki/NIST_Dictionary_of_Algorithms_and_Data_Structures" title="NIST Dictionary of Algorithms and Data Structures" class="mw-redirect">NIST Dictionary of Algorithms and Data Structures</a></i>&#160;document <a href="http://www.nist.gov/dads/HTML/select.html" class="external text" title="http://www.nist.gov/dads/HTML/select.html" rel="nofollow">"Select"</a>.</li>
</ul>
<p><br /></p>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Selection_algorithm&amp;action=edit&amp;section=20" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://www.ics.uci.edu/~eppstein/161/960130.html" class="external text" title="http://www.ics.uci.edu/~eppstein/161/960130.html" rel="nofollow">Design and Analysis of Algorithms</a>, for a detailed explanation of the recurrence relation for the median-of-medians</li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 230/1000000
Post-expand include size: 3576/2048000 bytes
Template argument size: 887/2048000 bytes
Expensive parser function count: 1/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:552786-0!1!0!default!!en!2 and timestamp 20090411175056 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Selection_algorithm">http://en.wikipedia.org/wiki/Selection_algorithm</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Selection_algorithms" title="Category:Selection algorithms">Selection algorithms</a></span></div><div id="mw-hidden-catlinks" class="mw-hidden-cats-hidden">Hidden categories:&#32;<span dir='ltr'><a href="/wiki/Category:Articles_with_unsourced_statements_since_December_2008" title="Category:Articles with unsourced statements since December 2008">Articles with unsourced statements since December 2008</a></span> | <span dir='ltr'><a href="/wiki/Category:All_articles_with_unsourced_statements" title="Category:All articles with unsourced statements">All articles with unsourced statements</a></span> | <span dir='ltr'><a href="/wiki/Category:Wikipedia_articles_incorporating_text_from_public_domain_works_of_the_United_States_Government" title="Category:Wikipedia articles incorporating text from public domain works of the United States Government">Wikipedia articles incorporating text from public domain works of the United States Government</a></span> | <span dir='ltr'><a href="/wiki/Category:Wikipedia_articles_incorporating_text_from_the_NIST_Dictionary_of_Algorithms_and_Data_Structures" title="Category:Wikipedia articles incorporating text from the NIST Dictionary of Algorithms and Data Structures">Wikipedia articles incorporating text from the NIST Dictionary of Algorithms and Data Structures</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Selection_algorithm" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Selection_algorithm" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Selection_algorithm&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Selection_algorithm&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Selection_algorithm" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Selection_algorithm" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Selection_algorithm" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Selection_algorithm&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Selection_algorithm&amp;oldid=265806713" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Selection_algorithm&amp;id=265806713">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-id"><a href="http://id.wikipedia.org/wiki/Algoritma_seleksi">Bahasa Indonesia</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E9%81%B8%E6%8A%9E%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Selekcja_(informatyka)">Polski</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/BFPRT-%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC">Русский</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 22 January 2009, at 23:21 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv182 in 0.571 secs. --></body></html>
