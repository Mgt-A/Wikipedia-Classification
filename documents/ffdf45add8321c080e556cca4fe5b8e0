<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Burroughs large systems,Articles with unsourced statements since February 2007,Articles with unsourced statements since September 2007,2007,68k,ALGOL,APL (programming language),ASIC,Accounting Machine,Alan Kay,Algol 60" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Burroughs_large_systems&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Burroughs_large_systems&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Burroughs large systems - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Burroughs_large_systems";
		var wgTitle = "Burroughs large systems";
		var wgAction = "view";
		var wgArticleId = "332693";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 285508118;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Burroughs_large_systems skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Burroughs large systems</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p>The <b>Burroughs large systems</b> were the largest of three series of <a href="/wiki/Burroughs_Corporation" title="Burroughs Corporation">Burroughs Corporation</a> mainframe computers. Founded in the 1880s, Burroughs was the oldest continuously operating entity in computing, but by the late 1950s its computing equipment was still limited to electromechanical <a href="/wiki/Accounting_Machine" title="Accounting Machine">accounting machines</a> such as the <a href="/wiki/Burroughs_Sensimatic" title="Burroughs Sensimatic" class="mw-redirect">Sensimatic</a>; as such it had nothing to compete with its traditional rivals <a href="/wiki/IBM" title="IBM">IBM</a> and <a href="/wiki/NCR_Corporation" title="NCR Corporation">NCR</a> who had started to produce larger-scale computers, or with recently-founded <a href="/wiki/Univac" title="Univac" class="mw-redirect">Univac</a>. The first machine, the B5000, was designed in 1961 and Burroughs sought to address its late entry in the market with the strategy of a completely different design based on the most advanced computing ideas available at the time. Computers using this architecture were still in production in 2005 as the <a href="/wiki/Unisys" title="Unisys">Unisys</a> ClearPath/MCP machines. Unisys now uses <a href="/wiki/Intel_Xeon" title="Intel Xeon" class="mw-redirect">Intel Xeon</a> processors, and run <a href="/wiki/Burroughs_MCP" title="Burroughs MCP">MCP</a>, <a href="/wiki/Microsoft_Windows" title="Microsoft Windows">Microsoft Windows</a> and <a href="/wiki/Linux" title="Linux">Linux</a> operating systems on their servers.</p>
<div class="thumb tright">
<div class="thumbinner" style="width:422px;"><a href="/wiki/File:B6700.jpg" class="image" title="Figure 4.5 From the ACM Monograph in the References. Elliot Organick 1973."><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/98/B6700.jpg/420px-B6700.jpg" width="420" height="494" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:B6700.jpg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Figure 4.5 From the ACM Monograph in the References. <i><a href="/wiki/Elliot_Organick" title="Elliot Organick">Elliot Organick</a> 1973.</i></div>
</div>
</div>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#B5000"><span class="tocnumber">1</span> <span class="toctext">B5000</span></a></li>
<li class="toclevel-1"><a href="#Unique_features"><span class="tocnumber">2</span> <span class="toctext">Unique features</span></a>
<ul>
<li class="toclevel-2"><a href="#Unique_system_design"><span class="tocnumber">2.1</span> <span class="toctext">Unique system design</span></a></li>
<li class="toclevel-2"><a href="#Language_support"><span class="tocnumber">2.2</span> <span class="toctext">Language support</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#History"><span class="tocnumber">3</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1"><a href="#ALGOL"><span class="tocnumber">4</span> <span class="toctext">ALGOL</span></a>
<ul>
<li class="toclevel-2"><a href="#ESPOL_and_NEWP"><span class="tocnumber">4.1</span> <span class="toctext">ESPOL and NEWP</span></a></li>
<li class="toclevel-2"><a href="#DCALGOL_and_Message_Control_Systems_.28MCS.29"><span class="tocnumber">4.2</span> <span class="toctext">DCALGOL and Message Control Systems (MCS)</span></a></li>
<li class="toclevel-2"><a href="#DMALGOL_and_databases"><span class="tocnumber">4.3</span> <span class="toctext">DMALGOL and databases</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Stack_architecture"><span class="tocnumber">5</span> <span class="toctext">Stack architecture</span></a>
<ul>
<li class="toclevel-2"><a href="#Stack_speed_and_performance"><span class="tocnumber">5.1</span> <span class="toctext">Stack speed and performance</span></a></li>
<li class="toclevel-2"><a href="#How_programs_map_to_the_stack_architecture"><span class="tocnumber">5.2</span> <span class="toctext">How programs map to the stack architecture</span></a></li>
<li class="toclevel-2"><a href="#Procedures"><span class="tocnumber">5.3</span> <span class="toctext">Procedures</span></a>
<ul>
<li class="toclevel-3"><a href="#Run_invocation_type"><span class="tocnumber">5.3.1</span> <span class="toctext">Run invocation type</span></a></li>
<li class="toclevel-3"><a href="#Inline_procedures"><span class="tocnumber">5.3.2</span> <span class="toctext">Inline procedures</span></a></li>
<li class="toclevel-3"><a href="#Asynchronous_calls"><span class="tocnumber">5.3.3</span> <span class="toctext">Asynchronous calls</span></a></li>
<li class="toclevel-3"><a href="#Display_registers"><span class="tocnumber">5.3.4</span> <span class="toctext">Display registers</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Stack_structure_advantages"><span class="tocnumber">5.4</span> <span class="toctext">Stack structure advantages</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Tagged_architecture"><span class="tocnumber">6</span> <span class="toctext">Tagged architecture</span></a></li>
<li class="toclevel-1"><a href="#Descriptor-based_architecture"><span class="tocnumber">7</span> <span class="toctext">Descriptor-based architecture</span></a></li>
<li class="toclevel-1"><a href="#Instruction_set"><span class="tocnumber">8</span> <span class="toctext">Instruction set</span></a></li>
<li class="toclevel-1"><a href="#Multiple_processors"><span class="tocnumber">9</span> <span class="toctext">Multiple processors</span></a></li>
<li class="toclevel-1"><a href="#Influence_of_the_B5000"><span class="tocnumber">10</span> <span class="toctext">Influence of the B5000</span></a></li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">11</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#Notes"><span class="tocnumber">12</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">13</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#Further_reading"><span class="tocnumber">14</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">15</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="B5000" id="B5000"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=1" title="Edit section: B5000">edit</a>]</span> <span class="mw-headline">B5000</span></h2>
<p>The first member of the series, the B5000, was designed beginning in 1961 by a team under the leadership of <a href="/wiki/Robert_(Bob)_Barton" title="Robert (Bob) Barton" class="mw-redirect">Robert (Bob) Barton</a>. It was a unique machine, well ahead of its time. It has been listed by the influential computer architect <a href="/wiki/John_Mashey" title="John Mashey">John Mashey</a> as one of the architectures that he admires the most. "I always thought it was one of the most innovative examples of combined hardware/software design I've seen, and far ahead of its time."<sup id="cite_ref-johnmashey_0-0" class="reference"><a href="#cite_note-johnmashey-0" title=""><span>[</span>1<span>]</span></a></sup></p>
<p><a name="Unique_features" id="Unique_features"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=2" title="Edit section: Unique features">edit</a>]</span> <span class="mw-headline">Unique features</span></h2>
<ul>
<li>All code automatically <a href="/wiki/Reentrant_(subroutine)" title="Reentrant (subroutine)">reentrant</a> (fig 4.5 from the ACM Monograph shows <a href="/wiki/Zero_address_arithmetic" title="Zero address arithmetic">in a nutshell</a> why): programmers don't have to do anything to have any code in any language spread across processors than use just the two shown simple primitives. This is perhaps the canonical but no means the only benefit of the these major distinguishing features of this architecture:
<ul>
<li>Data-driven <a href="/wiki/Tagged_architecture" title="Tagged architecture">tagged</a> and descriptor-based architecture</li>
<li>Hardware was designed to support software requirements</li>
<li>Hardware designed to exclusively support <a href="/wiki/High-level_programming_language" title="High-level programming language">high-level</a> <a href="/wiki/Programming_languages" title="Programming languages" class="mw-redirect">programming languages</a></li>
<li>No <a href="/wiki/Assembly_language" title="Assembly language">Assembly language</a> or assembler; all system software written in an extended variety of <a href="/wiki/ALGOL" title="ALGOL">ALGOL</a></li>
<li>No programmer accessible registers</li>
<li>Simplified <a href="/wiki/Instruction_set" title="Instruction set">instruction set</a></li>
<li>Stack architecture (to support high-level algorithmic languages)</li>
<li>Support for high-level <a href="/wiki/Operating_system" title="Operating system">operating system</a> (MCP, <a href="/wiki/MCP_(Burroughs_Large_Systems)" title="MCP (Burroughs Large Systems)" class="mw-redirect">Master Control Program</a>)</li>
</ul>
</li>
</ul>
<ul>
<li>Support for master/slave multiprocessing</li>
<li>Support for other languages such as <a href="/wiki/COBOL" title="COBOL">COBOL</a></li>
<li>Powerful string manipulation</li>
<li>Secure architecture prohibiting unauthorized access of data or disruptions to operations</li>
<li>Early error-detection supporting development and testing of software</li>
<li>First commercial implementation of virtual memory</li>
<li>Successors still exist in the <a href="/wiki/Unisys" title="Unisys">Unisys</a> ClearPath/MCP machines</li>
<li>Influenced many of today's computing techniques</li>
</ul>
<p>In the following discussion, the machine designations, B5000, A Series, and ClearPath/MCP are used interchangeably although this needlessly conflates the features and concepts of the various machines and should be edited someday to keep clear the distinctions between the 5000, 5500, 6500 et seq, and A Series.</p>
<p><a name="Unique_system_design" id="Unique_system_design"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=3" title="Edit section: Unique system design">edit</a>]</span> <span class="mw-headline">Unique system design</span></h3>
<p>The B5000 was revolutionary at the time in that the architecture and instruction set were designed with the needs of software taken into consideration. This was a large departure from the computer system design of the time, where a processor and its instruction set would be designed and then handed over to the software people, and is still. That is, modern architectures such as <a href="/wiki/X86_architecture" title="X86 architecture" class="mw-redirect">x86</a> or <a href="/wiki/PowerPC" title="PowerPC">PPC</a> are essentially traditional instruction set based architectures rather than holistic designs like the original Burroughs systems.</p>
<p><a name="Language_support" id="Language_support"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=4" title="Edit section: Language support">edit</a>]</span> <span class="mw-headline">Language support</span></h3>
<p>The B5000 was designed to exclusively support high-level languages. This was at a time when such languages were just coming to prominence with <a href="/wiki/FORTRAN" title="FORTRAN" class="mw-redirect">FORTRAN</a> and then <a href="/wiki/COBOL" title="COBOL">COBOL</a>. FORTRAN and COBOL were considered weaker languages by some, when it comes to modern software techniques, so a newer, mostly untried language was adopted, <a href="/wiki/Algol_60" title="Algol 60" class="mw-redirect">ALGOL-60</a>. The ALGOL dialect chosen for the B5000 was <a href="/wiki/Elliott_ALGOL" title="Elliott ALGOL">Elliott ALGOL</a>, first designed and implemented by <a href="/wiki/C._A._R._Hoare" title="C. A. R. Hoare">C.A.R. Hoare</a> on an Elliot 503. This was a practical extension of ALGOL with IO instructions (which ALGOL had ignored) and powerful string processing instructions. Hoare's famous Turing lecture was on this subject.</p>
<p>Thus the B5000 was based on a very powerful language. Most other vendors could only dream of implementing an ALGOL compiler and most in the industry dismissed ALGOL as being unimplementable. However, a bright young student named <a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a> had previously implemented ALGOL-58 on an earlier Burroughs machine during the three months of his summer break. Many wrote ALGOL off, mistakenly believing that high-level languages could not have the same power as assembler, and thus not realizing ALGOL's potential as a systems programming language, an opinion not revised until the development of the <a href="/wiki/C_(programming_language)" title="C (programming language)">C programming language</a>.</p>
<p>The Burroughs ALGOL compiler was very fast — this impressed the Dutch scientist <a href="/wiki/Edsger_Dijkstra" title="Edsger Dijkstra" class="mw-redirect">Edsger Dijkstra</a> when he submitted a program to be compiled at the B5000 Pasadena plant. His deck of cards was compiled almost immediately and he immediately wanted several machines for his university ( <a href="/wiki/Eindhoven_University_of_Technology" title="Eindhoven University of Technology">Eindhoven University of Technology</a> ) back in Europe. The compiler was fast for several reasons, but the primary reason was that it was a "one-pass compiler." Early computers did not have enough memory to store the source code, so compilers (and even assemblers) usually needed to read the source code more than once. The ALGOL syntax requires that each variable (or other object) be declared before it is used, so it is feasible to write an ALGOL compiler that reads the data only once. This concept has profound theoretical implications, but it also permits very fast compiling. Burroughs large systems could compile as fast as they could read the source code from the <a href="/wiki/Punched_card" title="Punched card">punched cards</a>, and they had the fastest card readers in the industry.</p>
<p>The powerful Burroughs COBOL compiler was also a one-pass compiler and equally fast. A 4000-card COBOL program compiled as fast as the 1000-card/minute readers could read the code. The program was ready to use as soon as the cards were through the reader.</p>
<p><a name="History" id="History"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=5" title="Edit section: History">edit</a>]</span> <span class="mw-headline">History</span></h2>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style="margin: 4px 1em 4px 0; width: 238px; border-collapse: collapse; font-size: 88%; line-height: 1.25em;">
<tr>
<td class="mbox-image"><a href="/wiki/File:Wiki_letter_w.svg" class="image" title="Wiki letter w.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/Wiki_letter_w.svg/20px-Wiki_letter_w.svg.png" width="20" height="20" border="0" /></a></td>
<td class="mbox-text" style="">This section requires <a href="http://en.wikipedia.org/w/index.php?title=Burroughs_large_systems&amp;action=edit" class="external text" title="http://en.wikipedia.org/w/index.php?title=Burroughs_large_systems&amp;action=edit" rel="nofollow">expansion</a>.</td>
</tr>
</table>
<p>The first of the Burroughs large systems was the B5000. Designed in 1961, it was a second-generation computer using <a href="/wiki/Discrete_device" title="Discrete device">discrete transistor</a> logic and <a href="/wiki/Magnetic_core_memory" title="Magnetic core memory">magnetic core memory</a>. The successor machines followed the hardware development trends to re-implement the architecture in new logic over the next 25 years, with the B5500, B6500, B5700, B6700, B7700, B6800, B7800, and finally the Burroughs A series. After Burroughs became part of Unisys, Unisys continued to develop new machines based on the <b>MCP <a href="/wiki/CMOS" title="CMOS">CMOS</a></b> <a href="/wiki/ASIC" title="ASIC" class="mw-redirect">ASIC</a>. These machines were the Libra 100 through the Libra 500, With the Libra 590 being announced in 2005. Later Libras, including the 590, also incorporate Intel Xeon processors and can run the Burroughs large systems architecture in emulation as well as on the MCP CMOS processors. It is unclear if Unisys will continue development of new MCP CMOS ASICs.</p>
<table class="wikitable" cellpadding="0" cellspacing="0" width="600" align="center">
<tr>
<th style="background: #017A5B;" colspan="4"><font color="white">Burroughs (1961-1986)</font></th>
</tr>
<tr>
<td><b>B5000</b></td>
<td>1961</td>
<td>initial system, 2nd generation (transistor) computer</td>
</tr>
<tr>
<td><b>B5500</b></td>
<td>1964</td>
<td>3x speed improvement(?)<sup id="cite_ref-1" class="reference"><a href="#cite_note-1" title=""><span>[</span>2<span>]</span></a></sup></td>
</tr>
<tr>
<td><b>B6500</b></td>
<td>1969</td>
<td>3rd gen computer (integrated circuits), up to 4 processors</td>
</tr>
<tr>
<td><b>B5700</b></td>
<td>1971</td>
<td>new name for B5500</td>
</tr>
<tr>
<td><b>B6700</b></td>
<td>1971</td>
<td>new name/bug fix for B6500</td>
</tr>
<tr>
<td><b>B7700</b></td>
<td>1972</td>
<td>faster processor, cache for stack, up to 8 processors.</td>
</tr>
<tr>
<td><b>B6800</b></td>
<td>1977?</td>
<td>semiconductor memory, <a href="/wiki/Non-Uniform_Memory_Access" title="Non-Uniform Memory Access">NUMA</a> architecture</td>
</tr>
<tr>
<td><b>B7800</b></td>
<td>1977?</td>
<td>semiconductor memory, faster, up to 16? processors</td>
</tr>
<tr>
<td><b>A Series</b></td>
<td>1984</td>
<td>Re-implemented in custom-designed Motorola <a href="/wiki/Emitter-coupled_logic" title="Emitter-coupled logic">ECL</a> MCA1, then MCA2 <a href="/wiki/Gate_array" title="Gate array">gate arrays</a></td>
</tr>
<tr>
<th style="background: #017A5B;" colspan="4"><font color="white">Unisys (1986-present))</font></th>
</tr>
<tr>
<td><b>Micro A</b></td>
<td>1989</td>
<td>desktop "mainframe" with single-chip SCAMP<sup id="cite_ref-2" class="reference"><a href="#cite_note-2" title=""><span>[</span>3<span>]</span></a></sup> processor.</td>
</tr>
<tr>
<td><b>Clearpath HMP NX 4000</b></td>
<td>198?</td>
<td>&#160;??</td>
</tr>
<tr>
<td><b>Clearpath HMP NX 5000</b></td>
<td>199?</td>
<td>&#160;??</td>
</tr>
<tr>
<td><b>Clearpath HMP LX 5000</b></td>
<td>1998</td>
<td>Implements Burroughs Large systems in emulation only (<a href="/w/index.php?title=Xeon_processor&amp;action=edit&amp;redlink=1" class="new" title="Xeon processor (page does not exist)">Xeon processors</a>)<sup id="cite_ref-3" class="reference"><a href="#cite_note-3" title=""><span>[</span>4<span>]</span></a></sup></td>
</tr>
<tr>
<td><b>Libra 100</b></td>
<td>2002?</td>
<td>&#160;??</td>
</tr>
<tr>
<td><b>Libra 200</b></td>
<td>200?</td>
<td>&#160;??</td>
</tr>
<tr>
<td><b>Libra 300</b></td>
<td>200?</td>
<td>&#160;??</td>
</tr>
<tr>
<td><b>Libra 400</b></td>
<td>200?</td>
<td>&#160;??</td>
</tr>
<tr>
<td><b>Libra 500</b></td>
<td>2005?</td>
<td>e.g. Libra 595<sup id="cite_ref-4" class="reference"><a href="#cite_note-4" title=""><span>[</span>5<span>]</span></a></sup></td>
</tr>
<tr>
<td><b>Libra 600</b></td>
<td>2006?</td>
<td>&#160;??</td>
</tr>
</table>
<p><a name="ALGOL" id="ALGOL"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=6" title="Edit section: ALGOL">edit</a>]</span> <span class="mw-headline">ALGOL</span></h2>
<p>The Burroughs large systems implement an <a href="/wiki/ALGOL" title="ALGOL">ALGOL</a>-derived <a href="/wiki/Stack_architecture" title="Stack architecture" class="mw-redirect">stack architecture</a>, unlike linear architectures such as <a href="/wiki/PDP-11" title="PDP-11">PDP-11</a>, <a href="/wiki/68k" title="68k" class="mw-redirect">Motorola M68k</a>, and <a href="/wiki/Itanium" title="Itanium">Itanium</a> or segmented architectures such as <a href="/wiki/X86" title="X86">x86</a> and <a href="/wiki/Texas_Instruments" title="Texas Instruments">Texas Instruments</a>. (This refers to the layout of the memory and how a program uses it.)</p>
<p>While B5000 was designed specifically around ALGOL, this was only a starting point. Other business-oriented languages such as COBOL were also well supported, most notably by the powerful string operators which were included for the development of fast compilers.</p>
<p>The ALGOL used on the B5000 is an extended ALGOL subset. It includes powerful string manipulation instructions but excludes certain ALGOL constructs, notably unspecified formal parameters. A DEFINE mechanism serves a similar purpose to the #defines found in C, but is fully integrated into the language rather than being a preprocessor. The EVENT data type facilitates coordination between processes, and ON FAULT blocks enable handling program faults.</p>
<p>The user level of ALGOL does not include many of the insecure constructs needed by the operating system and other system software. Two levels of language extensions provide the additional constructs: ESPOL and NEWP for writing the MCP and closely related software, and DCALGOL and DMALGOL to provide more specific extensions for specific kinds of system software.</p>
<p><a name="ESPOL_and_NEWP" id="ESPOL_and_NEWP"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=7" title="Edit section: ESPOL and NEWP">edit</a>]</span> <span class="mw-headline">ESPOL and NEWP</span></h3>
<p>Originally, the B5000 MCP operating system was written in an extension of extended ALGOL called ESPOL (Executive Systems Programming Oriented Language). This was replaced in the mid-to-late 70s by a language called NEWP. Though NEWP probably just meant "New Programming language", legends surround the name. A common (perhaps apocryphal) story around Burroughs at the time suggested it came from “<i>No Executive Washroom Privileges</i>.” Another story is that circa 1976, John McClintock of Burroughs (the software engineer developing NEWP) named the language "NEWP" after being asked, yet again, "does it have a name yet": answering "nyoooop", he adopted that as a name. NEWP, too, was a subset ALGOL extension, but it was more secure than ESPOL, and dropped some little-used complexities of ALGOL. In fact, all unsafe constructs are rejected by the NEWP compiler unless a block is specifically marked to allow those instructions. Such marking of blocks provide a multi-level protection mechanism.</p>
<p>NEWP programs that contain unsafe constructs are initially non-executable. The security administrator of a system is able to "bless" such programs and make them executable, but normal users are not able to do this. (Even "privileged users", who normally have essentially root privilege, may be unable to do this depending on the configuration chosen by the site.) While NEWP can be used to write general programs and has a number of features designed for large software projects, it does not support everything ALGOL does.</p>
<p>NEWP has a number of facilities to enable large-scale software projects, such as the operating system, including named interfaces (functions and data), groups of interfaces, modules, and super-modules. Modules group data and functions together, allowing easy access to the data as global within the module. Interfaces allow a module to import and export functions and data. Super-modules allow modules to be grouped.</p>
<p><a name="DCALGOL_and_Message_Control_Systems_.28MCS.29" id="DCALGOL_and_Message_Control_Systems_.28MCS.29"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=8" title="Edit section: DCALGOL and Message Control Systems (MCS)">edit</a>]</span> <span class="mw-headline">DCALGOL and Message Control Systems (MCS)</span></h3>
<p>The second intermediate level of security between operating system code (in NEWP) and user programs (in ALGOL) is for middleware programs, which are written in DCALGOL (data comms ALGOL). This is used for message reception and dispatching which remove messages from input queues and places them on queues for other processes in the system to handle. Middleware such as COMS (introduced around 1984) receive messages from around the network and dispatch these messages to specific handling processes or to an MCS (Message Control System) such as CANDE ("<b>C</b>ommand <b>AND E</b>dit," the program development environment).</p>
<p>MCSs are items of software worth noting – they control user sessions and provide keeping track of user state without having to run per-user processes since a single MCS stack can be shared by many users. Load balancing can also be achieved at the MCS level. For example saying that you want to handle 30 users per stack, in which case if you have 31 to 60 users, you have two stacks, 61 to 90 users, three stacks, etc. This gives B5000 machines a great performance advantage in a server since you don't need to start up another user process and thus create a new stack each time a user attaches to the system. Thus you can efficiently service users (whether they require state or not) with MCSs. MCSs also provide the backbone of large-scale transaction processing.</p>
<p>The MCS talked with an external co-processor, the TCP (Terminal Control Processor). This was a 24-bit minicomputer with a conventional register architecture and hardware I/O capability to handle thousands of remote terminals. The TCP and the B6500 communicated by messages in memory, essentially packets in today's terms, and the MCS did the B6500-side processing of those messages. The TCP did have an assembler, but that assembler was the B6500 ALGOL compiler. There was one ALGOL function for each kind of TCP instruction, and if you called that function then the corresponding TCP instruction bits would be emitted to the output. A TCP program was an ALGOL program comprising nothing but a long list of calls on these functions, one for each assembly language statement. Essentially ALGOL acted like the macro pass of a macro assembler. The first pass was the ALGOL compiler; the second pass was running the resulting program (on the B6500) which would then emit the binary for the TCP.</p>
<p><a name="DMALGOL_and_databases" id="DMALGOL_and_databases"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=9" title="Edit section: DMALGOL and databases">edit</a>]</span> <span class="mw-headline">DMALGOL and databases</span></h3>
<p>Another variant of ALGOL is DMALGOL (Data Management ALGOL). DMALGOL is ALGOL extended for compiling the DMSII database software from database description files created by the DASDL compiler. Database designers and administrators compile database descriptions to generate DMALGOL code tailored for the tables and indexes specified. Administrators never need to write DMALGOL themselves. Normal user-level programs obtain database access by using code written in application languages, mainly ALGOL and COBOL, extended with database instructions and transaction processing directives. The most notable feature of DMALGOL is its preprocessing mechanisms to generate code for handling tables and indices.</p>
<p>DMALGOL preprocessing includes variables and loops, and can generate names based on compile-time variables. This enables tailoring far beyond what can be done by preprocessing facilities which lack loops.</p>
<p>DMALGOL is used to provide tailored access routines for <a href="/wiki/Unisys_DMSII" title="Unisys DMSII">DMSII</a> databases. After a database is defined using the Data Access and Structure Definition Language (DASDL), the schema is translated by the preprocessor into tailored DMALGOL access routines and then compiled. This means that, unlike in other DBMS implementations, there is often no need for database-specific if/then/else code at run-time. In the 1970s, this "tailoring" was used very extensively to reduce the code footprint and execution time. It became much less used in later years, partly because low-level fine tuning for memory and speed became less critical, and partly because eliminating the preprocessing made coding simpler and thus enabled more important optimizations.</p>
<p>Roy Guck of Burroughs was one of the main developers of <a href="/wiki/Unisys_DMSII" title="Unisys DMSII">DMSII</a>.</p>
<p>In later years, with compiler code size being less of a concern, most of the preprocessing constructs were made available in the user level of ALGOL. Only the unsafe constructs and the direct processing of the database description file remain restricted to DMALGOL.</p>
<p><a name="Stack_architecture" id="Stack_architecture"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=10" title="Edit section: Stack architecture">edit</a>]</span> <span class="mw-headline">Stack architecture</span></h2>
<p>In many early systems and languages, programmers were often told not to make their routines too small – because procedure calls and returns were expensive operations, a number of operations had to be performed to maintain the stack. The B5000 was designed as a stack machine – all program data except for arrays (which include strings and objects) was kept on the stack. This meant that stack operations were optimized for efficiency. As a stack-oriented machine, there are no programmer addressable registers.</p>
<p><a href="/wiki/Computer_multitasking" title="Computer multitasking">Multitasking</a> is also very efficient on B5000 machines. There is one specific instruction to perform process switches – MVST (move stack)<sup id="cite_ref-5" class="reference"><a href="#cite_note-5" title=""><span>[</span>6<span>]</span></a></sup>. Each stack represents a process (task or thread) and tasks can become blocked waiting on resource requests (which includes waiting for a processor to run on if the task has been interrupted because of preemptive multitasking). User programs cannot issue an MVST, and there is only one line of code in the operating system where this is done.</p>
<p>So a process switch proceeds something like this – a process requests a resource that is not immediately available, maybe a read of a record of a file from a block which is not currently in memory, or the system timer has triggered an interrupt. The operating system code is entered and run on top of the user stack. It turns off user process timers. The current process is placed in the appropriate queue for the resource being requested, or the ready queue waiting for the processor if this is a preemptive context switch. The operating system determines the first process in the ready queue and invokes the instruction move_stack, which makes the process at the head of the ready queue active.</p>
<p><a name="Stack_speed_and_performance" id="Stack_speed_and_performance"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=11" title="Edit section: Stack speed and performance">edit</a>]</span> <span class="mw-headline">Stack speed and performance</span></h3>
<p>Some of the detractors of the B5000 architecture believed that stack architecture was inherently slow compared to register-based architectures. The trick to system speed is to keep data as close to the processor as possible. In the B5000 stack, this was done by assigning the top two positions of the stack to two registers A and B. Most operations are performed on those two top of stack positions. On faster machines past the B5000, more of the stack may be kept in registers or cache near the processor.</p>
<p>Thus the designers of the current B5000 systems can optimize in whatever is the latest technique, and programmers do not have to adjust their code for it to run faster – they do not even need to recompile, thus protecting software investment. Some programs have been known to run for years over many processor upgrades. Such speed up is limited on register-based machines.</p>
<p>Another point for speed as promoted by the RISC designers was that processor speed is considerably faster if everything is on a single chip. It was a valid point in the 1970s when more complex architectures such as the B5000 required too many transistors to fit on a single chip. However, this is not the case today and every B5000 successor machine now fits on a single chip as well as the performance support techniques such as caches and instruction pipelines.</p>
<p>In fact, the A Series line of B5000 successors included the first single chip mainframe, the Micro-A of the late 1980s. This "mainframe" chip (named SCAMP for Single-Chip A-series Mainframe Processor) sat on an Intel-based plug-in PC board.</p>
<p><a name="How_programs_map_to_the_stack_architecture" id="How_programs_map_to_the_stack_architecture"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=12" title="Edit section: How programs map to the stack architecture">edit</a>]</span> <span class="mw-headline">How programs map to the stack architecture</span></h3>
<p>Here is an example of how programs map to the stack architecture</p>
<pre>
<b>begin</b><br />   — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —
   — This is lexical level 2 (level zero is reserved for the operating system and level 1 for code segments).
   — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —

   — At level 2 we place global variables for our program.

   <b>integer</b> <i>i</i>, <i>j</i>, <i>k</i>
   <b>real</b> <i>f</i>, <i>g</i>
   <b>array</b> <i>a</i> [0:9]

   <b>procedure</b> <i>p</i> (<b>real</b> <i>p1</i>, <i>p2</i>)
      <b>value</b> <i>p1</i>     — p1 passed by value, p2 implicitly passed by reference.
      <b>begin</b>
         — — — — — — — — — — — — — — — — — —
         — This block is at lexical level 3
         — — — — — — — — — — — — — — — — — —
         <b>real</b> <i>r1</i>, <i>r2</i><br />         <i>r2</i> := <i>p1</i> * <i>5</i>
         <i>p2</i> := <i>r2</i>  — This sets 'g' to the value of r2
         <i>p1</i> := <i>r2</i>  — This set 'p2' to r2, but not 'f'
         — Since this overwrites the original value of f in p1 it most likely indicates
         — an error. Few of ALGOL's successors have corrected this situation by
         — making value parameters read only – most have not.

         <b>if</b> <i>r2</i> &gt; <i>10</i> <b>then</b>
            <b>begin</b>
               — — — — — — — — — — — — — — — — — — — — — — — — — — — —
               — A variable declared here makes this lexical level 4
               — — — — — — — — — — — — — — — — — — — — — — — — — — — —
               <b>integer</b> <i>n</i><br />               — The declaration of a variable makes this a block, which will invoke some
               — stack building code. Normally you won't declare variables here, in which
               — case this would be a compound statement, not a block.

               ... &lt;== sample stack is executing somewhere here.
            <b>end</b>
      <b>end</b>

   .....

   <i>p</i> (<i>f</i>, <i>g</i>)
<b>end</b>
</pre>
<p>Each stack frame corresponds to a lexical level in the current execution environment. As you can see, lexical level is the static textual nesting of a program, not the dynamic call nesting. The visibility rules of ALGOL, a language designed for single pass compilers, mean that only variables declared before the current position are visible at that part of the code except for forward declarations. All variables declared in enclosing blocks are visible. Another case is that variables of the same name may be declared in inner blocks and these effectively hide the outer variables which become inaccessible.</p>
<p>Since lexical nesting is static, it is very rare to find a program nested more than five levels deep, and it could be argued that such programs would be poorly structured. B5000 machines allow nesting of up to 32 levels. Procedures can be invoked in four ways – normal, call, process, and run.</p>
<p><a name="Procedures" id="Procedures"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=13" title="Edit section: Procedures">edit</a>]</span> <span class="mw-headline">Procedures</span></h3>
<p>The normal invocation invokes a procedure in the normal way any language invokes a routine, by suspending the calling routine until the invoked procedure returns.</p>
<p>The call mechanism invokes a procedure as a coroutine. Coroutines have partner tasks, where control is explicitly passed between the tasks by means of a CONTINUE instruction. These are synchronous processes.</p>
<p>The process mechanism invokes a procedure as an asynchronous task and in this case a separate stack is set up starting at the lexical level of the processed procedure. As an asynchronous task, there is no control over exactly when control will be passed between the tasks, unlike coroutines. Note also that the processed procedure still has access to the enclosing environment and this is a very efficient IPC (Inter Process Communication) mechanism. Since two or more tasks now have access to common variables, the tasks must be synchronized to prevent race conditions, which is handled by the EVENT data type, where processes can WAIT on an event until they are caused by another cooperating process. EVENTs also allow for mutual exclusion synchronization through the PROCURE and LIBERATE functions. If for any reason the child task dies, the calling task can continue – however, if the parent process dies, then all child processes are automatically terminated. On a machine with more than one processor, the processes may run simultaneously. This EVENT mechanism is a basic enabler for multiprocessing in addition to multitasking.</p>
<p><a name="Run_invocation_type" id="Run_invocation_type"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=14" title="Edit section: Run invocation type">edit</a>]</span> <span class="mw-headline">Run invocation type</span></h4>
<p>The last invocation type is run. This runs a procedure as an independent task which can continue on after the originating process terminates. For this reason, the child process cannot access variables in the parent's environment, and all parameters passed to the invoked procedure must be call-by-value.</p>
<p>Thus Burroughs Extended ALGOL had all of the multi-processing and synchronization features of later languages like Ada, with the added benefit that support for asynchronous processes was built into the hardware level.</p>
<p><a name="Inline_procedures" id="Inline_procedures"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=15" title="Edit section: Inline procedures">edit</a>]</span> <span class="mw-headline">Inline procedures</span></h4>
<p>One last possibility is that a procedure may be declared INLINE, that is when the compiler sees a reference to it the code for the procedure is generated inline to save the overhead of a procedure call. This is best done for small pieces of code and is like a define, except you don't get the problems with parameters that you can with defines. This facility is available in NEWP.</p>
<p><a name="Asynchronous_calls" id="Asynchronous_calls"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=16" title="Edit section: Asynchronous calls">edit</a>]</span> <span class="mw-headline">Asynchronous calls</span></h4>
<p>In the example program only normal calls are used, so all the information will be on a single stack. For asynchronous calls, the stack would be split into multiple stacks so that the processes share data but run asynchronously.</p>
<p><a name="Display_registers" id="Display_registers"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=17" title="Edit section: Display registers">edit</a>]</span> <span class="mw-headline">Display registers</span></h4>
<p>A stack hardware optimization is the provision of D (or "display") registers. These are registers that point to the start of each called stack frame. These registers are updated automatically as procedures are entered and exited and are not accessible by any software. There are 32 D registers, which is what limits to 32 levels of lexical nesting.</p>
<p>Consider how we would access a lexical level 2 (D[2]) global variable from lexical level 5 (D[5]). Suppose the variable is 6 words away from the base of lexical level 2. It is thus represented by the address couple (2, 6). If we don't have D registers, we have to look at the control word at the base of the D[5] frame, which points to the frame containing the D[4] environment. We then look at the control word at the base of this environment to find the D[3] environment, and continue in this fashion until we have followed all the links back to the required lexical level. Note this is not the same path as the return path back through the procedures which have been called in order to get to this point. (The architecture keeps both the data stack and the call stack in the same structure, but uses control words to tell them apart.)</p>
<p>As you can see, this is quite inefficient just to access a variable. With D registers, the D[2] register points at the base of the lexical level 2 environment, and all we need to do to generate the address of the variable is to add its offset from the stack frame base to the frame base address in the D register. (There is an efficient linked list search operator LLLU, which could search the stack in the above fashion, but the D register approach is still going to be faster.) With D registers, access to entities in outer and global environments is just as efficient as local variable access.</p>
<pre>
D Tag Data                — Comments
register

| 0        | <i>n</i>          | — The integer 'n' address couple (4, 1)
|-----------------------|
| D[4]==&gt;3 | <b>MSCW</b>       | — The Mark Stack Control Word containing the link to D[3].
|=======================|
| 0        | <i>r2</i>         | — The real 'r2' address couple (3, 5)
|-----------------------|
| 0        | <i>r1</i>         | — The real 'r1' address couple (3, 4)
|-----------------------|
| 1        | <i>p2</i>         | — An SIRW reference to 'g' at (2,6)
|-----------------------|
| 0        | <i>p1</i>         | — The parameter 'p1' from value of 'f' address couple (3, 2)
|-----------------------|
| 3        | <b>RCW</b>        | — A return control word
|-----------------------|
| D[3]==&gt;3 | <b>MSCW</b>       | — The Mark Stack Control Word containing the link to D[2].
|=======================| — The array 'a' address couple (2, 7)
| 1        | <i>a</i>          | ====================&gt;[ten word memory block]
|-----------------------|
| 0        | <i>g</i>          | — The real 'g' address couple (2, 6)
|-----------------------|
| 0        | <i>f</i>          | — The real 'f' address couple (2, 5)
|-----------------------|
| 0        | <i>k</i>          | — The integer 'k' address couple (2, 4)
|-----------------------|
| 0        | <i>j</i>          | — The integer 'j' address couple (2, 3)
|-----------------------|
| 0        | <i>i</i>          | — The integer 'i' address couple (2, 2)
|-----------------------|
| 3        | <b>RCW</b>        | — A return control word
|-----------------------|
| D[2]==&gt;3 | <b>MSCW</b>       | — The Mark Stack Control Word containing the link to the previous stack frame.
|=======================| — Stack bottom
</pre>
<p>If we had invoked the procedure p as a coroutine, or a process instruction, the D[3] environment would have become a separate D[3]-based stack. Note that this means that asynchronous processes still have access to the D[2] environment as implied in ALGOL program code. Taking this one step further, a totally different program could call another program’s code, creating a D[3] stack frame pointing to another process’ D[2] environment on top of its own process stack. At an instant the whole address space from the code’s execution environment changes, making the D[2] environment on the own process stack not directly addressable and instead make the D[2] environment in another process stack directly addressable. This is how library calls are implemented. At such a cross-stack call, the calling code and called code could even originate from programs written in different source languages and be compiled by different compilers.</p>
<p>Note that the D[1] and D[0] environments do not occur in the current process's stack. The D[1] environment is the code segment dictionary, which is shared by all processes running the same code. The D[0] environment represents entities exported by the operating system.</p>
<p>Stack frames actually don’t even have to exist in a process stack. This feature was used early on for file IO optimization, the FIB (file information block) was linked into the display registers at D[1] during IO operations. In the early nineties, this ability was implemented as a language feature as STRUCTURE BLOCKs and – combined with library technology - as CONNECTION BLOCKs. The ability to link a data structure into the display register address scope implemented object orientation. Thus, the B5000 actually used a form of object orientation long before the term was ever used.</p>
<p><a name="Stack_structure_advantages" id="Stack_structure_advantages"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=18" title="Edit section: Stack structure advantages">edit</a>]</span> <span class="mw-headline">Stack structure advantages</span></h3>
<p>One nice thing about the stack structure is that if a program does happen to fail, a stack dump is taken and it is very easy for a programmer to find out exactly what the state of a running program was. Compare that to core dumps and exchange packages of other systems.</p>
<p>Another thing about the stack structure is that programs are implicitly recursive. FORTRAN was not a recursive language and perhaps one stumbling block to people's understanding of how ALGOL was to be implemented was how to implement recursion. On the B5000, this was not a problem – in fact, they had the reverse problem, how to stop programs from being recursive. In the end they didn't bother, even the Burroughs FORTRAN compiler was recursive, since it was unproductive to stop it being so.</p>
<p>Thus Burroughs FORTRAN was better than any other implementation of FORTRAN.<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since February 2007" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup> In fact, Burroughs became known for its superior compilers and implementation of languages, including the object-oriented <a href="/wiki/Simula" title="Simula">Simula</a> (a superset of ALGOL), and <a href="/wiki/Kenneth_E._Iverson" title="Kenneth E. Iverson">Iverson</a>, the designer of <a href="/wiki/APL_(programming_language)" title="APL (programming language)">APL</a> declared that the Burroughs implementation of APL was the best he'd seen.<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since February 2007" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup> <a href="/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy</a>, the language designer of <a href="/wiki/LISP" title="LISP" class="mw-redirect">LISP</a> disagreed, since LISP was based on modifiable code<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since February 2007" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup>, he did not like the unmodifiable code of the B5000<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since February 2007" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup>, but most LISP implementations would run in an interpretive environment anyway.</p>
<p>Note also that stacks automatically used as much memory as was needed by a process. There was no having to do SYSGENs on Burroughs systems as with competing systems in order to preconfigure memory partitions in which to run tasks. In fact, Burroughs really championed "plug and play" in that extra peripherals could be plugged into the system without having to recompile the operating system with new peripheral tables. Thus these machines could be seen as the forerunners of today's USB and FireWire devices.</p>
<p><a name="Tagged_architecture" id="Tagged_architecture"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=19" title="Edit section: Tagged architecture">edit</a>]</span> <span class="mw-headline">Tagged architecture</span></h2>
<p>In most people's minds, the most defining aspect of the B5000 is that it is a stack machine as treated above. However, two other very important features of the architecture is that it is <a href="/wiki/Tagged_architecture" title="Tagged architecture">tag-based</a> and descriptor-based.</p>
<p>In the original B5000, a bit in each word was set aside to identify the word as a code or data word. This was a security mechanism to stop programs from being able to corrupt code, in the way that <a href="/wiki/Hacker_(computer_security)" title="Hacker (computer security)">crackers</a> do today.</p>
<p>An advantage to unmodifiable code is that B5000 code is fully reentrant: it does not matter how many users are running a program, there will only be one copy of the code in memory, thus saving substantial memory; these machines are actually very memory and disk efficient.</p>
<p>Later, when the B6500 was designed, it was realized that the 1-bit code/data distinction was a powerful idea and this was extended to three bits outside of the 48 bit word into a tag. The data bits are bits 0-47 and the tag is in bits 48-50. Bit 48 was the read-only bit, thus odd tags indicated control words that could not be written by a user-level program. Code words were given tag 3. Here is a list of the tags and their function:</p>
<table cellpadding="0">
<tr>
<th width="6%">Tag</th>
<th width="10%">Word kind</th>
<th width="50%">Description</th>
</tr>
<tr>
<td>0</td>
<td>Data</td>
<td>All kinds of user and system data (text data and single precision numbers)</td>
</tr>
<tr>
<td>2</td>
<td>Double</td>
<td>Double Precision data</td>
</tr>
<tr>
<td>4</td>
<td>SIW</td>
<td>Step Index word (used in loops)</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>Uninitialized data</td>
</tr>
<tr>
<td></td>
<td>SCW</td>
<td>Software Control Word (used to cut back the stack)</td>
</tr>
<tr>
<td>1</td>
<td>IRW</td>
<td>Indirect Reference Word</td>
</tr>
<tr>
<td></td>
<td>SIRW</td>
<td>Stuffed Indirect Reference Word</td>
</tr>
<tr>
<td>3</td>
<td>Code</td>
<td>Program code word</td>
</tr>
<tr>
<td></td>
<td>MSCW</td>
<td>Mark Stack Control Word</td>
</tr>
<tr>
<td></td>
<td>RCW</td>
<td>Return Control Word</td>
</tr>
<tr>
<td></td>
<td>TOSCW</td>
<td>Top of Stack Control Word</td>
</tr>
<tr>
<td></td>
<td>SD</td>
<td>Segment Descriptor</td>
</tr>
<tr>
<td>5</td>
<td>Descriptor</td>
<td>Data block descriptors</td>
</tr>
<tr>
<td>7</td>
<td>PCW</td>
<td>Program Control Word</td>
</tr>
</table>
<p>Note: Internally, some of the machines had 60 bit words, with the extra bits being used for engineering purposes such as a <a href="/wiki/Hamming_code" title="Hamming code">Hamming code</a> error-correction field, but these were never seen by programmers.</p>
<p>Note: The current incarnation of these machines, the Unisys ClearPath has extended tags further into a four bit tag. The microcode level that specified four bit tags was referred to as level Gamma.</p>
<p>Even-tagged words are user data which can be modified by a user program as user state. Odd-tagged words are created and used directly by the hardware and represent a program's execution state. Since these words are created and consumed by specific instructions or the hardware, the exact format of these words can change between hardware implementation and user programs do not need to be recompiled, since the same code stream will produce the same results, even though system word format may have changed.</p>
<p>Tag 1 words represent on-stack data addresses. The normal IRW simply stores an address couple to data on the current stack. The SIRW references data on any stack by including a stack number in the address.</p>
<p>Tag 5 words are descriptors, which are more fully described in the next section. Tag 5 words represent off-stack data addresses.</p>
<p>Tag 7 is the program control word which describes a procedure entry point. When operators hit a PCW, the procedure is entered. The ENTR operator explicitly enters a procedure (non-value-returning routine). Functions (value-returning routines) are implicitly entered by operators such as value call (VALC). Note that global routines are stored in the D[2] environment as SIRWs that point to a PCW stored in the code segment dictionary in the D[1] environment. The D[1] environment is not stored on the current stack because it can be referenced by all processes sharing this code. Thus code is reentrant and shared.</p>
<p>Tag 3 represents code words themselves, which won't occur on the stack. Tag 3 is also used for the stack control words MSCW, RCW, TOSCW.</p>
<div class="thumb tleft">
<div class="thumbinner" style="width:422px;"><a href="/wiki/File:B6700Word.jpg" class="image" title="Figure 9.2 From the ACM Monograph in the References. Elliot Organick 1973."><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/6/65/B6700Word.jpg/420px-B6700Word.jpg" width="420" height="324" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:B6700Word.jpg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Figure 9.2 From the ACM Monograph in the References. <i><a href="/wiki/Elliot_Organick" title="Elliot Organick">Elliot Organick</a> 1973.</i></div>
</div>
</div>
<p><a name="Descriptor-based_architecture" id="Descriptor-based_architecture"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=20" title="Edit section: Descriptor-based architecture">edit</a>]</span> <span class="mw-headline">Descriptor-based architecture</span></h2>
<p>The figure to the left shows how the Burroughs Large System architecture was fundamentally a hardware architecture for <a href="/wiki/Object-oriented_programming" title="Object-oriented programming">Object-oriented programming</a>, something that still doesn't exist in conventional architectures.</p>
<div class="rellink noprint relarticle mainarticle">Main article: <a href="/wiki/Burroughs_large_systems_descriptors" title="Burroughs large systems descriptors">Burroughs large systems descriptors</a></div>
<p><a name="Instruction_set" id="Instruction_set"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=21" title="Edit section: Instruction set">edit</a>]</span> <span class="mw-headline">Instruction set</span></h2>
<div class="rellink noprint relarticle mainarticle">Main article: <a href="/wiki/Burroughs_large_systems_instruction_set" title="Burroughs large systems instruction set">Burroughs large systems instruction set</a></div>
<p><a name="Multiple_processors" id="Multiple_processors"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=22" title="Edit section: Multiple processors">edit</a>]</span> <span class="mw-headline">Multiple processors</span></h2>
<p>The B5000 line also were pioneers in having multiple processors connected together on a high-speed bus. The B7000 line could have up to 8 processors, as long as at least one was an IO module. Note that RDLK is a very low-level way of synchronizing between processors. The high level used by user programs is the EVENT data type. The EVENT data type did have some system overhead. To avoid this overhead, a special locking technique called Dahm locks (named after a Burroughs software guru, Dave Dahm) can be used.</p>
<p>Notable operators are:</p>
<p><b>HEYU</b> — send an interrupt to another processor<br />
<b>RDLK</b> — Low-level semaphore operator: Load the A register with the memory location given by the A register and place the value in the B register at that memory location in a single uninterruptible cycle<br />
<b>WHOI</b> — Processor identification<br />
<b>IDLE</b> — Idle until an interrupt is received</p>
<p><a name="Influence_of_the_B5000" id="Influence_of_the_B5000"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=23" title="Edit section: Influence of the B5000">edit</a>]</span> <span class="mw-headline">Influence of the B5000</span></h2>
<p>Undoubtedly, the direct influence of the B5000 is the current Unisys ClearPath range of mainframes which are the direct descendants of the B5000 and still have the MCP operating system after 40 years of consistent development. This architecture is now called emode (for emulation mode) since the B5000 architecture can be implemented on many platforms. There was also going to be an nmode (<a href="/wiki/Native_mode" title="Native mode">native mode</a>), but this was dropped<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since September 2007" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup>, so you may often hear the B5000 successor machines being referred to as "emode machines".</p>
<p>B5000 machines were programmed exclusively in high-level languages, there is no assembler, obviously this would not apply to emode which is intended to run on stock hardware and thus breaks the fundamental basis of the architecture noted above except as noted below.</p>
<p>The B5000 stack architecture inspired <a href="/wiki/Chuck_Moore" title="Chuck Moore" class="mw-redirect">Chuck Moore</a>, the designer of the programming language <a href="/wiki/Forth_(programming_language)" title="Forth (programming language)">Forth</a>, who encountered the B5500 while at MIT. In <a href="http://www.colorforth.com/HOPL.html" class="external text" title="http://www.colorforth.com/HOPL.html" rel="nofollow"><i>Forth - The Early Years</i></a>, Moore described the influence, noting that Forth's DUP, DROP and SWAP came from the corresponding B5500 instructions (DUPL, DLET, EXCH).</p>
<p><a href="/wiki/Hewlett-Packard" title="Hewlett-Packard">Hewlett-Packard</a> systems were influenced by the B5000, since some Burroughs engineers found later employment designing machines for HP and these also were stack machines. Bob Barton's work on <a href="/wiki/Reverse_Polish_notation" title="Reverse Polish notation">reverse Polish notation</a> (RPN) found its way into <a href="/wiki/HP_calculators" title="HP calculators">HP calculators</a> beginning with the 9100A, and notably the <a href="/wiki/HP-35" title="HP-35">HP-35</a> and subsequent calculators.</p>
<p>The NonStop systems designed by <a href="/wiki/Tandem_Computers" title="Tandem Computers">Tandem Computers</a> in the late 1970s and early 1980s were also stack machines, influenced by the B5000 indirectly through the HP connection, as several of the early Tandem engineers were formerly with HP. Around 1990, these systems migrated to a RISC architecture and now contain only odd vestiges of their stack architecture.</p>
<p>Bob Barton was also very influential on <a href="/wiki/Alan_Kay" title="Alan Kay">Alan Kay</a>. Kay was also impressed by the data-driven tagged architecture of the B5000 and this influenced his thinking in his developments in object-oriented programming and <a href="/wiki/Smalltalk" title="Smalltalk">Smalltalk</a>.</p>
<p>Another facet of the B5000 architecture was that it was a secure architecture that runs directly on hardware. This technique has descendants in the virtual machines of today in their attempts to provide secure environments. One notable such product is the Java JVM which provides a secure sandbox in which applications run.</p>
<p>The value of the hardware-architecture binding that existed before emode would be substantially preserved in <a href="/wiki/Intel_x86" title="Intel x86" class="mw-redirect">iAPXx86</a> to the extent that MCP was the one and only control program but the support provided by stock hardwares is still inferior to that of the native mode. A little-known Intel processor architecture that actually preceded iAPXx86 (<a href="/wiki/Intel_iAPX_432" title="Intel iAPX 432">Intel iAPX 432</a>) <i>would</i> have provided an equivalent physical basis, as it too was essentially an object oriented dataflow architecture.</p>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=24" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/CANDE" title="CANDE">CANDE</a></li>
<li><a href="/wiki/Work_Flow_Language" title="Work Flow Language">WFL</a></li>
</ul>
<p><a name="Notes" id="Notes"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=25" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline">Notes</span></h2>
<ol class="references">
<li id="cite_note-johnmashey-0"><b><a href="#cite_ref-johnmashey_0-0" title="">^</a></b> John Mashey (2006-08-15). "<i><a href="news:1155671202.964792.162180@b28g2000cwb.googlegroups.com" class="external text" title="news:1155671202.964792.162180@b28g2000cwb.googlegroups.com" rel="nofollow">Admired designs / designs to study</a></i>". <a href="news:comp.arch" class="external text" title="news:comp.arch" rel="nofollow">comp.arch</a>. <a href="http://groups.google.com/group/comp.arch/msg/8dcee778af867966" class="external text" title="http://groups.google.com/group/comp.arch/msg/8dcee778af867966" rel="nofollow">(Web link)</a>. Retrieved on <span class="mw-formatted-date" title="2007-12-15"><a href="/wiki/2007" title="2007">2007</a>-<a href="/wiki/December_15" title="December 15">12-15</a></span>.</li>
<li id="cite_note-1"><b><a href="#cite_ref-1" title="">^</a></b> <a href="http://www.cc.gatech.edu/gvu/people/randy.carpenter/folklore/v3n5.html" class="external text" title="http://www.cc.gatech.edu/gvu/people/randy.carpenter/folklore/v3n5.html" rel="nofollow">Burroughs 3rd Generation.</a></li>
<li id="cite_note-2"><b><a href="#cite_ref-2" title="">^</a></b> <a href="http://www.classiccmp.org/dunfield/other/h/uascpu.jpg" class="external text" title="http://www.classiccmp.org/dunfield/other/h/uascpu.jpg" rel="nofollow">SCAMP picture at dave's Old computers</a></li>
<li id="cite_note-3"><b><a href="#cite_ref-3" title="">^</a></b> <a href="http://www.highbeam.com/doc/1G1-50063166.html" class="external text" title="http://www.highbeam.com/doc/1G1-50063166.html" rel="nofollow">Unisys Accelerates Mainframe Rebirth with New ClearPath Enterprise Servers, Aggressive New Pricing. - Business Wire - HighBeam Research</a></li>
<li id="cite_note-4"><b><a href="#cite_ref-4" title="">^</a></b> <a href="http://www.unisys.com/products/mainframes/mcp__mainframes/earlier__mcp__models.htm" class="external text" title="http://www.unisys.com/products/mainframes/mcp__mainframes/earlier__mcp__models.htm" rel="nofollow">Libra 595</a></li>
<li id="cite_note-5"><b><a href="#cite_ref-5" title="">^</a></b> <cite style="font-style:normal" class="book" id="CITEREFOrganick1973"><a href="/wiki/Elliot_Organick" title="Elliot Organick">Organick, Elliot</a> (1973). <i>Computer System Organization</i>. <a href="/wiki/Association_for_Computing_Machinery" title="Association for Computing Machinery">ACM</a>. pp.&#160;115–117. <a href="/wiki/Special:BookSources/0125282508" class="internal">ISBN 0125282508</a>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Computer+System+Organization&amp;rft.aulast=Organick&amp;rft.aufirst=Elliot&amp;rft.au=Organick%2C+Elliot&amp;rft.date=1973&amp;rft.pages=pp.%26nbsp%3B115%E2%80%93117&amp;rft.pub=%5B%5BAssociation+for+Computing+Machinery%7CACM%5D%5D&amp;rft.isbn=0125282508&amp;rfr_id=info:sid/en.wikipedia.org:Burroughs_large_systems"><span style="display: none;">&#160;</span></span></li>
</ol>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=26" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<ul>
<li><i>The Extended ALGOL Primer</i> (Three Volumes), Donald J. Gregory.</li>
<li><i>Computer Architecture: A Structured Approach,</i> R. Doran, Academic Press (1979).</li>
<li><i>Stack Computers: The New Wave,</i> Philip J. Koopman, available at: <a href="http://www.ece.cmu.edu/~koopman/stack_computers/index.html" class="external autonumber" title="http://www.ece.cmu.edu/~koopman/stack_computers/index.html" rel="nofollow">[1]</a></li>
<li>B5500, B6500, B6700, B6800, B6900, B7700 manuals at: <a href="http://www.bitsavers.org/pdf/burroughs/" class="external text" title="http://www.bitsavers.org/pdf/burroughs/" rel="nofollow">bitsavers.org</a></li>
</ul>
<p><a name="Further_reading" id="Further_reading"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=27" title="Edit section: Further reading">edit</a>]</span> <span class="mw-headline">Further reading</span></h2>
<ul>
<li>Barton, Robert S. "A New Approach to the Functional Design of a Digital Computer" Proceedings of the Western Joint Computer Conference. ACM (1961).</li>
<li><a href="/wiki/Charles_Babbage_Institute" title="Charles Babbage Institute">Charles Babbage Institute</a>, <a href="http://www.cbi.umn.edu/oh/display.phtml?id=53" class="external text" title="http://www.cbi.umn.edu/oh/display.phtml?id=53" rel="nofollow">Burroughs B 5000 Conference</a>, University of Minnesota, Minneapolis. The Burroughs 5000 computer series is discussed by individuals responsible for its development and marketing from 1957 through the 1960s in a 1985 conference sponsored by AFIPS and Burroughs Corporation.</li>
<li>Gray, George. <a href="http://wiki.cc.gatech.edu/folklore/index.php/Main_Page" class="external text" title="http://wiki.cc.gatech.edu/folklore/index.php/Main_Page" rel="nofollow">"Some Burroughs Transistor Computers"</a>, Unisys History Newsletter, Volume 3, Number 1, March 1999.</li>
<li>Gray, George. <a href="http://wiki.cc.gatech.edu/folklore/index.php/Main_Page" class="external text" title="http://wiki.cc.gatech.edu/folklore/index.php/Main_Page" rel="nofollow">"Burroughs Third-Generation Computers</a>, Unisys History Newsletter, Volume 3, Number 5, October 1999.</li>
<li>Hauck, E.A., Dent, Ben A. "Burroughs B6500/B7500 Stack Mechanism", SJCC (1968) pp. 245-251.</li>
<li>McKeeman, William M. "Language Directed Computer Design", Fall Joint Computer Conference, (1967) pp.413-417.</li>
<li>Organick, Elliot I. "Computer System Organization The B5700/B6700 series", Academic Press (1973)</li>
<li>Waychoff, Richard, <a href="http://web.me.com/ianjoyner/Files/Waychoff.pdf" class="external text" title="http://web.me.com/ianjoyner/Files/Waychoff.pdf" rel="nofollow">"Stories of the B5000 and People Who Were There"</a>, September 27, 1979</li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit&amp;section=28" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://web.me.com/ianjoyner/Ian_Joyner/Burroughs.html" class="external text" title="http://web.me.com/ianjoyner/Ian_Joyner/Burroughs.html" rel="nofollow">Ian Joyner's page on the Burroughs B5000</a></li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 1209/1000000
Post-expand include size: 12534/2048000 bytes
Template argument size: 4069/2048000 bytes
Expensive parser function count: 5/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:332693-0!1!0!default!!en!2 and timestamp 20090422200139 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Burroughs_large_systems">http://en.wikipedia.org/wiki/Burroughs_large_systems</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Early_computers" title="Category:Early computers">Early computers</a></span> | <span dir='ltr'><a href="/wiki/Category:Mainframe_computers" title="Category:Mainframe computers">Mainframe computers</a></span></div><div id="mw-hidden-catlinks" class="mw-hidden-cats-hidden">Hidden categories:&#32;<span dir='ltr'><a href="/wiki/Category:Articles_to_be_expanded_since_June_2008" title="Category:Articles to be expanded since June 2008">Articles to be expanded since June 2008</a></span> | <span dir='ltr'><a href="/wiki/Category:All_articles_to_be_expanded" title="Category:All articles to be expanded">All articles to be expanded</a></span> | <span dir='ltr'><a href="/wiki/Category:All_articles_with_unsourced_statements" title="Category:All articles with unsourced statements">All articles with unsourced statements</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_unsourced_statements_since_February_2007" title="Category:Articles with unsourced statements since February 2007">Articles with unsourced statements since February 2007</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_unsourced_statements_since_September_2007" title="Category:Articles with unsourced statements since September 2007">Articles with unsourced statements since September 2007</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Burroughs_large_systems" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Burroughs_large_systems" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Burroughs_large_systems&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Burroughs_large_systems&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Burroughs_large_systems" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Burroughs_large_systems" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Burroughs_large_systems" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Burroughs_large_systems&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Burroughs_large_systems&amp;oldid=285508118" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Burroughs_large_systems&amp;id=285508118">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Grandes_sistemas_de_Burroughs">Español</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E3%83%90%E3%83%AD%E3%83%BC%E3%82%B9_B5000">日本語</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 22 April 2009, at 20:01 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv216 in 0.046 secs. --></body></html>
