<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Method of analytic tableaux,Atom (logic),Atomic formula,Classical logic,Clause (logic),Connective (logic),Contradiction,Cut-elimination theorem,De Morgan&#039;s laws,Decision procedure,First-order logic" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Method of analytic tableaux - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Method_of_analytic_tableaux";
		var wgTitle = "Method of analytic tableaux";
		var wgAction = "view";
		var wgArticleId = "1027229";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 271292587;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Method_of_analytic_tableaux skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Method of analytic tableaux</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<div class="thumb tright">
<div class="thumbinner" style="width:202px;"><a href="/wiki/File:Partially_built_tableau.svg" class="image" title="A graphical representation of a partially built propositional tableau"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/a/ad/Partially_built_tableau.svg/200px-Partially_built_tableau.svg.png" width="200" height="238" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Partially_built_tableau.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
A graphical representation of a partially built propositional tableau</div>
</div>
</div>
<p>In <a href="/wiki/Proof_theory" title="Proof theory">proof theory</a>, the <b>semantic tableau</b> is a <a href="/wiki/Decision_procedure" title="Decision procedure" class="mw-redirect">decision procedure</a> for <a href="/wiki/Sentential_logic" title="Sentential logic" class="mw-redirect">sentential</a> and related logics, and a <a href="/wiki/Proof_procedure" title="Proof procedure">proof procedure</a> for formulas of <a href="/wiki/First-order_logic" title="First-order logic">first-order logic</a>. The tableau method can also determine the <a href="/wiki/Satisfiability" title="Satisfiability" class="mw-redirect">satisfiability</a> of finite sets of <a href="/wiki/Formula" title="Formula">formulas</a> of various logics. It is the most popular <a href="/wiki/Proof_procedure" title="Proof procedure">proof procedure</a> for <a href="/wiki/Modal_logic" title="Modal logic">modal logics</a> (Girle 2000).</p>
<p>An <b>analytic tableau</b> has for each node a subformula of the formula at the origin. In other words, it is a tableau satisfying the subformula property.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1"><a href="#Propositional_logic"><span class="tocnumber">2</span> <span class="toctext">Propositional logic</span></a>
<ul>
<li class="toclevel-2"><a href="#And"><span class="tocnumber">2.1</span> <span class="toctext">And</span></a></li>
<li class="toclevel-2"><a href="#Or"><span class="tocnumber">2.2</span> <span class="toctext">Or</span></a></li>
<li class="toclevel-2"><a href="#Not"><span class="tocnumber">2.3</span> <span class="toctext">Not</span></a></li>
<li class="toclevel-2"><a href="#Closure"><span class="tocnumber">2.4</span> <span class="toctext">Closure</span></a></li>
<li class="toclevel-2"><a href="#Set-labeled_tableau"><span class="tocnumber">2.5</span> <span class="toctext">Set-labeled tableau</span></a></li>
<li class="toclevel-2"><a href="#Conditional"><span class="tocnumber">2.6</span> <span class="toctext">Conditional</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#First-order_logic_tableau"><span class="tocnumber">3</span> <span class="toctext">First-order logic tableau</span></a>
<ul>
<li class="toclevel-2"><a href="#First-order_tableau_without_unification"><span class="tocnumber">3.1</span> <span class="toctext">First-order tableau without unification</span></a></li>
<li class="toclevel-2"><a href="#First-order_tableau_with_unification"><span class="tocnumber">3.2</span> <span class="toctext">First-order tableau with unification</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Tableau_calculi_and_their_properties"><span class="tocnumber">4</span> <span class="toctext">Tableau calculi and their properties</span></a></li>
<li class="toclevel-1"><a href="#Proof_procedures"><span class="tocnumber">5</span> <span class="toctext">Proof procedures</span></a></li>
<li class="toclevel-1"><a href="#Searching_for_a_closed_tableau"><span class="tocnumber">6</span> <span class="toctext">Searching for a closed tableau</span></a>
<ul>
<li class="toclevel-2"><a href="#Reducing_search"><span class="tocnumber">6.1</span> <span class="toctext">Reducing search</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Clause_tableaux"><span class="tocnumber">7</span> <span class="toctext">Clause tableaux</span></a>
<ul>
<li class="toclevel-2"><a href="#Connection_tableau"><span class="tocnumber">7.1</span> <span class="toctext">Connection tableau</span></a></li>
<li class="toclevel-2"><a href="#Regular_tableaux"><span class="tocnumber">7.2</span> <span class="toctext">Regular tableaux</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Tableaux_for_modal_logics"><span class="tocnumber">8</span> <span class="toctext">Tableaux for modal logics</span></a>
<ul>
<li class="toclevel-2"><a href="#Formula-deleting_tableau"><span class="tocnumber">8.1</span> <span class="toctext">Formula-deleting tableau</span></a></li>
<li class="toclevel-2"><a href="#World-labeled_tableau"><span class="tocnumber">8.2</span> <span class="toctext">World-labeled tableau</span></a></li>
<li class="toclevel-2"><a href="#Set-labeling_tableaux"><span class="tocnumber">8.3</span> <span class="toctext">Set-labeling tableaux</span></a></li>
<li class="toclevel-2"><a href="#Auxiliary_tableaux"><span class="tocnumber">8.4</span> <span class="toctext">Auxiliary tableaux</span></a></li>
<li class="toclevel-2"><a href="#Global_assumptions"><span class="tocnumber">8.5</span> <span class="toctext">Global assumptions</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Notations"><span class="tocnumber">9</span> <span class="toctext">Notations</span></a>
<ul>
<li class="toclevel-2"><a href="#Uniform_notation"><span class="tocnumber">9.1</span> <span class="toctext">Uniform notation</span></a></li>
<li class="toclevel-2"><a href="#Signed_formulae"><span class="tocnumber">9.2</span> <span class="toctext">Signed formulae</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">10</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">11</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Introduction" id="Introduction"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a>]</span> <span class="mw-headline">Introduction</span></h2>
<p>For refutation tableaux, the objective is to show that the negation of a formula cannot be satisfied. There are rules for handling each of the usual <a href="/wiki/Logical_connective" title="Logical connective">connectives</a>, starting with the main connective. In many cases, applying these rules causes the subtableau to divide into two. <a href="/wiki/Quantifier" title="Quantifier" class="mw-redirect">Quantifiers</a> are instantiated. If any branch of a tableau leads to an evident <a href="/wiki/Contradiction" title="Contradiction">contradiction</a>, the branch <i>closes</i>. If all branches close, the proof is complete and the original formula is a logical truth.</p>
<p>Although the fundamental idea behind the <b>analytic tableau method</b> is derived from the <a href="/wiki/Cut-elimination_theorem" title="Cut-elimination theorem">cut-elimination theorem</a> of <a href="/wiki/Structural_proof_theory" title="Structural proof theory">structural proof theory</a>, the origins of tableau calculi lie in the meaning (or <a href="/wiki/Semantics" title="Semantics">semantics</a>) of the logical connectives, as the connection with <a href="/wiki/Proof_theory" title="Proof theory">proof theory</a> was made only in recent decades.</p>
<p>More specifically, a tableau calculus consists of a finite collection of rules with each rule specifying how to break down one logical connective into its constituent parts. The rules typically are expressed in terms of finite <a href="/wiki/Set_(mathematics)" title="Set (mathematics)">sets</a> of formulae, although there are logics for which we must use more complicated data structures, such as <a href="/wiki/Multiset" title="Multiset">multisets</a>, <a href="/wiki/List_(computing)" title="List (computing)">lists</a>, or even <a href="/wiki/Tree_(data_structure)" title="Tree (data structure)">trees</a> of formulas. Henceforth, "set" denotes any of {set, multiset, list, tree}.</p>
<p>If there is such a rule for every logical connective then the procedure will eventually produce a set which consists only of <a href="/wiki/Atomic_formula" title="Atomic formula">atomic formulae</a> and their negations, which cannot be broken down any further. Such a set is easily recognizable as satisfiable or unsatisfiable with respect to the semantics of the logic in question. To keep track of this process, the nodes of a tableau itself are set out in the form of a tree and the branches of this tree are created and assessed in a systematic way. Such a systematic method for searching this tree gives rise to an algorithm for performing deduction and automated reasoning. Note that this larger tree is present regardless of whether the nodes contain sets, multisets, lists or trees.</p>
<p><a name="Propositional_logic" id="Propositional_logic"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=2" title="Edit section: Propositional logic">edit</a>]</span> <span class="mw-headline">Propositional logic</span></h2>
<p>This section presents the tableau calculus for classical propositional logic. Tableau checks whether a given set of formulae is satisfiable or not. It can be used to check validity or entailment: a formula is valid if its negation is unsatisfiable and formulae <img class="tex" alt="A_1,\ldots,A_n" src="http://upload.wikimedia.org/math/7/d/7/7d740e0aebd91f51599843947d90fdee.png" /> imply <span class="texhtml"><i>B</i></span> if <img class="tex" alt="\{A_1,\ldots,A_n,\neg B\}" src="http://upload.wikimedia.org/math/2/9/5/29519cf04c56cdaabd9182365acb03e3.png" /> is unsatisfiable.</p>
<p>The main principle of propositional tableau is to attempt to "break" complex formulae into smaller ones until complementary pairs of literals are produced or no further expansion is possible.</p>
<div class="thumb tright">
<div class="thumbinner" style="width:102px;"><a href="/wiki/File:Prop-tableau-1.svg" class="image" title="Initial tableau for "><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/d/d1/Prop-tableau-1.svg/100px-Prop-tableau-1.svg.png" width="100" height="120" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Prop-tableau-1.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Initial tableau for <img class="tex" alt="\{(a \vee \neg b) \wedge b, \neg a\}" src="http://upload.wikimedia.org/math/c/8/d/c8d8f81a2dff7fe8dd7ccf7ba774c273.png" /></div>
</div>
</div>
<p>The method works on a tree whose nodes are labeled with formulae. At each step, this tree is modified; in the propositional case, the only allowed changes are additions of nodes as descendant of a leaf. The procedure starts by generating the tree made of a chain of all formulae in the set to prove unsatisfiability. A variant to this starting step is to begin with a single-node tree whose root is labeled by <img class="tex" alt="\top" src="http://upload.wikimedia.org/math/0/9/c/09c35e480ff978d5868d6e09f324f913.png" />; in this second case, the procedure can always copy a formula in the set below a leaf. As a running example, the tableau for the set <img class="tex" alt="\{(a \vee \neg b) \wedge b, \neg a\}" src="http://upload.wikimedia.org/math/c/8/d/c8d8f81a2dff7fe8dd7ccf7ba774c273.png" /> is shown.</p>
<p>The principle of tableau is that formulae in nodes of the same branch are considered in conjunction while the different branches are considered to be disjuncted. As a result, a tableau is a tree-like representation of a formula that is a disjunction of conjunctions. This formula is equivalent to the set to prove unsatisfiability. The procedure modifies the tableau in such a way that the formula represented by the resulting tableau is equivalent to the original one. One of these conjunctions may contain a pair of complementary literals, which proves that that conjunction is unsatisfiable. If all conjunctions are proved unsatisfiable, the original set of formulae is unsatisfiable.</p>
<p><a name="And" id="And"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=3" title="Edit section: And">edit</a>]</span> <span class="mw-headline">And</span></h3>
<div class="thumb tright">
<div class="thumbinner" style="width:102px;"><a href="/wiki/File:Prop-tableau-2.svg" class="image" title=" generates  and b"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/b/bc/Prop-tableau-2.svg/100px-Prop-tableau-2.svg.png" width="100" height="260" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Prop-tableau-2.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
<img class="tex" alt="(a \vee \neg b) \wedge b" src="http://upload.wikimedia.org/math/6/1/c/61c7de9c1f9060c1f035b35b14c0788e.png" /> generates <img class="tex" alt="a \vee \neg b" src="http://upload.wikimedia.org/math/4/b/4/4b41876ac926967017855ebcc763b4d0.png" /> and <span class="texhtml"><i>b</i></span></div>
</div>
</div>
<p>Whenever a branch of a tableau contains a formula <img class="tex" alt="A \wedge B" src="http://upload.wikimedia.org/math/2/c/1/2c1e6cb923ab7b5d63ce41ed77fe8c36.png" /> that is the conjunction of two formulae, these two formulae are both consequences of that formula. This fact can be formalized by the following rule for expansion of a tableau:</p>
<blockquote>
<p>(<img class="tex" alt="\wedge" src="http://upload.wikimedia.org/math/1/b/a/1ba4f06f68614e5da79a8ebd378d532a.png" />) If a branch of the tableau contains a conjunctive formula <img class="tex" alt="A \wedge B" src="http://upload.wikimedia.org/math/2/c/1/2c1e6cb923ab7b5d63ce41ed77fe8c36.png" />, add to its leaf the chain of two nodes containing the formulae <span class="texhtml"><i>A</i></span> and <span class="texhtml"><i>B</i></span></p>
</blockquote>
<p>This rule is generally written as follows:</p>
<dl>
<dd><img class="tex" alt="(\and) \frac{A \wedge B}{\begin{array}{c} A \\ B\end{array}}" src="http://upload.wikimedia.org/math/1/2/e/12e0a0ab9cef96068d89784bd784329f.png" /></dd>
</dl>
<p>A variant of this rule allows a node to contain a set of formulae rather than a single one. In this case, the formulae in this set are considered in conjunction, so one can add <span class="texhtml">{<i>A</i>,<i>B</i>}</span> at the end of a branch containing <img class="tex" alt="A \wedge B" src="http://upload.wikimedia.org/math/2/c/1/2c1e6cb923ab7b5d63ce41ed77fe8c36.png" />. More precisely, if a node on a branch is labeled <img class="tex" alt="X \cup \{A \wedge B\}" src="http://upload.wikimedia.org/math/1/c/a/1cabdc55d2120e2b98dca5673acf80eb.png" />, one can add to the branch the new leaf <img class="tex" alt="X \cup \{A, B\}" src="http://upload.wikimedia.org/math/0/6/6/066327743754bbbda90b3aa5fb4633bd.png" />.</p>
<p><a name="Or" id="Or"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=4" title="Edit section: Or">edit</a>]</span> <span class="mw-headline">Or</span></h3>
<div class="thumb tright">
<div class="thumbinner" style="width:182px;"><a href="/wiki/File:Prop-tableau-3.svg" class="image" title=" generates a and "><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/c/c0/Prop-tableau-3.svg/180px-Prop-tableau-3.svg.png" width="180" height="330" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Prop-tableau-3.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
<img class="tex" alt="a \vee \neg b" src="http://upload.wikimedia.org/math/4/b/4/4b41876ac926967017855ebcc763b4d0.png" /> generates <span class="texhtml"><i>a</i></span> and <img class="tex" alt="\neg b" src="http://upload.wikimedia.org/math/7/3/4/734d0a1fe0500adc8614e6b99b04b49a.png" /></div>
</div>
</div>
<p>If a branch of a tableau contains a formula that is a disjunction of two formulae, such as <img class="tex" alt="A \vee B" src="http://upload.wikimedia.org/math/f/5/f/f5f0e7687cefaa33ff9fa15cdcce9413.png" />, the following rule can be applied:</p>
<blockquote>
<p>(<img class="tex" alt="\vee" src="http://upload.wikimedia.org/math/7/2/7/727ea4c8c49862411edae46adf506e3e.png" />) If a node on a branch contains a disjunctive formula <img class="tex" alt="A \vee B" src="http://upload.wikimedia.org/math/f/5/f/f5f0e7687cefaa33ff9fa15cdcce9413.png" />, then create two sibling children to the leaf of the branch, containing the formulae <span class="texhtml"><i>A</i></span> and <span class="texhtml"><i>B</i></span>, respectively.</p>
</blockquote>
<p>This rules splits a branch into two ones, differing only for the final node. Since branches are considered in disjunction to each other, the two resulting branches are equivalent to the original one, as the disjunction of their non-common nodes is precisely <img class="tex" alt="A \vee B" src="http://upload.wikimedia.org/math/f/5/f/f5f0e7687cefaa33ff9fa15cdcce9413.png" />. The rule for disjunction is generally formally written using the symbol <span class="texhtml">|</span> for separating the formulae of the two distinct nodes to be created:</p>
<dl>
<dd><img class="tex" alt="(\vee) \frac{A \vee B}{A|B}" src="http://upload.wikimedia.org/math/c/3/d/c3da66d5a14d277b4eb559a02051c76e.png" /></dd>
</dl>
<p>If nodes are assumed to contain sets of formulae, this rule is replaced by: if a node is labeled <img class="tex" alt="Y \cup \{A \vee B\}" src="http://upload.wikimedia.org/math/5/c/e/5ce7b16f8bf77bc62437651538ad8a48.png" />, a leaf of the branch this node is in can be appended two sibling child nodes labeled <img class="tex" alt="Y \cup \{A\}" src="http://upload.wikimedia.org/math/9/5/7/957d99fe604f87ab0ef88dae5c9b28ca.png" /> and <img class="tex" alt="Y \cup \{B\}" src="http://upload.wikimedia.org/math/3/2/2/322ec01f74ceda402f66e357fee3d0b9.png" />, respectively.</p>
<p><a name="Not" id="Not"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=5" title="Edit section: Not">edit</a>]</span> <span class="mw-headline">Not</span></h3>
<p>The aim of tableau is to generate progressively simpler formulae until pairs of opposite literals are produced or no other rule can be applied. Negation can be treated by initially making formulae in <a href="/wiki/Negation_normal_form" title="Negation normal form">negation normal form</a>, so that negation only occurs in front of literals. Alternatively, one can use <a href="/wiki/De_Morgan%27s_laws" title="De Morgan's laws">De Morgan's laws</a> during the expansion of the tableau, so that for example <img class="tex" alt="\neg (A \wedge B)" src="http://upload.wikimedia.org/math/5/1/8/518e740294a0b44d98ca742538e2cfec.png" /> is treated as <img class="tex" alt="\neg A \vee \neg B" src="http://upload.wikimedia.org/math/7/5/5/7550cde55e31e2d4e5f7ed778a53ac42.png" />. Rules that introduce or remove a pair of negations (such as in <img class="tex" alt="\neg \neg A" src="http://upload.wikimedia.org/math/6/8/6/68668de33662d7cc191bf942d6e83dad.png" />) are also used in this case (otherwise, there would be no way of expanding a formula like <img class="tex" alt="\neg \neg (A \wedge B)" src="http://upload.wikimedia.org/math/9/b/6/9b66e3620432dc5057cdd7be1308f945.png" />:</p>
<dl>
<dd><img class="tex" alt="(\neg 1) \frac{A}{\neg \neg A}" src="http://upload.wikimedia.org/math/0/c/2/0c23a3bace928358c5e694c6a9ef39e4.png" /></dd>
</dl>
<dl>
<dd><img class="tex" alt="(\neg 2) \frac{\neg \neg A}{A}" src="http://upload.wikimedia.org/math/b/b/4/bb4b4ccefb9207c1fe2ff0b02059729d.png" /></dd>
</dl>
<div class="thumb tright">
<div class="thumbinner" style="width:222px;"><a href="/wiki/File:Prop-tableau-4.svg" class="image" title="The tableau is closed"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/2/21/Prop-tableau-4.svg/220px-Prop-tableau-4.svg.png" width="220" height="259" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Prop-tableau-4.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
The tableau is closed</div>
</div>
</div>
<p><a name="Closure" id="Closure"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=6" title="Edit section: Closure">edit</a>]</span> <span class="mw-headline">Closure</span></h3>
<p>Every tableau can be considered as a graphical representation of a formula, which is equivalent to the set the tableau is built from. This formula is as follows: each branch of the tableau represents the conjunction of its formulae; the tableau represents the disjunction of its branches. The expansion rules transforms a tableau into one having an equivalent represented formula. Since the tableau is initialized as a single branch containing the formulae of the input set, all subsequent tableaux obtained from it represent formulae which are equivalent to that set (in the variant where the initial tableau is the single node labeled true, the formulae represented by tableaux are consequences of the original set.)</p>
<div class="thumb tright">
<div class="thumbinner" style="width:222px;"><a href="/wiki/File:Non-closed_propositional_tableau.svg" class="image" title="A tableau for the satisfiable set&#160;: all rules have been applied to every formula on every branch, but the tableau is not closed (only the left branch is closed), as expected for satisfiable sets"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/5/5a/Non-closed_propositional_tableau.svg/220px-Non-closed_propositional_tableau.svg.png" width="220" height="314" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Non-closed_propositional_tableau.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
A tableau for the satisfiable set <img class="tex" alt="\{a \wedge c, \neg a \vee b\}" src="http://upload.wikimedia.org/math/d/8/3/d836e63b2fc08d426e23a09577200366.png" />: all rules have been applied to every formula on every branch, but the tableau is not closed (only the left branch is closed), as expected for satisfiable sets</div>
</div>
</div>
<p>The method of tableaux works by starting with the initial set of formulae and then adding to the tableau simpler and simpler formulae, while still preserving equivalent to the original set, until contradiction is shown in the simple form of opposite literals. Since the formula represented by a tableau is the disjunction of the formulae represented by its branches, contradiction is obtained when every branch contains a pair of opposite literals.</p>
<p>Once a branch contains a literal and its negation, its corresponding formula is unsatisfiable. As a result, this branch can be now "closed", as there is no need to further expand it. If all branches of a tableau are closed, the formula represented by the tableau is unsatisfiable; therefore, the original set is unsatisfiable as well. Obtaining a tableau where all branches are closed is a way for proving the unsatisfiability of the original set. In the propositional case, one can also prove that satisfiability is proved by the impossibility of finding a closed tableau, provided that every expansion rule has been applied everywhere it could be applied. In particular, if a tableau contains some open (non-closed) branches and every formula that is not a literal has been used by a rule to generate a new node on every branch the formula is in, the set is satisfiable.</p>
<p>This rule takes into account that a formula may occur in more than one branch (this is the case if there is at least a branching point "below" the node). In this case, the rule for expanding the formula has to be applied so that its conclusion(s) are appended to all of these branches that are still open, before one can conclude that the tableau cannot be further expanded and that the formula is therefore satisfiable.</p>
<p><a name="Set-labeled_tableau" id="Set-labeled_tableau"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=7" title="Edit section: Set-labeled tableau">edit</a>]</span> <span class="mw-headline">Set-labeled tableau</span></h3>
<p>A variant of tableau is to label nodes with sets of formulae rather than single formulae. In this case, the initial tableau is a single node labeled with the set to be proved satisfiable. The formulae in a set are therefore considered to be in conjunction.</p>
<p>The rules of expansion of the tableau can now work on the leaves of the tableau, ignoring all internal nodes. For conjunction, the rule is based on the equivalence of a set containing a conjunction <img class="tex" alt="A \wedge B" src="http://upload.wikimedia.org/math/2/c/1/2c1e6cb923ab7b5d63ce41ed77fe8c36.png" /> with the set containing both <span class="texhtml"><i>A</i></span> and <span class="texhtml"><i>B</i></span> in place of it. In particular, if a leaf is labeled with <img class="tex" alt="X \cup \{A \wedge B\}" src="http://upload.wikimedia.org/math/1/c/a/1cabdc55d2120e2b98dca5673acf80eb.png" />, a node can be appended to it with label <img class="tex" alt="X \cup \{A, B\}" src="http://upload.wikimedia.org/math/0/6/6/066327743754bbbda90b3aa5fb4633bd.png" />:</p>
<dl>
<dd><img class="tex" alt="(\wedge) \frac{X \cup \{A \wedge B\}}{X \cup \{A, B\}}" src="http://upload.wikimedia.org/math/c/9/e/c9e240e18fe66bc50fb151ccee8fc625.png" /></dd>
</dl>
<p>For disjunction, a set <img class="tex" alt="X \cup \{A \vee B\}" src="http://upload.wikimedia.org/math/3/1/2/312d7d7e70a1f01a9cf6604f17ea9ee2.png" /> is equivalent to the disjunction of the two sets <img class="tex" alt="X \cup \{A\}" src="http://upload.wikimedia.org/math/a/3/d/a3d5f9be6deaaedb93307c0b60724951.png" /> and <img class="tex" alt="X \cup \{B\}" src="http://upload.wikimedia.org/math/1/3/1/1313f6055d352cec61dfa31d2e45d12e.png" />. As a result, if the first set labels a leaf, two children can be appended to it, labeled with the latter two formulae.</p>
<dl>
<dd><img class="tex" alt="(\vee) \frac{X \cup \{A \vee B\}}{X \cup \{A\}|X \cup \{B\}}" src="http://upload.wikimedia.org/math/1/4/e/14ed8c3fc945fb32567bf37ff94f194c.png" /></dd>
</dl>
<p>Finally, if a set contains both a literal and its negation, this branch can be closed:</p>
<dl>
<dd><img class="tex" alt="(id) \frac{X \cup \{p, \neg p\}}{closed}" src="http://upload.wikimedia.org/math/2/b/a/2ba77edb28cfc4ea8e89df18a1da80ea.png" /></dd>
</dl>
<p>A tableau for a given finite set <i>X</i> is a finite (upside down) tree with root <i>X</i> in which all child nodes are obtained by applying the tableau rules to their parents. A branch in such a tableau is closed if its leaf node contains "closed". A tableau is closed if all its branches are closed. A tableau is open if at least one branch is not closed.</p>
<p>Here are two closed tableaux for the set <i>X</i> = {<i>r</i>0 &amp; ~<i>r</i>0, <i>p</i>0 &amp; ((~<i>p</i>0 ∨ <i>q</i>0) &amp; ~<i>q</i>0)} with each rule application marked at the right hand side (&amp; and ~ stand for <img class="tex" alt="\wedge" src="http://upload.wikimedia.org/math/1/b/a/1ba4f06f68614e5da79a8ebd378d532a.png" /> and <img class="tex" alt="\neg" src="http://upload.wikimedia.org/math/a/0/c/a0c4c2ce7f9c78efeedd2bfb53ab9f3e.png" />, respectively)</p>
<pre>
 {r0 &amp; ~r0, p0 &amp; ((~p0 v q0) &amp; ~q0)}                                    {r0 &amp; ~r0, p0 &amp; ((~p0 v q0) &amp; ~q0)}
--------------------------------------(&amp;)                        ------------------------------------------------------------(&amp;)
 {r0 , ~r0, p0 &amp; ((~p0 v q0) &amp; ~q0)}                                    {r0 &amp; ~r0, p0, ((~p0 v q0) &amp; ~q0)}
 -------------------------------------(id)                         ----------------------------------------------------------(&amp;)
            closed                                                      {r0 &amp; ~r0, p0,  (~p0 v q0),  ~q0} 
                                                                -------------------------------------------------------------(v)
                                                                  {r0 &amp; ~r0, p0, ~p0, ~q0}       |   {r0 &amp; ~r0, p0, q0, ~q0}
                                                                 -------------------------- (id)     ----------------------  (id)
                                                                          closed                            closed
</pre>
<p>The left hand tableau closes after only one rule application while the right hand one misses the mark and takes a lot longer to close. Clearly, we would prefer to always find the shortest closed tableaux but it can be shown that one single algorithm that finds the shortest closed tableaux for all input sets of formulae cannot exist.</p>
<p>The three rules <img class="tex" alt="(\wedge)" src="http://upload.wikimedia.org/math/2/6/8/26869e731c6120e72c0fdfcd91297335.png" />, <img class="tex" alt="(\vee)" src="http://upload.wikimedia.org/math/7/3/c/73c0574045fa05acfb8bbb7c84408b59.png" /> and <span class="texhtml">(<i>i</i><i>d</i>)</span> given above are then enough to decide if a given set <span class="texhtml"><i>X</i>'</span> of formulae in negated normal form are jointly satisfiable:</p>
<blockquote>
<p>Just apply all possible rules in all possible orders until we find a closed tableau for <span class="texhtml"><i>X</i>'</span> or until we exhaust all possibilities and conclude that every tableau for <span class="texhtml"><i>X</i>'</span> is open.</p>
</blockquote>
<p>In the first case, <span class="texhtml"><i>X</i>'</span> is jointly unsatisfiable and in the second the case the leaf node of the open branch gives an assignment to the atomic formulae and negated atomic formulae which makes <span class="texhtml"><i>X</i>'</span> jointly satisfiable. Classical logic actually has the rather nice property that we need to investigate only (any) one tableau completely: if it closes then <span class="texhtml"><i>X</i>'</span> is unsatisfiable and if it is open then <span class="texhtml"><i>X</i>'</span> is satisfiable. But this property is not generally enjoyed by other logics.</p>
<p>These rules suffice for all of classical logic by taking an initial set of formulae <i>X</i> and replacing each member <i>C</i> by its logically equivalent negated normal form <i>C'</i> giving a set of formulae <i>X'</i> . We know that <i>X</i> is satisfiable if and only if <i>X'</i> is satisfiable, so it suffices to search for a closed tableau for <i>X'</i> using the procedure outlined above.</p>
<p>By setting <img class="tex" alt="X = \{\neg A\}" src="http://upload.wikimedia.org/math/2/7/a/27aaee4d38534a4cf904c0347b79094d.png" /> we can test whether the formula <i>A</i> is a tautology of classical logic:</p>
<blockquote>
<p>If the tableau for <img class="tex" alt="\{\neg A\}" src="http://upload.wikimedia.org/math/3/e/8/3e87f5d8569b6433d8dabd6d4ce561d0.png" /> closes then <img class="tex" alt="\neg A" src="http://upload.wikimedia.org/math/9/1/f/91f4f5fde06448561332b0f36c5a0973.png" /> is unsatisfiable and so <i>A</i> is a tautology since no assignment of truth values will ever make <i>A</i> false. Otherwise any open leaf of any open branch of any open tableau for <img class="tex" alt="\{\neg A\}" src="http://upload.wikimedia.org/math/3/e/8/3e87f5d8569b6433d8dabd6d4ce561d0.png" /> gives an assignment that falsifies <i>A</i>.</p>
</blockquote>
<p><a name="Conditional" id="Conditional"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=8" title="Edit section: Conditional">edit</a>]</span> <span class="mw-headline">Conditional</span></h3>
<p>Classical <a href="/wiki/Propositional_logic" title="Propositional logic" class="mw-redirect">propositional logic</a> usually has a <a href="/wiki/Connective_(logic)" title="Connective (logic)" class="mw-redirect">connective</a> to denote <a href="/wiki/Material_implication" title="Material implication" class="mw-redirect">material implication</a>. If we write this connective as ⇒, then the formula <i>A</i> ⇒ <i>B</i> stands for "if <i>A</i> then <i>B</i>". It is possible to give a tableau rule for breaking down <i>A</i> ⇒ <i>B</i> into its constituent formulae. Similarly, we can give one rule each for breaking down each of ¬(<i>A</i> ∧ <i>B</i>), ¬(<i>A</i> ∨ <i>B</i>), ¬(¬<i>A</i>), and ¬(<i>A</i> ⇒ <i>B</i>). Together these rules would give a terminating procedure for deciding whether a given set of formulae is simultaneously <a href="/wiki/Satisfiable" title="Satisfiable" class="mw-redirect">satisfiable</a> in classical logic since each rule breaks down one formula into its constituents but no rule builds larger formulae out of smaller constituents. Thus we must eventually reach a node that contains only <a href="/wiki/Atom_(logic)" title="Atom (logic)" class="mw-redirect">atoms</a> and negations of atoms. If this last node matches (id) then we can close the branch, otherwise it remains open.</p>
<p>But note that the following equivalences hold in classical logic where (...) = (...) means that the left hand side formula is <a href="/wiki/Logically_equivalent" title="Logically equivalent" class="mw-redirect">logically equivalent</a> to the right hand side formula:</p>
<p><img class="tex" alt="
\begin{array}{lcl}
\neg (A \and B)            &amp; = &amp; \neg A \or \neg B \\
\neg (A \or B)             &amp; = &amp; \neg A \and \neg B \\
\neg (\neg A)              &amp; = &amp; A \\
\neg (A \Rightarrow B)     &amp; = &amp; A \and \neg B \\
A \Rightarrow B            &amp; = &amp; \neg A \or B \\
A \Leftrightarrow B        &amp; = &amp; (A \and B) \or (\neg A \and \neg B) \\
\neg (A \Leftrightarrow B) &amp; = &amp; (A \and \neg B) \or (\neg A \and B)
\end{array}
" src="http://upload.wikimedia.org/math/b/e/0/be0e65386630e10790c8f35873dd0c4c.png" /></p>
<p>If we start with an arbitrary formula <i>C</i> of <a href="/wiki/Classical_logic" title="Classical logic">classical logic</a>, and apply these equivalences repeatedly to replace the left hand sides with the right hand sides in <i>C</i>, then we will obtain a formula <i>C'</i> which is logically equivalent to <i>C</i> but which has the property that <i>C'</i> contains no implications, and ¬ appears in front of atomic formulae only. Such a formula is said to be in <a href="/wiki/Negation_normal_form" title="Negation normal form">negation normal form</a> and it is possible to prove formally that every formula <i>C</i> of classical logic has a logically equivalent formula <i>C'</i> in negation normal form. That is, <i>C</i> is satisfiable if and only if <i>C'</i> is satisfiable.</p>
<p><a name="First-order_logic_tableau" id="First-order_logic_tableau"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=9" title="Edit section: First-order logic tableau">edit</a>]</span> <span class="mw-headline">First-order logic tableau</span></h2>
<p>Tableau are extended to first order by two rules for dealing with universal and existential quantifiers, respectively. Two different sets of rules can be used; both employ a form of <a href="/wiki/Skolem_normal_form" title="Skolem normal form">Skolemization</a> for handing existential quantifiers, but differ on the handling of universal quantifiers.</p>
<p>The set of formulae to check for validity is here supposed to contain no free variables; this is not a limitation as free variables are implicitly universally quantified, so universal quantifiers over these variables can be added, resulting in a formula with no free variables.</p>
<p><a name="First-order_tableau_without_unification" id="First-order_tableau_without_unification"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=10" title="Edit section: First-order tableau without unification">edit</a>]</span> <span class="mw-headline">First-order tableau without unification</span></h3>
<p>A first-order formula <img class="tex" alt="\forall x . \gamma(x)" src="http://upload.wikimedia.org/math/f/2/6/f261ae7c9ef5f4eb44a00b8c9181b572.png" /> implies all formulae <span class="texhtml">γ(<i>t</i>)</span> where <span class="texhtml"><i>t</i></span> is a ground term. The following inference rule is therefore correct:</p>
<dl>
<dd><img class="tex" alt="(\forall) \frac{\forall x . \gamma(x)}{\gamma(t)}" src="http://upload.wikimedia.org/math/3/b/0/3b0f94945e4e90e86cec0274e8cf3ac3.png" /> where <span class="texhtml"><i>t</i></span> is an arbitrary ground term</dd>
</dl>
<p>Contrarily to the rules for the propositional connectives, multiple applications of this rule to the same formula may be necessary. As an example, the set <img class="tex" alt="\{\neg P(a) \vee \neg P(b), \forall x . P(x)\}" src="http://upload.wikimedia.org/math/c/c/3/cc34453019afd652e645e69925e7fdb2.png" /> can only be proved unsatisfiable if both <span class="texhtml"><i>P</i>(<i>a</i>)</span> and <span class="texhtml"><i>P</i>(<i>b</i>)</span> are generated from <img class="tex" alt="\forall x . P(x)" src="http://upload.wikimedia.org/math/8/b/d/8bde802642d0698481b53213a035f76d.png" />.</p>
<p>Existential quantifiers are dealt with Skolemization. In particular, a formula with a leading existential quantifier like <img class="tex" alt="\exists x . \delta(x)" src="http://upload.wikimedia.org/math/b/a/9/ba94f015fd86ad3743efb8e288ebf7c3.png" /> generates its Skolemization <span class="texhtml">δ(<i>c</i>)</span>, where <span class="texhtml"><i>c</i></span> is a new constant symbol.</p>
<dl>
<dd><img class="tex" alt="(\exists) \frac{\exists x . \delta(x)}{\delta(c)}" src="http://upload.wikimedia.org/math/a/a/8/aa8c78f329cad809c1c0aa18a297ad01.png" /> where <span class="texhtml"><i>c</i></span> is a new constant symbol</dd>
</dl>
<div class="thumb tright">
<div class="thumbinner" style="width:352px;"><a href="/wiki/File:First-order_tableau.svg" class="image" title="A tableau without unification for . For clarity, formulae are numbered on the left and the formula and rule used at each step is on the right"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/c/c3/First-order_tableau.svg/350px-First-order_tableau.svg.png" width="350" height="282" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:First-order_tableau.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
A tableau without unification for <img class="tex" alt="\{\forall x.P(x), \exists x.(\neg P(x) \vee \neg P(f(x)))\}" src="http://upload.wikimedia.org/math/e/3/1/e315d7b4ab054df01b561a646cbc0e82.png" />. For clarity, formulae are numbered on the left and the formula and rule used at each step is on the right</div>
</div>
</div>
<p>The Skolem term <span class="texhtml"><i>c</i></span> is a constant (a function of arity 0) because the quantification over <span class="texhtml"><i>x</i></span> does not occur within the scope of any universal quantifier. If the original formula contained some universal quantifiers such that the quantification over <span class="texhtml"><i>x</i></span> was within their scope, these quantifiers have evidently been removed by the application of the rule for universal quantifiers.</p>
<p>The rule for existential quantifiers introduces new constant symbols. These symbols can be used by the rule for universal quantifiers, so that <img class="tex" alt="\forall y . \gamma(y)" src="http://upload.wikimedia.org/math/b/5/5/b55d72c764de5e20606cdfc63d2ed979.png" /> can generate <span class="texhtml">γ(<i>c</i>)</span> even if <span class="texhtml"><i>c</i></span> was not in the original formula but is a Skolem constant created by the rule for existential quantifiers.</p>
<p>The above two rules for universal and existential quantifiers are correct, and so are the propositional rules: if a set of formulae generates a closed tableau, this set is unsatisfiable. Completeness can also be proved: if a set of formulae is unsatisfiable, there exists a closed tableau built from it by these rules. However, actually finding such a closed tableau requires a suitable policy of application of rules. Otherwise, an unsatisfiable set can generate an infinite-growing tableau. As an example, the set <img class="tex" alt="\{\neg P(f(c)), \forall x . P(x)\}" src="http://upload.wikimedia.org/math/d/8/a/d8a84703b4b95be962c916773f6a4193.png" /> is unsatisfiable, but a closed tableau is never obtained if one unwisely keeps applying the rule for universal quantifiers to <img class="tex" alt="\forall x . P(x)" src="http://upload.wikimedia.org/math/8/b/d/8bde802642d0698481b53213a035f76d.png" />, generating for example <img class="tex" alt="P(c), P(f(c)), P(f(f(c))), \ldots" src="http://upload.wikimedia.org/math/7/2/a/72acd477124d240dbf4c550c2040b09f.png" />. A closed tableau can always be found by ruling out this and similar "unfair" policies of application of tableau rules.</p>
<p>The rule for universal quantifiers <img class="tex" alt="(\forall)" src="http://upload.wikimedia.org/math/2/5/c/25c983bc72cef21543c5c8da5d72a69c.png" /> is the only non-deterministic rule, as it does not specify which term to instantiate with. Moreover, while the other rules need to be applied only once for each formula and each path the formula is in, this one may require multiple applications. Application of this rule can however be restricted by delaying the application of the rule until no other rule is applicable and by restricting the application of the rule to ground terms that already appear in the path of the tableau. The variant of tableaux with unification shown below aims at solving the problem of non-determinism.</p>
<p><a name="First-order_tableau_with_unification" id="First-order_tableau_with_unification"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=11" title="Edit section: First-order tableau with unification">edit</a>]</span> <span class="mw-headline">First-order tableau with unification</span></h3>
<p>The main problem of tableau without unification is how to choose a ground term <span class="texhtml"><i>t</i></span> for the universal quantifier rule. Indeed, every possible ground term can be used, but clearly most of them might be useless for closing the tableau.</p>
<p>A solution to this problem is to "delay" the choice of the term to the time when the consequent of the rule allows closing at least a branch of the tableau. This can be done by using a variable instead of a term, so that <img class="tex" alt="\forall x . \gamma(x)" src="http://upload.wikimedia.org/math/f/2/6/f261ae7c9ef5f4eb44a00b8c9181b572.png" /> generates <span class="texhtml">γ(<i>x</i>')</span>, and then allowing substitutions to later replace <span class="texhtml"><i>x</i>'</span> with a term. The rule for universal quantifiers becomes:</p>
<dl>
<dd><img class="tex" alt="(\forall) \frac{\forall x . \gamma(x)}{\gamma(x')}" src="http://upload.wikimedia.org/math/e/c/e/eced378201584c8458d6b0450934c19b.png" /> where <span class="texhtml"><i>x</i>'</span> is a variable not occurring everywhere else in the tableau</dd>
</dl>
<p>While the initial set of formulae is supposed not to contain free variables, a formula of the tableau contain the free variables generated by this rule. These free variables are implicitly considered universally quantified.</p>
<p>This rule employs a variable instead of a ground term. The gain of this change is that these variables can be then given a value when a branch of the tableau can be closed, solving the problem of generating terms that might be useless.</p>
<dl>
<dd>
<table>
<tr>
<td><span class="texhtml">(σ)</span></td>
<td>if <span class="texhtml">σ</span> is the most general unifier of two literals <span class="texhtml"><i>A</i></span> and <span class="texhtml"><i>B</i></span>, where <span class="texhtml"><i>A</i></span> and the negation of <span class="texhtml"><i>B</i></span> occur in the same branch of the tableau, <span class="texhtml">σ</span> can be applied at the same time to all formulae of the tableau</td>
</tr>
</table>
</dd>
</dl>
<p>As an example, <img class="tex" alt="\{\neg P(a), \forall x . P(x)\}" src="http://upload.wikimedia.org/math/6/c/e/6ce8abcdc1934398e5bd45884346a44b.png" /> can be proved unsatisfiable by first generating <span class="texhtml"><i>P</i>(<i>x</i><sub>1</sub>)</span>; the negation of this literal is unifiable with <img class="tex" alt="\neg P(a)" src="http://upload.wikimedia.org/math/a/9/0/a9078cdeab78eed84446fa5bc6de4703.png" />, the most general unifier being the substitution that replaces <span class="texhtml"><i>x</i><sub>1</sub></span> with <span class="texhtml"><i>a</i></span>; applying this substitution results in replacing <span class="texhtml"><i>P</i>(<i>x</i><sub>1</sub>)</span> with <span class="texhtml"><i>P</i>(<i>a</i>)</span>, which closes the tableau.</p>
<p>This rule closes at least a branch of the tableau -the one containing the considered pair of literals. However, the substitution has to be applied to the whole tableau, not only on these two literals. This is expressed by saying that the free variables of the tableau are <i>rigid</i>: if an occurrence of a variable is replaced by something else, all other occurrences of the same variable must be replaced in the same way. Formally, the free variables are (implicitly) universally quantified and all formulae of the tableau are within the scope of these quantifiers.</p>
<p>Existential quantifiers are dealt with by Skolemization. Contrary to the tableau without unification, Skolem terms may not be simple constant. Indeed, formulae in a tableau with unification may contain free variables, which are implicitly considered universally quantified. As a result, a formula like <img class="tex" alt="\exists x . \delta(x)" src="http://upload.wikimedia.org/math/b/a/9/ba94f015fd86ad3743efb8e288ebf7c3.png" /> may be within the scope of universal quantifiers; if this is the case, the <a href="/wiki/Skolem_term" title="Skolem term" class="mw-redirect">Skolem term</a> is not a simple constant but a term made of a new function symbol and the free variables of the formula.</p>
<dl>
<dd><img class="tex" alt="(\exists) \frac{\exists x . \delta(x)}{\delta(f(x_1,\ldots,x_n)}" src="http://upload.wikimedia.org/math/1/6/c/16c9d736b1b45482a1b66bd7b1dfe77a.png" /> where <span class="texhtml"><i>f</i></span> is a new function symbol and <img class="tex" alt="x_1,\ldots,x_n" src="http://upload.wikimedia.org/math/c/2/a/c2a79f82f9c9783d20426062c9feebbe.png" /> the free variables of <span class="texhtml">δ</span></dd>
</dl>
<div class="thumb tright">
<div class="thumbinner" style="width:402px;"><a href="/wiki/File:First-order_tableau_with_unification.svg" class="image" title="A first-order tableau with unification for . For clarity, formulae are numbered on the left and the formula and rule used at each step is on the right"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/2/23/First-order_tableau_with_unification.svg/400px-First-order_tableau_with_unification.svg.png" width="400" height="255" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:First-order_tableau_with_unification.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
A first-order tableau with unification for <img class="tex" alt="\{\forall x.P(x), \exists x.(\neg P(x) \vee \neg P(f(x)))\}" src="http://upload.wikimedia.org/math/e/3/1/e315d7b4ab054df01b561a646cbc0e82.png" />. For clarity, formulae are numbered on the left and the formula and rule used at each step is on the right</div>
</div>
</div>
<p>This rule incorporates a simplification over a rule where <img class="tex" alt="x_1,\ldots,x_n" src="http://upload.wikimedia.org/math/c/2/a/c2a79f82f9c9783d20426062c9feebbe.png" /> are the free variables of the branch, not of <span class="texhtml">δ</span> alone. This rule can be further simplified by the reuse of a function symbol if it has already been used in a formula that is identical to <span class="texhtml">δ</span> up to variable renaming.</p>
<p>The formula represented by a tableau is obtained in a way that is similar to the propositional case, with the additional assumption that free variables are considered universally quantified. As for the propositional case, formulae in each branch are conjoined and the resulting formulae are disjoined. In addition, all free variables of the resulting formula are universally quantified. All these quantifiers have the whole formula in their scope. In other words, if <span class="texhtml"><i>F</i></span> is the formula obtained by disjoining the conjunction of the formulae in each branch, and <img class="tex" alt="x_1,\ldots,x_n" src="http://upload.wikimedia.org/math/c/2/a/c2a79f82f9c9783d20426062c9feebbe.png" /> are the free variables in it, then <img class="tex" alt="\forall x_1,\ldots,x_n . F" src="http://upload.wikimedia.org/math/d/8/1/d815cca1146bf2321357822dc5560b57.png" /> is the formula represented by the tableau. The following considerations apply:</p>
<ul>
<li>The assumption that free variables are universally quantified is what makes the application of a most general unifier a sound rule: since <span class="texhtml">γ(<i>x</i>')</span> means that <span class="texhtml">γ</span> is true for every possible value of <span class="texhtml"><i>x</i>'</span>, then <span class="texhtml">γ(<i>t</i>)</span> is true for the term <span class="texhtml"><i>t</i></span> that the most general unifier replaces <span class="texhtml"><i>x</i></span> with.</li>
</ul>
<ul>
<li>Free variables in a tableau are rigid: all occurrences of the same variable have to be replaced all with the same term. Every variable can be considered a symbol representing a term that is yet to be decided. This is a consequence of free variables being assumed universally quantified over the whole formula represented by the tableau: if the same variable occurs free in two different nodes, both occurrences are in the scope of the same quantifier. As an example, if the formulae in two nodes are <span class="texhtml"><i>A</i>(<i>x</i>)</span> and <span class="texhtml"><i>B</i>(<i>x</i>)</span>, where <span class="texhtml"><i>x</i></span> is free in both, the formula represented by the tableau is something in the form <img class="tex" alt="\forall x . (...A(x)...B(x)...)" src="http://upload.wikimedia.org/math/a/2/d/a2df407b937253c75b8943428319a23b.png" />. This formula implies that <span class="texhtml">(...<i>A</i>(<i>x</i>)...<i>B</i>(<i>x</i>)...)</span> is true for any value of <span class="texhtml"><i>x</i></span>, but does not in general imply <span class="texhtml">(...<i>A</i>(<i>t</i>)...<i>A</i>(<i>t</i>')...)</span> for two different terms <span class="texhtml"><i>t</i></span> and <span class="texhtml"><i>t</i>'</span>, as these two terms may in general take different values. This means that <span class="texhtml"><i>x</i></span> cannot be replaced by two different terms in <span class="texhtml"><i>A</i>(<i>x</i>)</span> and <span class="texhtml"><i>B</i>(<i>x</i>)</span>.</li>
</ul>
<ul>
<li>Free variables in a formula to check for validity are also considered universally quantified. However, these variables cannot be left free when building a tableau, because tableau rules works on the converse of the formula but still treats free variables as universally quantified. For example, <img class="tex" alt="P(x) \rightarrow P(c)" src="http://upload.wikimedia.org/math/f/b/2/fb284f97afbe3cc9133e36552953a4ed.png" /> is not valid (it is not true in the model where <img class="tex" alt="D=\{1,2\}, P(1)=\bot, P(2)=\top, c=1" src="http://upload.wikimedia.org/math/c/a/6/ca65d8f83780efe05eba1a476c5a1820.png" />, and the interpretation where <span class="texhtml"><i>x</i> = 2</span>). Consequently, <img class="tex" alt="\{P(x),\neg P(c)\}" src="http://upload.wikimedia.org/math/1/d/0/1d04edc71ddab1778583bcdd223eee54.png" /> is satisfiable (it is satisfied by the same model and interpretation). However, a closed tableau could be generated with <span class="texhtml"><i>P</i>(<i>x</i>)</span> and <img class="tex" alt="\neg P(c)" src="http://upload.wikimedia.org/math/7/e/d/7edb061493143c5117cf6d31dd685819.png" />, and substituting <span class="texhtml"><i>x</i></span> with <span class="texhtml"><i>c</i></span> would generate a closure. A correct procedure is to first make universal quantifiers explicit, thus generating <img class="tex" alt="\forall x . (P(x) \rightarrow P(c))" src="http://upload.wikimedia.org/math/7/6/5/7654ad06f87d789a66f03dbf964efa82.png" />.</li>
</ul>
<p>The following two variants are also correct.</p>
<ul>
<li>Applying to the whole tableau a substitution to the free variables of the tableau is a correct rule, provided that this substitution is free for the formula representing the tableau. In other worlds, applying such a substitution leads to a tableau whose formula is still a consequence of the input set. Using most general unifiers automatically ensures that the condition of freeness for the tableau is met.</li>
</ul>
<ul>
<li>While in general every variable has to be replaced with the same term in the whole tableau, there are some special cases in which this is not necessary.</li>
</ul>
<p>Tableau with unification can be proved complete: if a set of formulae is unsatisfiable, it has a tableau-with-unification proof. However, actually finding such a proof may be a difficult problem. Contrarily to the case without unification, applying a substitution can modify the existing part of a tableau; while applying a substitution closes at least a branch, it may make other branches impossible to close (even if the set is unsatisfiable).</p>
<p>A solution to this problem is that <i>delayed instantiation</i>: no substitution is applied until one that closes all branches at the same time is found. With this variant, a proof for an unsatisfiable set can always be found by a suitable policy of application of the other rules. This method however requires the whole tableau to be kept in memory: the general method closes branches which can be then discarded, while this variant does not close any branch until the end.</p>
<p>The problem that some tableau that can be generated are impossible to close even if the set is unsatisfiable is common to other sets of tableau expansion rules: even if some specific sequences of application of these rules allow constructing a closed tableau (if the set is unsatisfiable), some other sequences lead to tableau that cannot be closed. General solutions for these cases are outlined in the "Searching for a tableau" section.</p>
<p><a name="Tableau_calculi_and_their_properties" id="Tableau_calculi_and_their_properties"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=12" title="Edit section: Tableau calculi and their properties">edit</a>]</span> <span class="mw-headline">Tableau calculi and their properties</span></h2>
<p>A tableau calculus is a set of rules that allows building and modification of a tableau. Propositional tableau rules, tableau rules without unification, and tableau rules with unification, are all tableau calculi. Some important properties a tableau calculus may or may not possess are completeness, destructiveness, and proof confluence.</p>
<p>A tableau calculi is said complete if it allows building a tableau proof for every given unsatisfiable set of formulae. The tableau calculi mentioned above can be proved complete.</p>
<p>A remarkable difference between tableau with unification and the other two calculi is that the latter two calculi only modify a tableau by adding new nodes to it, while the former one allows substitutions to modify the existing part of the tableau. More generally, tableau calculi are classed as <i>destructive</i> or <i>non-destructive</i> depending on whether they only add new nodes to tableau or not. Tableau with unification is therefore destructive, while propositional tableau and tableau without unification are non-destructive.</p>
<p>Proof confluence is the property of a tableau calculus to obtain a proof for an arbitrary unsatisfiable set from an arbitrary tableau, assuming that this tableau has itself been obtained by applying the rules of the calculus. In other words, in a proof confluent tableau calculus, from an unsatisfiable set one can apply whatever set of rules and still obtain a tableau from which a closed one can be obtained by applying some other rules.</p>
<p><a name="Proof_procedures" id="Proof_procedures"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=13" title="Edit section: Proof procedures">edit</a>]</span> <span class="mw-headline">Proof procedures</span></h2>
<p>A tableau calculus is simply a set of rules that tells how a tableau can be modified. A proof procedure is a method for actually finding a proof (if one exists). In other words, a tableau calculus is a set of rules, while a proof procedure is a policy of application of these rules. Even if a calculus is complete, not every possible choice of application of rules leads to a proof of an unsatisfiable set. For example <img class="tex" alt="\{P(f(x)), R(c), \neg P(f(c)) \vee \neg R(c), \forall x .  Q(x)\}" src="http://upload.wikimedia.org/math/4/e/a/4eafdda026de06a318253828264f2bcf.png" /> is unsatisfiable, but both tableaux with unification and tableaux without unification allow the rule for the universal quantifiers to be applied repeatedly to the last formula, while simply applying the rule for disjunction to the third one would directly lead to closure.</p>
<p>For proof procedures, a definition of completeness has been given: a proof procedure is strongly complete if it allows finding a closed tableau for any given unsatisfiable set of formulae. Proof confluence of the underlying calculus is relevant to completeness: proof confluence is the guarantee that a closed tableau can be always generated from an arbitrary partially constructed tableau (if the set is unsatisfiable). Without proof confluence, the application of a 'wrong' rule may result in the impossibility of making the tableau complete by applying other rules.</p>
<p>Propositional tableaux and tableaux without unification have strongly complete proof procedures. In particular, a complete proof procedure is that of applying the rules in a <i>fair</i> way. This is because the only way such calculi cannot generate a closed tableau from an unsatisfiable set is by not applying some applicable rules.</p>
<p>For propositional tableaux, fairness amounts to expanding every formula in every branch. More precisely, for every formula and every branch the formula is in, the rule having the formula as a precondition has been used to expand the branch. A fair proof procedure for propositional tableaux is strongly complete.</p>
<p>For first-order tableaux without unification, the condition of fairness is similar, with the exception that the rule for universal quantifier might require more than one application. Fairness amounts to expanding every universal quantifier infinitely often. In other words, a fair policy of application of rules cannot keep applying other rules without expanding every universal quantifier in every branch that is still open once in a while.</p>
<p><a name="Searching_for_a_closed_tableau" id="Searching_for_a_closed_tableau"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=14" title="Edit section: Searching for a closed tableau">edit</a>]</span> <span class="mw-headline">Searching for a closed tableau</span></h2>
<p>If a tableau calculus is complete, every unsatisfiable set of formula has an associated closed tableau. While this tableau can always be obtained by applying some of the rules of the calculus, the problem of which rules to apply for a given formula still remains. As a result, completeness does not automatically implies the existence of a feasible policy of application of rules that can always lead to building a closed tableau for every given unsatisfiable set of formulae. While a fair proof procedure is complete for ground tableau and tableau without unification, this is not the case for tableau with unification.</p>
<div class="thumb tright">
<div class="thumbinner" style="width:702px;"><a href="/wiki/File:Search_tree_of_tableau_space.svg" class="image" title="A search tree in the space of tableau for . For simplicity, the formulae of the set have been omitted from all tableau in the figure and a rectangle used in their place. A closed tableau is in the bold box; the other branches could be still expanded."><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/b/bb/Search_tree_of_tableau_space.svg/700px-Search_tree_of_tableau_space.svg.png" width="700" height="320" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Search_tree_of_tableau_space.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
A search tree in the space of tableau for <img class="tex" alt="\{\forall x.P(x), \neg P(c) \vee \neg Q(c), \exists y.Q(c)\}" src="http://upload.wikimedia.org/math/8/1/7/817d80d9dbb7db25cf1430e94ea6ba92.png" />. For simplicity, the formulae of the set have been omitted from all tableau in the figure and a rectangle used in their place. A closed tableau is in the bold box; the other branches could be still expanded.</div>
</div>
</div>
<p>A general solution for this problem is that of searching the space of tableau until a closed one is found (if any exists, that is, the set is unsatisfiable). In this approach, one starts with an empty tableau and then recursively tries to apply every possible applicable rule. This procedure visit a (implicit) tree whose nodes are labeled with tableau, and such that the tableau in a node is obtained from the tableau in its parent by applying one of the valid rules.</p>
<p>Since one such branch can be infinite, this tree has to be visited breadth-first rather than depth-first. This requires a large amount of space, as the breadth of the tree can grow exponentially. A method that may visit some nodes more than once but works in polynomial space is to visit in a depth-first manner with <a href="/wiki/Iterative_deepening" title="Iterative deepening" class="mw-redirect">iterative deepening</a>: one first visits the tree up to a certain depth, then increases the depth and perform the visit again. This particular procedure uses the depth (which is also the number of tableau rules that have been applied) for deciding when to stop at each step. Various other parameters (such as the size of the tableau labeling a node) have been used instead.</p>
<p><a name="Reducing_search" id="Reducing_search"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=15" title="Edit section: Reducing search">edit</a>]</span> <span class="mw-headline">Reducing search</span></h3>
<p>The size of the search tree depends on the number of (children) tableau that can be generated from a given (parent) one. Reducing the number of such tableau therefore reduces the required search.</p>
<p>A way for reducing this number is to disallow the generation of some tableau based on their internal structure. An example is the condition of regularity: if a branch contains a literal, using an expansion rule that generates the same literal is useless because the branch containing two copies of the literals would have the same set of formulae of the original one. This expansion can be disallowed because if a closed tableau exists, it can be found without it. This restriction is structural because it can be checked by looking at the structure of the tableau to expand only.</p>
<p>Different methods for reducing search disallow the generation of some tableau on the ground that a closed tableau can still be found by expanding the other ones. These restrictions are called global. As an example of a global restriction, one may employ a rule that specify which of the open branches is to be expanded. As a result, if a tableau has for example two non-closed branches, the rule tells which one is to be expanded, disallowing the expansion of the second one. This restriction reduces the search space because one possible choice is now forbidden; completeness if however not harmed, as the second branch will still be expanded if the first one is eventually closed. As an example, a tableau with root <img class="tex" alt="\neg a \wedge \neg b" src="http://upload.wikimedia.org/math/9/6/e/96ea5b9e9b9d0826bfe1e63f0335d8a4.png" />, child <img class="tex" alt="a \vee b" src="http://upload.wikimedia.org/math/5/0/d/50ddb475ce61684d9dace1f3ed6cc135.png" />, and two leaves <span class="texhtml"><i>a</i></span> and <span class="texhtml"><i>b</i></span> can be closed in two ways: applying <img class="tex" alt="(\wedge)" src="http://upload.wikimedia.org/math/2/6/8/26869e731c6120e72c0fdfcd91297335.png" /> first to <span class="texhtml"><i>a</i></span> and then to <span class="texhtml"><i>b</i></span>, or vice versa. There is clearly no need to follow both possibilities; one may consider only the case in which <img class="tex" alt="(\wedge)" src="http://upload.wikimedia.org/math/2/6/8/26869e731c6120e72c0fdfcd91297335.png" /> is first applied to <span class="texhtml"><i>a</i></span> and disregard the case in which it is first applied to <span class="texhtml"><i>b</i></span>. This is a global restriction because what allows neglecting this second expansion is the presence of the other tableau, where expansion is applied to <span class="texhtml"><i>a</i></span> first and <span class="texhtml"><i>b</i></span> afterwards.</p>
<p><a name="Clause_tableaux" id="Clause_tableaux"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=16" title="Edit section: Clause tableaux">edit</a>]</span> <span class="mw-headline">Clause tableaux</span></h2>
<p>When applied to sets of <a href="/wiki/Clause_(logic)" title="Clause (logic)">clauses</a> (rather than of arbitrary formulae), tableaux methods allow for a number of efficiency improvements. A first-order clause is a formula <img class="tex" alt="\forall x_1,\ldots,x_n L_1 \vee \cdots \vee L_m" src="http://upload.wikimedia.org/math/4/5/8/45861139b9ac1bd5f6dded1e0f111196.png" /> that does not contain free variables and such that each <span class="texhtml"><i>L</i><sub><i>i</i></sub></span> is a literal. The universal quantifiers are often omitted for clarity, so that for example <img class="tex" alt="P(x,y) \vee Q(f(x))" src="http://upload.wikimedia.org/math/9/f/0/9f021cd6a0e319d7402111059542cecc.png" /> actually means <img class="tex" alt="\forall x,y .  P(x,y) \vee Q(f(x))" src="http://upload.wikimedia.org/math/3/9/0/3909ca0f39a38793a7c0475267bc0672.png" />. Note that, if taken literally, these two formulae are not the same as for satisfiability: rather, the satisfiability <img class="tex" alt="P(x,y) \vee Q(f(x))" src="http://upload.wikimedia.org/math/9/f/0/9f021cd6a0e319d7402111059542cecc.png" /> is the same as that of <img class="tex" alt="\exists x,y . P(x,y) \vee Q(f(x))" src="http://upload.wikimedia.org/math/d/3/8/d3847f16b999651bf8159d9046ab8416.png" />. That free variables are universally quantified is not a consequence of the definition of first-order satisfiability; it is rather used as an implicit common assumption when dealing with clauses.</p>
<p>The only expansion rules that are applicable to a clause are <img class="tex" alt="(\forall)" src="http://upload.wikimedia.org/math/2/5/c/25c983bc72cef21543c5c8da5d72a69c.png" /> and <img class="tex" alt="(\vee)" src="http://upload.wikimedia.org/math/7/3/c/73c0574045fa05acfb8bbb7c84408b59.png" />; these two rules can be replaced by their combination without losing completeness. In particular, the following rule corresponds to applying in sequence the rules <img class="tex" alt="(\forall)" src="http://upload.wikimedia.org/math/2/5/c/25c983bc72cef21543c5c8da5d72a69c.png" /> and <img class="tex" alt="(\vee)" src="http://upload.wikimedia.org/math/7/3/c/73c0574045fa05acfb8bbb7c84408b59.png" /> of the first-order calculus with unification.</p>
<dl>
<dd><img class="tex" alt="(C) \frac{L_1 \vee \cdots \vee L_n}{L_1'|\cdots|L_n'}" src="http://upload.wikimedia.org/math/3/2/a/32a7314c428cd1c551d057a1b797c400.png" /> where <img class="tex" alt="L_1' \vee \cdots \vee L_n'" src="http://upload.wikimedia.org/math/3/6/3/3631500265cd304325f884ab318460e0.png" /> is obtained by replacing every variable with a new one in <img class="tex" alt="L_1 \vee \cdots \vee L_n" src="http://upload.wikimedia.org/math/b/6/1/b6189985862cdea8d9de210272e701ab.png" /></dd>
</dl>
<p>When the set to be checked for satisfiability is only composed of clauses, this and the unification rules are sufficient to prove unsatisfiability. In other worlds, the tableau calculi composed of <span class="texhtml">(<i>C</i>)</span> and <span class="texhtml">(σ)</span> is complete.</p>
<p>Since the clause expansion rule only generates literals and never new clauses, the clauses to which it can be applied are only clauses of the input set. As a result, the clause expansion rule can be further restricted to the case where the clause is in the input set.</p>
<dl>
<dd><img class="tex" alt="(C) \frac{L_1 \vee \cdots \vee L_n}{L_1'|\cdots|L_n'}" src="http://upload.wikimedia.org/math/3/2/a/32a7314c428cd1c551d057a1b797c400.png" /> where <img class="tex" alt="L_1' \vee \cdots \vee L_n'" src="http://upload.wikimedia.org/math/3/6/3/3631500265cd304325f884ab318460e0.png" /> is obtained by replacing every variable with a</dd>
</dl>
<p>new one in <img class="tex" alt="L_1 \vee \cdots \vee L_n" src="http://upload.wikimedia.org/math/b/6/1/b6189985862cdea8d9de210272e701ab.png" />, which is a clause of the input set</p>
<p>Since this rule directly exploit the clauses in the input set there is no need to initialize the tableau to the chain of the input clauses. The initial tableau can therefore be initialize with the single node labeled <span class="texhtml"><i>t</i><i>r</i><i>u</i><i>e</i></span>; this label is often omitted as implicit. As a result of this further simplification, every node of the tableau (apart of the root) is labeled with a literal.</p>
<p>A number of optimizations can be used for clause tableau. These optimization are aimed at reducing the number of possible tableaux to be explored when searching for a closed tableau as described in the "Searching for a closed tableau" section above.</p>
<p><a name="Connection_tableau" id="Connection_tableau"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=17" title="Edit section: Connection tableau">edit</a>]</span> <span class="mw-headline">Connection tableau</span></h3>
<p>Connection is a condition over tableau that forbids expanding a branch using clauses that are unrelated to the literals that are already in the branch. Connection and be defined in two ways:</p>
<dl>
<dt>strong connectedness&#160;</dt>
<dd>when expanding a branch, use an input clause only if it contains a literal that can be unified with the negation of the literal in the current leaf</dd>
<dt>weak connectedness&#160;</dt>
<dd>allow the use of clauses that contain a literal that unifies with the negation of a literal on the branch</dd>
</dl>
<p>Both conditions apply only to branches not only comprised of the root. The second definition allows for the use of a clause containing a literal that unifies with the negation of a literal in the branch, while the first only further constraint that literal to be in leaf of the current branch.</p>
<p>If clause expansion is restricted by connectedness (either strong or weak), its application produces a tableau in which substitution can applied to one of the new leaves, closing its branch. In particular, this is the leaf containing the literal of the clause that unifies with the negation of a literal in the branch (or the negation of the literal in the parent, in case of strong connection).</p>
<p>Both conditions of connectedness lead to a complete first-order calculus: if a set of clauses is unsatisfiable, it has a closed connected (strongly or weakly) tableau. Such a closed tableau can be found by searching in the space of tableaux as explained in the "Searching for a closed tableau" section. During this search, connectedness eliminates some possible choices of expansion, thus reducing search. In other worlds, while the tableau in a node of the tree can be in general expanded in several different ways, connection may allow only few of them, thus reducing the number of resulting tableaux that need to be further expanded.</p>
<p>This can be seen on the following (propositional) example. The tableau made of a chain <span class="texhtml"><i>t</i><i>r</i><i>u</i><i>e</i> − <i>a</i></span> for the set of clauses <img class="tex" alt="\{a, \neg a \vee b, \neg c \vee d, \neg b\}" src="http://upload.wikimedia.org/math/a/b/1/ab1409bd0f5af2bfc51e452f53d773a1.png" /> can be in general expanded using each of the four input clauses, but connection only allows the expansion that uses <img class="tex" alt="\neg a \vee b" src="http://upload.wikimedia.org/math/3/b/2/3b249f2cf8cc7850e14f9e9d79a32cf6.png" />. This means that the tree of tableaux has four leaves in general but only one if connectedness is imposed. This means that connectedness leaves only one tableau to try and expand, instead of the four ones to consider in general. In spite of this reduction of choices, the completeness theorem implies that a closed tableau can be found if the set is unsatisfiable.</p>
<p>The connectedness conditions, when applied to the propositional (clausal) case, make the resulting calculus non-confluent. As an example, <img class="tex" alt="\{a, b, \neg b\}" src="http://upload.wikimedia.org/math/5/1/a/51a255edc4688f1777f45ec558f6f314.png" /> is unsatisfiable, but applying <span class="texhtml">(<i>C</i>)</span> to <span class="texhtml"><i>a</i></span> generates the chain <span class="texhtml"><i>t</i><i>r</i><i>u</i><i>e</i> − <i>a</i></span>, which is not closed and to which no other expansion rule can be applied without violating either strong or weak connectedness. In the case of weak connectedness, confluence holds provided that the clause used for expanding the root is relevant to unsatisfiability, that is, it is contained in a minimally unsatisfiable subset of the set of clauses. Unfortunately, the problem of checking whether a clause meets this condition is itself a hard problem. In spite of non-confluence, a closed tableau can be found using search, as presented in the "Searching for a closed tableau" section above. While search is made necessary, connectedness reduces the possible choices of expansion, thus making search more efficient.</p>
<p><a name="Regular_tableaux" id="Regular_tableaux"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=18" title="Edit section: Regular tableaux">edit</a>]</span> <span class="mw-headline">Regular tableaux</span></h3>
<p>A tableau is regular if no literal occurs twice in the same branch. Enforcing this condition allows for a reduction of the possible choices of tableau expansion, as the clauses that would generate a non-regular tableau cannot be expanded.</p>
<p>These disallowed expansion steps are however useless. If <span class="texhtml"><i>B</i></span> is a branch containing a literal <span class="texhtml"><i>L</i></span>, and <span class="texhtml"><i>C</i></span> is a clause whose expansion violates regularity, then <span class="texhtml"><i>C</i></span> contains <span class="texhtml"><i>L</i></span>. In order to close the tableau, one needs to expand and close, among others, the branch where <span class="texhtml"><i>B</i> − <i>L</i></span>, where <span class="texhtml"><i>L</i></span> occurs twice. However, the formulae in this branch are exactly the same as the formulae of <span class="texhtml"><i>B</i></span> alone. As a result, the same expansion steps that close <span class="texhtml"><i>B</i> − <i>L</i></span> also close <span class="texhtml"><i>B</i></span>. This means that expanding <span class="texhtml"><i>C</i></span> was unnecessary; moreover, if <span class="texhtml"><i>C</i></span> contained other literals, its expansion generated other leaves that needed to be closed. In the propositional case, the expansion needed to close these leaves are completely useless; in the first-order case, they may only affect the rest of the tableau because of some unifications; these can however be combined to the substitutions used to close the rest of the tableau.</p>
<p><a name="Tableaux_for_modal_logics" id="Tableaux_for_modal_logics"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=19" title="Edit section: Tableaux for modal logics">edit</a>]</span> <span class="mw-headline">Tableaux for modal logics</span></h2>
<p>In a <a href="/wiki/Modal_logic" title="Modal logic">modal logic</a>, a model comprises a set of <i>possible worlds</i>, each one associated to a truth evaluation; an <i>accessibility relation</i> tells when a world is <i>accessible</i> from another one. A modal formula may specify not only conditions over a possible world, but also on the ones that are accessible from it. As an example, <img class="tex" alt="\Box A" src="http://upload.wikimedia.org/math/d/9/1/d91e4f304c84a7181bef110a238b40a3.png" /> is true in a world if <span class="texhtml"><i>A</i></span> is true in all worlds that are accessible from it.</p>
<p>As for propositional logic, tableaux for modal logics are based on recursively breaking formulae into its basic components. Expanding a modal formula may however require stating conditions over different worlds. As an example, if <img class="tex" alt="\neg \Box A" src="http://upload.wikimedia.org/math/d/7/9/d79f6da65565bb21b2e39eae890c2c5c.png" /> is true in a world then there exists a world accessible from it where <span class="texhtml"><i>A</i></span> is false. However, one cannot simply add the following rule to the propositional ones.</p>
<dl>
<dd><img class="tex" alt="\frac{\neg \Box A}{\neg A}" src="http://upload.wikimedia.org/math/0/b/8/0b82f204431b2578980d9a9bc7d28f0d.png" /></dd>
</dl>
<p>In propositional tableaux all formulae refer to the same truth evaluation, but the precondition of the rule above holds in a world while the consequence holds in another. Not taking into account this would generate wrong results. For example, formula <img class="tex" alt="a \wedge \neg \Box a" src="http://upload.wikimedia.org/math/d/6/3/d63ba251043a222f51eb2f821a4e04ad.png" /> states that <span class="texhtml"><i>a</i></span> is true in the current world and <span class="texhtml"><i>a</i></span> is false in a world that is accessible from it. Simply applying <img class="tex" alt="(\wedge)" src="http://upload.wikimedia.org/math/2/6/8/26869e731c6120e72c0fdfcd91297335.png" /> and the expansion rule above would produce <span class="texhtml"><i>a</i></span> and <img class="tex" alt="\neg a" src="http://upload.wikimedia.org/math/a/1/f/a1fb17953a3cc31a0b4993d229b3d5ce.png" />, but these two formulae should not in general generate a contradiction, as they hold in different worlds. Modal tableaux calculi do contain rules of the kind of the one above, but include mechanisms to avoid the incorrect interaction of formulae referring to different worlds.</p>
<p>Technically, tableaux for modal logics check the satisfiability of a set of formulae: they check whether there exists a model <span class="texhtml"><i>M</i></span> and world <span class="texhtml"><i>w</i></span> such that the formulae in the set are true in that model and world. In the example above, while <span class="texhtml"><i>a</i></span> states the truth of <span class="texhtml"><i>a</i></span> in <span class="texhtml"><i>w</i></span>, the formula <img class="tex" alt="\neg \Box a" src="http://upload.wikimedia.org/math/3/9/1/39187923ef8d5934c13039188399edfc.png" /> states the truth of <img class="tex" alt="\neg a" src="http://upload.wikimedia.org/math/a/1/f/a1fb17953a3cc31a0b4993d229b3d5ce.png" /> in some world <span class="texhtml"><i>w</i>'</span> that is accessible from <span class="texhtml"><i>w</i></span> and which may in general be different from <span class="texhtml"><i>w</i></span>. Tableaux calculi for modal logic take into account that formulae may refer to different worlds.</p>
<p>This fact has an important consequence: formulae that hold in a world may imply conditions over different successors of that world. Unsatisfiability may then be proved from the subset of formulae referring to the a single successor. This holds if a world may have more than one successor, which is true for most modal logic. If this is the case, a formula like <img class="tex" alt="\neg \Box A \wedge \neg \Box B" src="http://upload.wikimedia.org/math/8/8/5/8851286684f7989d1b88ae32af0fdc8c.png" /> is true if a successor where <img class="tex" alt="\neg A" src="http://upload.wikimedia.org/math/9/1/f/91f4f5fde06448561332b0f36c5a0973.png" /> holds exists and a successor where <img class="tex" alt="\neg B" src="http://upload.wikimedia.org/math/d/9/a/d9a9ce3734464ec8b2fa333bb4a87500.png" /> holds exists. In the other way around, if one can show unsatisfiability of <img class="tex" alt="\neg A" src="http://upload.wikimedia.org/math/9/1/f/91f4f5fde06448561332b0f36c5a0973.png" /> in an arbitrary successor, the formula is proved unsatisfiable without checking for worlds where <img class="tex" alt="\neg B" src="http://upload.wikimedia.org/math/d/9/a/d9a9ce3734464ec8b2fa333bb4a87500.png" /> holds. At the same time, if one can show unsatisfiability of <img class="tex" alt="\neg B" src="http://upload.wikimedia.org/math/d/9/a/d9a9ce3734464ec8b2fa333bb4a87500.png" />, there is no need to check <img class="tex" alt="\neg A" src="http://upload.wikimedia.org/math/9/1/f/91f4f5fde06448561332b0f36c5a0973.png" />. As a result, while there are two possible way to expand <img class="tex" alt="\neg \Box A \wedge \neg \Box B" src="http://upload.wikimedia.org/math/8/8/5/8851286684f7989d1b88ae32af0fdc8c.png" />, one of these two ways is always sufficient to prove unsatisfiability if the formula is unsatisfiable. For example, one may expand the tableau by considering an arbitrary world where <img class="tex" alt="\neg A" src="http://upload.wikimedia.org/math/9/1/f/91f4f5fde06448561332b0f36c5a0973.png" /> holds. If this expansion leads to unsatisfiability, the original formula is unsatisfiable. However, it is also possible that unsatisfiability cannot be proved this way, and that the world where <img class="tex" alt="\neg B" src="http://upload.wikimedia.org/math/d/9/a/d9a9ce3734464ec8b2fa333bb4a87500.png" /> holds should have been considered instead. As a result, one can always prove unsatisfiability by expanding either <img class="tex" alt="\neg \Box A" src="http://upload.wikimedia.org/math/d/7/9/d79f6da65565bb21b2e39eae890c2c5c.png" /> only or <img class="tex" alt="\neg \Box B" src="http://upload.wikimedia.org/math/8/d/f/8df73a4b8701f0477135ffa58131a335.png" /> only; however, if the wrong choice is done the resulting tableau may not be closed. Expanding either subformula leads to tableau calculi that are complete but not proof-confluent. Searching as described in the "Searching for a closed tableau" may therefore be necessary.</p>
<p>Depending on whether the precondition and consequence of a tableau expansion rule refer to the same world or not, the rule is called static or transactional. While rules for propositional connectives are all static, not all rules for modal connectives are transactional: for example, in every modal logic including axiom <a href="/w/index.php?title=T_(modal_logic)&amp;action=edit&amp;redlink=1" class="new" title="T (modal logic) (page does not exist)">T</a>, it holds that <img class="tex" alt="\Box A" src="http://upload.wikimedia.org/math/d/9/1/d91e4f304c84a7181bef110a238b40a3.png" /> implies <span class="texhtml"><i>A</i></span> in the same world. As a result, the relative (modal) tableau expansion rule is static, as both its precondition and consequence refer to the same world.</p>
<p><a name="Formula-deleting_tableau" id="Formula-deleting_tableau"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=20" title="Edit section: Formula-deleting tableau">edit</a>]</span> <span class="mw-headline">Formula-deleting tableau</span></h3>
<p>A way for making formulae referring to different worlds not interacting in the wrong way is to make sure that all formulae of a branch refer to the same world. This condition is initially true as all formulae in the set to be checked for consistency are assumed referring to the same world. When expanding a branch, two situations are possible: either the new formulae refer to the same world as the other one in the branch or not. In the first case, the rule is applied normally. In the second case, all formulae of the branch that do not also hold in the new world are deleted from the branch, and possibly added to all other branches that are still relative to the old world.</p>
<p>As an example, in <a href="/wiki/S5_(modal_logic)" title="S5 (modal logic)">S5</a> every formula <img class="tex" alt="\Box A" src="http://upload.wikimedia.org/math/d/9/1/d91e4f304c84a7181bef110a238b40a3.png" /> that is true in a world is also true in all accessible worlds (that is, in all accessible worlds both <span class="texhtml"><i>A</i></span> and <img class="tex" alt="\Box A" src="http://upload.wikimedia.org/math/d/9/1/d91e4f304c84a7181bef110a238b40a3.png" /> are true). Therefore, when applying <img class="tex" alt="\frac{\neg \Box A}{\neg A}" src="http://upload.wikimedia.org/math/0/b/8/0b82f204431b2578980d9a9bc7d28f0d.png" />, whose consequence holds in a different world, one deletes all formulae from the branch, but can keep all formulae <img class="tex" alt="\Box A" src="http://upload.wikimedia.org/math/d/9/1/d91e4f304c84a7181bef110a238b40a3.png" />, as these hold in the new world as well. In order to retain completeness, the deleted formulae are then added to all other branches that still refer to the old world.</p>
<p><a name="World-labeled_tableau" id="World-labeled_tableau"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=21" title="Edit section: World-labeled tableau">edit</a>]</span> <span class="mw-headline">World-labeled tableau</span></h3>
<p>A different mechanism for ensuring the correct interaction between formulae referring to different worlds is to switch from formulae to labeled formulae: instead of writing <span class="texhtml"><i>A</i></span>, one would write <span class="texhtml"><i>w</i>:<i>A</i></span> to make it explicit that <span class="texhtml"><i>A</i></span> holds in world <span class="texhtml"><i>w</i></span>.</p>
<p>All propositional expansion rules are adapted to this variant by stating that they all refer to formulae with the same world label. For example, <img class="tex" alt="w:A \wedge B" src="http://upload.wikimedia.org/math/a/0/7/a072541db7e905ad3df5fdcf84d05a99.png" /> generates two nodes labeled with <span class="texhtml"><i>w</i>:<i>A</i></span> and <span class="texhtml"><i>w</i>:<i>B</i></span>; a branch is closed only if it contains two opposite literals of the same world, like <span class="texhtml"><i>w</i>:<i>a</i></span> and <img class="tex" alt="w:\neg a" src="http://upload.wikimedia.org/math/1/5/f/15f5720bab3cbe8d8b33f486a9b03255.png" />; no closure is generated if the two world labels are different, like in <span class="texhtml"><i>w</i>:<i>a</i></span> and <img class="tex" alt="w':\neg a" src="http://upload.wikimedia.org/math/f/9/6/f96d659029b7e40041776f265c584170.png" />.</p>
<p>The modal expansion rule may have a consequence that refer to a different worlds. For example, the rule for <img class="tex" alt="\neg \Box A" src="http://upload.wikimedia.org/math/d/7/9/d79f6da65565bb21b2e39eae890c2c5c.png" /> would be written as follows</p>
<dl>
<dd><img class="tex" alt="\frac{w:\neg \Box A}{w':\neg A}" src="http://upload.wikimedia.org/math/4/8/7/487e3c29efd2a1e51c1726887b291045.png" /></dd>
</dl>
<p>The precondition and consequent of this rule refer to worlds <span class="texhtml"><i>w</i></span> and <span class="texhtml"><i>w</i>'</span>, respectively. The various different calculi use different methods for keeping track of the accessibility of the worlds used as labels. Some include pseudo-formulae like <span class="texhtml"><i>w</i><i>R</i><i>w</i>'</span> to denote that <span class="texhtml"><i>w</i>'</span> is accessible from <span class="texhtml"><i>w</i></span>. Some others use sequences of integers as world labels, this notation implicitly representing the accessibility relation (for example, <span class="texhtml">(1,4,2,3)</span> is accessible from <span class="texhtml">(1,4,2)</span>.)</p>
<p><a name="Set-labeling_tableaux" id="Set-labeling_tableaux"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=22" title="Edit section: Set-labeling tableaux">edit</a>]</span> <span class="mw-headline">Set-labeling tableaux</span></h3>
<p>The problem of interaction between formulae holding in different worlds can be overcome by using set-labeling tableaux. These are trees whose nodes are labeled with sets of formulae; the expansion rules tell how to attach new nodes to a leaf, based only on the label of the leaf (and not on the label of other nodes in the branch).</p>
<p>Tableaux for modal logics are used to verify the satisfiability of a set of modal formulae in a given modal logic. Given a set of formulae <span class="texhtml"><i>S</i></span>, they check the existence of a model <span class="texhtml"><i>M</i></span> and a world <span class="texhtml"><i>w</i></span> such that <img class="tex" alt="M,w \models S" src="http://upload.wikimedia.org/math/f/e/e/fee884865e2130019c310d6b785e0f27.png" />.</p>
<p>The expansion rules depend on the particular modal logic used. A tableau system for the basic modal logic <a href="/w/index.php?title=K_(modal_logic)&amp;action=edit&amp;redlink=1" class="new" title="K (modal logic) (page does not exist)">K</a> can be obtained by adding to the propositional tableau rules the following one:</p>
<dl>
<dd><img class="tex" alt="(K) \frac{\Box A_1; \ldots&#160;; \Box A_n&#160;; \neg \Box B}{A_1; \ldots&#160;; A_n&#160;; \neg B}" src="http://upload.wikimedia.org/math/e/d/2/ed2eb762c6e001d53d038dab582a6fa7.png" /></dd>
</dl>
<p>Intuitively, the precondition of this rule expresses the truth of all formulae <img class="tex" alt="A_1,\ldots,A_n" src="http://upload.wikimedia.org/math/7/d/7/7d740e0aebd91f51599843947d90fdee.png" /> at all accessible worlds, and truth of <img class="tex" alt="\neg B" src="http://upload.wikimedia.org/math/d/9/a/d9a9ce3734464ec8b2fa333bb4a87500.png" /> at some accessible worlds. The consequence of this rule is a formula that must be true at one of those worlds where <img class="tex" alt="\neg B" src="http://upload.wikimedia.org/math/d/9/a/d9a9ce3734464ec8b2fa333bb4a87500.png" /> is true.</p>
<p>More technically, modal tableaux methods check the existence of a model <span class="texhtml"><i>M</i></span> and a world <span class="texhtml"><i>w</i></span> that make set of formulae true. If <img class="tex" alt="\Box A_1; \ldots&#160;; \Box A_n&#160;; \neg \Box B" src="http://upload.wikimedia.org/math/0/f/e/0fe56bda3a7c8959e485cf6892c6190b.png" /> are true in <span class="texhtml"><i>w</i></span>, there must be a world <span class="texhtml"><i>w</i>'</span> that is accessible from <span class="texhtml"><i>w</i></span> and that makes <img class="tex" alt="A_1; \ldots&#160;; A_n&#160;; \neg B" src="http://upload.wikimedia.org/math/3/d/7/3d72b894b1dab9315d33693afc9a319f.png" /> true. This rule therefore amounts to deriving a set of formulae that must be satisfied in such <span class="texhtml"><i>w</i>'</span>.</p>
<p>While the preconditions <img class="tex" alt="\Box A_1; \ldots&#160;; \Box A_n&#160;; \neg \Box B" src="http://upload.wikimedia.org/math/0/f/e/0fe56bda3a7c8959e485cf6892c6190b.png" /> are assumed satisfied by <span class="texhtml"><i>M</i>,<i>w</i></span>, the consequences <img class="tex" alt="A_1; \ldots&#160;; A_n&#160;; \neg B" src="http://upload.wikimedia.org/math/3/d/7/3d72b894b1dab9315d33693afc9a319f.png" /> are assumed satisfied in <span class="texhtml"><i>M</i>,<i>w</i>'</span>: same model but possibly different worlds. Set-labeled tableaux do not explicitly keep track of the world where each formula is assumed true: two nodes may or may not refer to the same world. However, the formulae labeling any given node are assumed true at the same world.</p>
<p>As a result of the possibly different worlds where formulae are assumed true, a formula in a node is not automatically valid in all its descendants, as every application of the modal rule correspond to a move from a world to another one. This condition is automatically captured by set-labeling tableaux, as expansion rules are based only on the leaf where they are applied and not on its ancestors.</p>
<p>Remarkably, <span class="texhtml">(<i>K</i>)</span> does not directly extend to multiple negated boxed formulae such as in <img class="tex" alt="\Box A_1; \ldots; \Box A_n; \neg \Box B_1; \neg \Box B_2" src="http://upload.wikimedia.org/math/e/3/d/e3d5906b95e1417ee7970c7aecb7f26f.png" />: while there exists an accessible world where <span class="texhtml"><i>B</i><sub>1</sub></span> is false and one in which <span class="texhtml"><i>B</i><sub>2</sub></span> is false, these two worlds are not necessarily the same.</p>
<p>Differently from the propositional rules, <span class="texhtml">(<i>K</i>)</span> states conditions over all its preconditions. For example, it cannot be applied to a node labeled by <img class="tex" alt="a; \Box b; \Box (b \rightarrow c); \neg \Box c" src="http://upload.wikimedia.org/math/c/1/1/c11032610ff353c6e638125fe81f0e7f.png" />; while this set is inconsistent and this could be easily proved by applying <span class="texhtml">(<i>K</i>)</span>, this rule cannot be applied because of formula <span class="texhtml"><i>a</i></span>, which is not even relevant to inconsistency. Removal of such formulae is made possible by the rule:</p>
<dl>
<dd><img class="tex" alt="(\theta) \frac{A_1;\ldots;A_n;B_1;\ldots;B_m}{A_1;\ldots;A_n}" src="http://upload.wikimedia.org/math/5/0/6/5063b4680a5a4dc6eaf59876febba303.png" /></dd>
</dl>
<p>The addition of this rule (thinning rule) makes the resulting calculus non-confluent: a tableau for an inconsistent set may be impossible to close, even if a closed tableau for the same set exists.</p>
<p>Rule <span class="texhtml">(θ)</span> is non-deterministic: the set of formulae to be removed (or to be kept) can be chosen arbitrarily; this creates the problem of choosing a set of formulae to discard that is not so large it makes the resulting set satisfiable and not so small it makes the necessary expansion rules inapplicable. Having a large number of possible choices makes the problem of searching for a closed tableau harder.</p>
<p>This non-determinism can be avoided by restricting the usage of <span class="texhtml">(θ)</span> so that it is only applied before a modal expansion rule, and so that it only removes the formulae that make that other rule inapplicable. This condition can be also formulated by merging the two rules in a single one. The resulting rule produces the same result as the old one, but implicitly discard all formulae that made the old rule inapplicable. This mechanism for removing <span class="texhtml">(θ)</span> has been proved to preserve completeness for many modal logics.</p>
<p>Axiom <a href="/w/index.php?title=T_(modal_logic)&amp;action=edit&amp;redlink=1" class="new" title="T (modal logic) (page does not exist)">T</a> expresses reflexivity of the accessibility relation: every world is accessible from itself. The corresponding tableau expansion rule is:</p>
<dl>
<dd><img class="tex" alt="(T) \frac{A_1;\ldots;A_n;\Box B}{A_1;\ldots;A_n; \Box B; B}" src="http://upload.wikimedia.org/math/2/b/a/2bafe8eff43301079c1580592a555e98.png" /></dd>
</dl>
<p>This rule relates conditions over the same world: if <img class="tex" alt="\Box B" src="http://upload.wikimedia.org/math/a/f/3/af389cf88e44cd791de4ddde7e6e65ad.png" /> is true in a world, by reflexivity <span class="texhtml"><i>B</i></span> is also true <i>in the same world</i>. This rule is static, not transactional, as both its precondition and consequent refer to the same world.</p>
<p>This rule copies <img class="tex" alt="\Box B" src="http://upload.wikimedia.org/math/a/f/3/af389cf88e44cd791de4ddde7e6e65ad.png" /> from the precondition to the consequent, in spite of this formula having being "used" to generate <span class="texhtml"><i>B</i></span>. This is correct, as the considered world is the same, so <img class="tex" alt="\Box B" src="http://upload.wikimedia.org/math/a/f/3/af389cf88e44cd791de4ddde7e6e65ad.png" /> also holds there. This "copying" is necessary in some cases. It is for example necessary to prove the inconsistency of <img class="tex" alt="\Box(a \wedge \neg \Box a)" src="http://upload.wikimedia.org/math/2/4/8/248209efe21121740214e4a23b4bebc5.png" />: the only applicable rules are in order <img class="tex" alt="(T), (\wedge), (\theta), (K)" src="http://upload.wikimedia.org/math/7/5/d/75d6711e8f8e2fdb404c571ce90f4b2a.png" />, from which one is blocked if <img class="tex" alt="\Box a" src="http://upload.wikimedia.org/math/6/0/a/60aba5f0d77650ee736221582a15d87b.png" /> is not copied.</p>
<p><a name="Auxiliary_tableaux" id="Auxiliary_tableaux"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=23" title="Edit section: Auxiliary tableaux">edit</a>]</span> <span class="mw-headline">Auxiliary tableaux</span></h3>
<p>A different method for dealing with formulae holding in alternate worlds is to start a different tableau for each now world that is introduced in the tableau. For example, <img class="tex" alt="\neg \Box A" src="http://upload.wikimedia.org/math/d/7/9/d79f6da65565bb21b2e39eae890c2c5c.png" /> implies that <span class="texhtml"><i>A</i></span> is false in an accessible world, so one starts a new tableau rooted by <img class="tex" alt="\neg A" src="http://upload.wikimedia.org/math/9/1/f/91f4f5fde06448561332b0f36c5a0973.png" />. This new tableau is attached to the node of the original tableau where the expansion rule has been applied; a closure of this tableau immediately generates a closure of all branches where that node is, regardless of whether the same node is associated other auxiliary tableaux. The expansion rules for the auxiliary tableaux are the same as for the original one; therefore, an auxiliary tableau can have in turns other (sub-)auxiliary tableaux.</p>
<p><a name="Global_assumptions" id="Global_assumptions"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=24" title="Edit section: Global assumptions">edit</a>]</span> <span class="mw-headline">Global assumptions</span></h3>
<p>The above modal tableaux establish the consistency of a set of formulae, and can be used for solving the local logical consequence problem. This is the problem of telling whether, for each model <span class="texhtml"><i>M</i></span>, if <span class="texhtml"><i>A</i></span> is true in a world <span class="texhtml"><i>w</i></span>, then <span class="texhtml"><i>B</i></span> is also true in the same world. This is the same as checking whether <span class="texhtml"><i>B</i></span> is true in a world of a model, in the assumption that <span class="texhtml"><i>A</i></span> is also true in the same world of the same model.</p>
<p>A related problem is the global consequence problem, where the assumption is that a formula (or set of formulae) <span class="texhtml"><i>G</i></span> is true in all possible worlds of the model. The problem is that of checking whether, in all models <span class="texhtml"><i>M</i></span> where <span class="texhtml"><i>G</i></span> is true in all worlds, <span class="texhtml"><i>B</i></span> is also true in all worlds.</p>
<p>Local and global assumption differ on models where the assumed formula is true in some worlds but not in others. As an example, <img class="tex" alt="\{P, \neg \Box (P \wedge Q)\}" src="http://upload.wikimedia.org/math/3/3/d/33dcd6ed59d2955cd4a069138eea0463.png" /> entails <img class="tex" alt="\neg \Box Q" src="http://upload.wikimedia.org/math/5/e/d/5ed7dd199f6b6899892f2c3e021c9ccb.png" /> globally but not locally. Local entailment does not hold in a model comprised of two worlds making <span class="texhtml"><i>P</i></span> and <img class="tex" alt="\neg P, Q" src="http://upload.wikimedia.org/math/f/8/7/f87cd15545b274068fbcd3cf67f967ae.png" /> true, respectively, and where the second is accessible from the first; in the first world, the assumption is true but <img class="tex" alt="\Box Q" src="http://upload.wikimedia.org/math/2/8/6/286371aff0e1f903a52e3ee5e21c3bda.png" /> is false. This counterexample works because <span class="texhtml"><i>P</i></span> can be assumed true in a world and false in another one. If however the same assumption is considered global, <img class="tex" alt="\neg P" src="http://upload.wikimedia.org/math/f/a/c/faca3e753a7340bc7072a2020888ca51.png" /> is not allowed in any world of the model.</p>
<p>These two problems can be combined, so that one can check whether <span class="texhtml"><i>B</i></span> is a local consequence of <span class="texhtml"><i>A</i></span> under the global assumption <span class="texhtml"><i>G</i></span>. Tableaux calculi can deal with global assumption by a rule allowing its addition to every node, regardless of the world it refers to.</p>
<p><a name="Notations" id="Notations"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=25" title="Edit section: Notations">edit</a>]</span> <span class="mw-headline">Notations</span></h2>
<p>The following conventions are sometimes used.</p>
<p><a name="Uniform_notation" id="Uniform_notation"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=26" title="Edit section: Uniform notation">edit</a>]</span> <span class="mw-headline">Uniform notation</span></h3>
<p>When writing tableaux expansion rules, formulae are often denoted using a convention, so that for example <span class="texhtml">α</span> is always considered to be <img class="tex" alt="\alpha_1 \wedge \alpha_2" src="http://upload.wikimedia.org/math/d/5/5/d558b02799f4f5ed10e7fe69958aa80f.png" />. The following table provides the notation for formulae in propositional, first-order, and modal logic.</p>
<table border="1">
<tr>
<th>Notation</th>
<th colspan="3">Formulae</th>
</tr>
<tr>
<td><span class="texhtml">α</span></td>
<td><img class="tex" alt="\alpha_1 \wedge \alpha_2" src="http://upload.wikimedia.org/math/d/5/5/d558b02799f4f5ed10e7fe69958aa80f.png" /></td>
<td><img class="tex" alt="\neg (\overline{\alpha_1} \vee \overline{\alpha_2})" src="http://upload.wikimedia.org/math/0/5/a/05a1a0a85d4df7d988fd8a8736c0501b.png" /></td>
<td><img class="tex" alt="\neg (\alpha_1 \rightarrow \overline{\alpha_2})" src="http://upload.wikimedia.org/math/8/5/f/85fff1347dae7901c5dbbf27f46e49f4.png" /></td>
</tr>
<tr>
<td><span class="texhtml">β</span></td>
<td><img class="tex" alt="\beta_1 \vee \beta_2" src="http://upload.wikimedia.org/math/a/6/9/a69711b3cd79a236fa8f57f1937ba2b0.png" /></td>
<td><img class="tex" alt="\overline{\beta_1} \rightarrow \beta_2" src="http://upload.wikimedia.org/math/e/4/b/e4b1d260ad6d3d67f65b03d262c8bd5f.png" /></td>
<td><img class="tex" alt="\neg (\overline{\beta_1} \wedge \overline{\beta_2})" src="http://upload.wikimedia.org/math/8/6/9/869771a0a12071e0301ceb7f6a9c4efd.png" /></td>
</tr>
<tr>
<td><span class="texhtml">γ</span></td>
<td><img class="tex" alt="\forall x \gamma_1(x)" src="http://upload.wikimedia.org/math/0/c/3/0c3b0bb0f5d472031987be9fadd3862e.png" /></td>
<td><img class="tex" alt="\neg\exists x \overline{\gamma_1(x)}" src="http://upload.wikimedia.org/math/0/d/1/0d167d813a2aa014c2a7ddabf6e0942e.png" /></td>
</tr>
<tr>
<td><span class="texhtml">δ</span></td>
<td><img class="tex" alt="\exists x \delta_1(x)" src="http://upload.wikimedia.org/math/9/d/2/9d2f18825b972c6573aa6923d04b332c.png" /></td>
<td><img class="tex" alt="\neg\forall x \overline{\delta_1(x)}" src="http://upload.wikimedia.org/math/4/1/9/419ef4bfa5fe7d6f88db743761e27832.png" /></td>
</tr>
<tr>
<td><span class="texhtml">π</span></td>
<td><img class="tex" alt="\Box \pi_1" src="http://upload.wikimedia.org/math/2/6/7/26722cc9fe460488bca5450c33aefd36.png" /></td>
<td><img class="tex" alt="\neg\Diamond \overline{\pi_1}" src="http://upload.wikimedia.org/math/9/c/2/9c2180892de4e76c59af3c012bd93e81.png" /></td>
</tr>
<tr>
<td><span class="texhtml">υ</span></td>
<td><img class="tex" alt="\Diamond \upsilon_1" src="http://upload.wikimedia.org/math/9/7/0/970caf832e2de038498d23936b1cc6fc.png" /></td>
<td><img class="tex" alt="\neg\Box \overline{\upsilon_1}" src="http://upload.wikimedia.org/math/7/2/7/727796623851aaac472fed10cfe7c1f7.png" /></td>
</tr>
</table>
<p>Each label in the first column is taken to be either formula in the other columns. An overlined formula such as <img class="tex" alt="\overline{\alpha_1}" src="http://upload.wikimedia.org/math/d/8/e/d8e0af212f1b9d57a8045047ad60ebe9.png" /> indicates that <span class="texhtml">α<sub>1</sub></span> is the negation of whatever formula appears in its place, so that for example in formula <img class="tex" alt="\neg (a \vee b)" src="http://upload.wikimedia.org/math/6/4/3/643f681187d972d71e8bc34a15a1578e.png" /> the subformula <span class="texhtml">α<sub>1</sub></span> is the negation of <span class="texhtml"><i>a</i></span>.</p>
<p>Since every label indicates many equivalent formulae, this notation allows writing a single rule for all these equivalent formulae. For example, the conjunction expansion rule is formulated as:</p>
<dl>
<dd><img class="tex" alt="(\alpha) \frac{\alpha}{\begin{array}{c}\alpha_1\\ \alpha_2\end{array}}" src="http://upload.wikimedia.org/math/d/9/f/d9f35a909f711c674bd508dda183a301.png" /></dd>
</dl>
<p><a name="Signed_formulae" id="Signed_formulae"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=27" title="Edit section: Signed formulae">edit</a>]</span> <span class="mw-headline">Signed formulae</span></h3>
<p>A formula in a tableau is assumed true. Signed tableaux allows stating that a formula is false. This is generally achieved by adding a label to each formula, where the label <i><b>T</b></i> indicates formulae assumed true and <i><b>F</b></i> those assumed false. A different but equivalent notation is that to write formulae that are assumed true at the left of the node and formulae assumed false at its right.</p>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=28" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<ul>
<li>Bostock, David, 1997. <i>Intermediate Logic</i>. Oxford Univ. Press.</li>
<li>M D'Agostino, D Gabbay, R Haehnle, J Posegga (Eds), <i>Handbook of Tableau Methods</i>, Kluwer,1999.</li>
<li>Girle, Rod, 2000. <i>Modal Logics and Philosophy</i>. Teddington UK: Acumen.</li>
<li>Goré, Rajeev (1999) "Tableau Methods for Modal and Temporal Logics" in D'Agostino, M., Dov Gabbay, R. Haehnle, and J. Posegga, eds., <i>Handbook of Tableau Methods</i>. Kluwer: 297-396.</li>
<li><a href="/wiki/Richard_Jeffrey" title="Richard Jeffrey">Richard Jeffrey</a>, 1990 (1967). <i>Formal Logic: Its Scope and Limits</i>, 3rd ed. McGraw Hill.</li>
<li><a href="/wiki/Raymond_Smullyan" title="Raymond Smullyan">Raymond Smullyan</a>, 1995 (1968). <i>First Order-Logic</i>. Dover Publications.</li>
<li>Melvin Fitting (1996). First-order logic and automated theorem proving (2nd ed.). 	Springer-Verlag.</li>
<li>Reiner Hähnle (2001). Tableaux and Related Methods. <a href="/wiki/Handbook_of_Automated_Reasoning" title="Handbook of Automated Reasoning">Handbook of Automated Reasoning</a></li>
<li>Reinhold Letz, Gernot Stenz (2001). Model Elimination and Connection Tableau Procedures. <a href="/wiki/Handbook_of_Automated_Reasoning" title="Handbook of Automated Reasoning">Handbook of Automated Reasoning</a></li>
<li>Zeman, J. J. (1973) <i><a href="http://www.clas.ufl.edu/users/jzeman/modallogic/" class="external text" title="http://www.clas.ufl.edu/users/jzeman/modallogic/" rel="nofollow">Modal Logic.</a></i> Reidel.</li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit&amp;section=29" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://i12www.ira.uka.de/TABLEAUX/" class="external text" title="http://i12www.ira.uka.de/TABLEAUX/" rel="nofollow">TABLEAUX</a>: an annual international conference on automated reasoning with analytic tableaux and related methods.</li>
<li><a href="http://www-unix.mcs.anl.gov/JAR/" class="external text" title="http://www-unix.mcs.anl.gov/JAR/" rel="nofollow">JAR</a>: Journal of Automated Reasoning.</li>
<li><a href="http://okitsune.sourceforge.net" class="external text" title="http://okitsune.sourceforge.net" rel="nofollow">Okitsune</a>: a simple theorem prover written in Haskell that uses analytic tableaux for propositional logic.</li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 1098/1000000
Post-expand include size: 0/2048000 bytes
Template argument size: 0/2048000 bytes
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:1027229-0!1!0!default!!en!2 and timestamp 20090417001334 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Method_of_analytic_tableaux">http://en.wikipedia.org/wiki/Method_of_analytic_tableaux</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Logical_calculi" title="Category:Logical calculi">Logical calculi</a></span> | <span dir='ltr'><a href="/wiki/Category:Proof_theory" title="Category:Proof theory">Proof theory</a></span> | <span dir='ltr'><a href="/wiki/Category:Mathematical_logic" title="Category:Mathematical logic">Mathematical logic</a></span> | <span dir='ltr'><a href="/wiki/Category:Automated_theorem_proving" title="Category:Automated theorem proving">Automated theorem proving</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Method_of_analytic_tableaux" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Method_of_analytic_tableaux" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Method_of_analytic_tableaux&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Method_of_analytic_tableaux" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Method_of_analytic_tableaux" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Method_of_analytic_tableaux" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Method_of_analytic_tableaux&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Method_of_analytic_tableaux&amp;oldid=271292587" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Method_of_analytic_tableaux&amp;id=271292587">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Baumkalk%C3%BCl">Deutsch</a></li>
				<li class="interwiki-nl"><a href="http://nl.wikipedia.org/wiki/Semantisch_tableau">Nederlands</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 17 February 2009, at 06:27 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv193 in 0.043 secs. --></body></html>
