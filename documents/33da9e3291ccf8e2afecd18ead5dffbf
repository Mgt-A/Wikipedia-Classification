<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Collision detection,Articles with unsourced statements since June 2008,A priori and a posteriori (philosophy),Air traffic control,Axis-aligned bounding box,Billiards,Binary space partition,Binary space partitioning,Binary tree,Bounding volume,CSMA/CD" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Collision_detection&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Collision_detection&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Collision detection - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Collision_detection";
		var wgTitle = "Collision detection";
		var wgAction = "view";
		var wgArticleId = "171552";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 278549399;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Collision_detection skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Collision detection</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<div class="dablink">For collision detection on networks see <a href="/wiki/CSMA/CD" title="CSMA/CD" class="mw-redirect">CSMA/CD</a></div>
<p>In <a href="/wiki/Physical_simulation" title="Physical simulation" class="mw-redirect">physical simulations</a>, <a href="/wiki/Video_game" title="Video game">video games</a> and <a href="/wiki/Computational_geometry" title="Computational geometry">computational geometry</a>, <b>collision detection</b> involves algorithms for checking for <a href="/wiki/Collision" title="Collision">collision</a>, i.e. intersection, of two given solids. Simulating what happens once a collision is detected is sometimes referred to as "collision response", for which see <a href="/wiki/Physics_engine" title="Physics engine">physics engine</a> and <a href="/wiki/Ragdoll_physics" title="Ragdoll physics">ragdoll physics</a>. Collision detection algorithms are a basic component of 3D video games. Without them, characters could go through walls and other obstacles.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1"><a href="#Collision_detection_in_physical_simulation"><span class="tocnumber">2</span> <span class="toctext">Collision detection in physical simulation</span></a>
<ul>
<li class="toclevel-2"><a href="#A_posteriori_versus_a_priori"><span class="tocnumber">2.1</span> <span class="toctext">A posteriori versus a priori</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Optimization"><span class="tocnumber">3</span> <span class="toctext">Optimization</span></a>
<ul>
<li class="toclevel-2"><a href="#Exploiting_temporal_coherence"><span class="tocnumber">3.1</span> <span class="toctext">Exploiting temporal coherence</span></a></li>
<li class="toclevel-2"><a href="#Pairwise_pruning"><span class="tocnumber">3.2</span> <span class="toctext">Pairwise pruning</span></a></li>
<li class="toclevel-2"><a href="#Exact_pairwise_collision_detection"><span class="tocnumber">3.3</span> <span class="toctext">Exact pairwise collision detection</span></a></li>
<li class="toclevel-2"><a href="#A_priori_pruning"><span class="tocnumber">3.4</span> <span class="toctext">A priori pruning</span></a></li>
<li class="toclevel-2"><a href="#Spatial_partitioning"><span class="tocnumber">3.5</span> <span class="toctext">Spatial partitioning</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Video_games"><span class="tocnumber">4</span> <span class="toctext">Video games</span></a></li>
<li class="toclevel-1"><a href="#Open_Source_Collision_Detection"><span class="tocnumber">5</span> <span class="toctext">Open Source Collision Detection</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">8</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Overview" id="Overview"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a>]</span> <span class="mw-headline">Overview</span></h2>
<div class="thumb tright">
<div class="thumbinner" style="width:202px;"><a href="/wiki/File:Billiards_balls.jpg" class="image" title="Billiards balls hitting each other are a classic example applicable within the science of collision detection."><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Billiards_balls.jpg/200px-Billiards_balls.jpg" width="200" height="150" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Billiards_balls.jpg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Billiards balls hitting each other are a classic example applicable within the science of collision detection.</div>
</div>
</div>
<p>In physical simulation, we wish to conduct experiments, such as playing <a href="/wiki/Billiards" title="Billiards" class="mw-redirect">billiards</a>. The <a href="/wiki/Physics" title="Physics">physics</a> of bouncing billiard balls are well understood, under the umbrella of <a href="/wiki/Rigid_body_motion" title="Rigid body motion" class="mw-redirect">rigid body motion</a> and <a href="/wiki/Elastic_collision" title="Elastic collision">elastic collisions</a>. An initial description of the situation would be given, with a very precise physical description of the billiard table and balls, as well as initial positions of all the balls. Given a certain impulsion on the cue ball (probably resulting from a player hitting the ball with his cue stick), we want to calculate the trajectories, precise motion, and eventual resting places of all the balls with a <a href="/wiki/Computer_program" title="Computer program">computer program</a>. A program to simulate this game would consist of several portions, one of which would be responsible for calculating the precise impacts between the billiard balls. This particular example also turns out to be <a href="/wiki/Numerical_stability" title="Numerical stability">numerically unstable</a>: a small error in any calculation will cause drastic changes in the final position of the billiard balls.</p>
<p>Video games have similar requirements, with some crucial differences. While physical simulation needs to simulate real-world physics as precisely as possible, video games need to simulate real-world physics in an <i>acceptable</i> way, in <a href="/wiki/Real-time_computing" title="Real-time computing">real time</a> and robustly. Compromises are allowed, so long as the resulting simulation is satisfying to the game player.</p>
<p><a name="Collision_detection_in_physical_simulation" id="Collision_detection_in_physical_simulation"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=2" title="Edit section: Collision detection in physical simulation">edit</a>]</span> <span class="mw-headline">Collision detection in physical simulation</span></h2>
<p>Physical simulators differ in the way they react on a collision. Some use the softness of the material to calculate a force, which will resolve the collision in the following time steps like it is in reality. Due to the low softness of some materials this is very CPU intensive. Some simulators estimate the time of collision by linear interpolation, <a href="/wiki/Rollback_(data_management)" title="Rollback (data management)">roll back</a> the simulation, and calculate the collision by the more abstract methods of <a href="/wiki/Conservation_laws" title="Conservation laws" class="mw-redirect">conservation laws</a>.</p>
<p>Some iterate the linear interpolation (<a href="/wiki/Newton%27s_method" title="Newton's method">Newton's method</a>) to calculate the time of collision with a much higher precision than the rest of the simulation. Collision detection utilizes time coherence to allow ever finer time steps without much increasing CPU demand, such as in <a href="/wiki/Air_traffic_control" title="Air traffic control">air traffic control</a>.</p>
<p>After an inelastic collision, special states of sliding and resting can occur and, for example, the <a href="/wiki/Open_Dynamics_Engine" title="Open Dynamics Engine">Open Dynamics Engine</a> uses constrains to simulate them. Constrains avoid inertia and thus instability. Implementation of rest by means of a <a href="/wiki/Scene_graph" title="Scene graph">scene graph</a> avoids drift.</p>
<p>In other words, physical simulators usually function one of two ways, where the collision is detected <a href="/wiki/A_priori_and_a_posteriori_(philosophy)" title="A priori and a posteriori (philosophy)" class="mw-redirect"><i>a posteriori</i></a> (after the collision occurs) or <a href="/wiki/A_priori_and_a_posteriori_(philosophy)" title="A priori and a posteriori (philosophy)" class="mw-redirect"><i>a priori</i></a> (before the collision occurs). In addition to the <i>a posteriori</i> and <i>a priori</i> distinction, almost all modern collision detection algorithms are broken into a hierarchy of algorithms.</p>
<p><a name="A_posteriori_versus_a_priori" id="A_posteriori_versus_a_priori"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=3" title="Edit section: A posteriori versus a priori">edit</a>]</span> <span class="mw-headline">A posteriori versus a priori</span></h3>
<p>In the <i>a posteriori</i> case, we advance the physical simulation by a small time step, then check if any objects are intersecting, or are somehow so close to each other that we deem them to be intersecting. At each simulation step, a list of all intersecting bodies is created, and the positions and trajectories of these objects are somehow "fixed" to account for the collision. We say that this method is <i>a posteriori</i> because we typically miss the actual instant of collision, and only catch the collision after it has actually happened.</p>
<p>In the <i>a priori</i> methods, we write a collision detection algorithm which will be able to predict very precisely the trajectories of the physical bodies. The instants of collision are calculated with high precision, and the physical bodies never actually interpenetrate. We call this <i>a priori</i> because we calculate the instants of collision before we update the configuration of the physical bodies.</p>
<p>The main benefits of the <i>a posteriori</i> methods are as follows. In this case, the collision detection algorithm need not be aware of the myriad physical variables; a simple list of physical bodies is fed to the algorithm, and the program returns a list of intersecting bodies. The collision detection algorithm doesn't need to understand friction, elastic collisions, or worse, nonelastic collisions and deformable bodies. In addition, the <i>a posteriori</i> algorithms are in effect one dimension simpler than the <i>a priori</i> algorithms. Indeed, an <i>a priori</i> algorithm must deal with the time variable, which is absent from the <i>a posteriori</i> problem.</p>
<p>On the other hand, <i>a posteriori</i> algorithms cause problems in the "fixing" step, where intersections (which aren't physically correct) need to be corrected.</p>
<p>The benefits of the <i>a priori</i> algorithms are increased fidelity and stability. It is difficult (but not completely impossible) to separate the physical simulation from the collision detection algorithm. However, in all but the simplest cases, the problem of determining ahead of time when two bodies will collide (given some initial data) has no closed form solution -- a numerical <a href="/wiki/Root-finding_algorithm" title="Root-finding algorithm">root finder</a> is usually involved.</p>
<p>Some objects are in <i>resting contact</i>, that is, in collision, but neither bouncing off, nor interpenetrating, such as a vase resting on a table. In all cases, resting contact requires special treatment: If two objects collide (<i>a posteriori</i>) or slide (<i>a priori</i>) and their relative motion is below a threshold, friction becomes <a href="/wiki/Stiction" title="Stiction">stiction</a> and both objects are arranged in the same branch of the <a href="/wiki/Scene_graph" title="Scene graph">scene graph</a>.</p>
<p><a name="Optimization" id="Optimization"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=4" title="Edit section: Optimization">edit</a>]</span> <span class="mw-headline">Optimization</span></h2>
<p>The obvious approaches to collision detection for multiple objects are very slow. Checking every object against every other object will, of course, work, but is too inefficient to be used when the number of objects is at all large. Checking objects with complex geometry against each other in the obvious way, by checking each face against each other face, is itself quite slow. Thus, considerable research has been applied to speeding up the problem.</p>
<p><a name="Exploiting_temporal_coherence" id="Exploiting_temporal_coherence"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=5" title="Edit section: Exploiting temporal coherence">edit</a>]</span> <span class="mw-headline">Exploiting temporal coherence</span></h3>
<p>In many applications, the configuration of physical bodies from one time step to the next changes very little. Many of the objects may not move at all. Algorithms have been designed so that the calculations done in a preceding time step can be reused in the current time step, resulting in faster algorithms.</p>
<p>At the coarse level of collision detection, the objective is to find pairs of objects which might potentially intersect. Those pairs will require further analysis. An early high performance algorithm for this was developed by M. C. Lin at U.C. Berkley <a href="http://www.cs.berkeley.edu/~jfc/mirtich/collDet.html" class="external autonumber" title="http://www.cs.berkeley.edu/~jfc/mirtich/collDet.html" rel="nofollow">[1]</a>, who suggested using <a href="/wiki/Axis-aligned_bounding_box" title="Axis-aligned bounding box" class="mw-redirect">axis-aligned bounding boxes</a> for all n bodies in the scene.</p>
<p>Each box is represented by the product of three intervals (i.e., a box would be <img class="tex" alt="I_1 \times I_2 \times I_3=[a_1,b_1] \times [a_2,b_2] \times [a_3,b_3]" src="http://upload.wikimedia.org/math/1/f/3/1f371e2f64c44695e65b9c0c22f1c682.png" />.) A common algorithm for collision detection of bounding boxes is <a href="/wiki/Sweep_and_prune" title="Sweep and prune">sweep and prune</a>. We observe that two such boxes, <img class="tex" alt="I_1 \times I_2 \times I_3" src="http://upload.wikimedia.org/math/2/b/d/2bd2da79778a74d1869d3a6a3b58eaa0.png" /> and <img class="tex" alt="J_1 \times J_2 \times J_3" src="http://upload.wikimedia.org/math/2/9/d/29d807c3dca041bdc0d0927d8e07ef32.png" /> intersect if, and only if, <span class="texhtml"><i>I</i><sub>1</sub></span> intersects <span class="texhtml"><i>J</i><sub>1</sub></span>, <span class="texhtml"><i>I</i><sub>2</sub></span> intersects <span class="texhtml"><i>J</i><sub>2</sub></span> and <span class="texhtml"><i>I</i><sub>3</sub></span> intersects <span class="texhtml"><i>J</i><sub>3</sub></span>. We suppose that, from one time step to the next, <span class="texhtml"><i>I</i><sub><i>k</i></sub></span> and <span class="texhtml"><i>J</i><sub><i>k</i></sub></span> intersect, then it is very likely that at the next time step, they will still intersect. Likewise, if they did not intersect in the previous time step, then they are very likely to continue not to.</p>
<p>So we reduce the problem to that of tracking, from frame to frame, which intervals do intersect. We have three lists of intervals (one for each axis) and all lists are the same length (since each list has length <span class="texhtml"><i>n</i></span>, the number of bounding boxes.) In each list, each interval is allowed to intersect all other intervals in the list. So for each list, we will have an <img class="tex" alt="n \times n" src="http://upload.wikimedia.org/math/6/0/7/607acaa73c762411b20745149a11e90b.png" /> <a href="/wiki/Matrix_(math)" title="Matrix (math)" class="mw-redirect">matrix</a> <span class="texhtml"><i>M</i> = (<i>m</i><sub><i>i</i><i>j</i></sub>)</span> of zeroes and ones: <span class="texhtml"><i>m</i><sub><i>i</i><i>j</i></sub></span> is 1 if intervals <span class="texhtml"><i>i</i></span> and <span class="texhtml"><i>j</i></span> intersect, and 0 if they do not intersect.</p>
<p>By our assumption, the matrix <span class="texhtml"><i>M</i></span> associated to a list of intervals will remain essentially unchanged from one time step to the next. To exploit this, the list of intervals is actually maintained as a list of labeled endpoints. Each element of the list has the coordinate of an endpoint of an interval, as well as a unique integer identifying that interval. Then, we <a href="/wiki/Sorting_algorithm" title="Sorting algorithm">sort</a> the list by coordinates, and update the matrix <span class="texhtml"><i>M</i></span> as we go. It's not so hard to believe that this algorithm will work relatively quickly if indeed the configuration of bounding boxes does not change significantly from one time step to the next.</p>
<p>In the case of deformable bodies such as cloth simulation, it may not be possible to use a more specific pairwise pruning algorithm as discussed below, and an <i>n</i>-body pruning algorithm is the best that can be done.</p>
<p>If an upper bound can be placed on the velocity of the physical bodies in a scene, then pairs of objects can be pruned based on their initial distance and the size of the time step.</p>
<p><a name="Pairwise_pruning" id="Pairwise_pruning"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=6" title="Edit section: Pairwise pruning">edit</a>]</span> <span class="mw-headline">Pairwise pruning</span></h3>
<p>Once we've selected a pair of physical bodies for further investigation, we need to check for collisions more carefully. However, in many applications, individual objects (if they are not too deformable) are described by a set of smaller primitives, mainly triangles. So now, we have two sets of triangles, <img class="tex" alt="S={S_1,S_2,\dots,S_n}" src="http://upload.wikimedia.org/math/b/1/5/b150f86ec8067e3bff0c182258256c37.png" /> and <img class="tex" alt="T={T_1,T_2,\dots,T_n}" src="http://upload.wikimedia.org/math/f/8/2/f82aabbf434b2ba44f156e032b739562.png" /> (for simplicity, we will assume that each set has the same number of triangles.)</p>
<p>The obvious thing to do is to check all triangles <span class="texhtml"><i>S</i><sub><i>j</i></sub></span> against all triangles <span class="texhtml"><i>T</i><sub><i>k</i></sub></span> for collisions, but this involves <span class="texhtml"><i>n</i><sup>2</sup></span> comparisons, which is highly inefficient. If possible, it is desirable to use a pruning algorithm to reduce the number of pairs of triangles we need to check.</p>
<p>The most widely used family of algorithms is known as the <i>hierarchical bounding volumes</i> method. As a preprocessing step, for each object (in our example, <span class="texhtml"><i>S</i></span> and <span class="texhtml"><i>T</i></span>) we will calculate a hierarchy of bounding volumes. Then, at each time step, when we need to check for collisions between <span class="texhtml"><i>S</i></span> and <span class="texhtml"><i>T</i></span>, the hierarchical bounding volumes are used to reduce the number of pairs of triangles under consideration. For the sake of simplicity, we will give an example using bounding spheres, although it has been noted that spheres are undesirable in many cases.<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since June 2008" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup></p>
<p>If <span class="texhtml"><i>E</i></span> is a set of triangles, we can precalculate a bounding sphere <span class="texhtml"><i>B</i>(<i>E</i>)</span>. There are many ways of choosing <span class="texhtml"><i>B</i>(<i>E</i>)</span>, we only assume that <span class="texhtml"><i>B</i>(<i>E</i>)</span> is a sphere that completely contains <span class="texhtml"><i>E</i></span> and is as small as possible.</p>
<p>Ahead of time, we can compute <span class="texhtml"><i>B</i>(<i>S</i>)</span> and <span class="texhtml"><i>B</i>(<i>T</i>)</span>. Clearly, if these two spheres do not intersect (and that is very easy to test,) then neither do <span class="texhtml"><i>S</i></span> and <span class="texhtml"><i>T</i></span>. This is not much better than an <i>n</i>-body pruning algorithm, however.</p>
<p>If <img class="tex" alt="E={E_1,E_2,\dots,E_m}" src="http://upload.wikimedia.org/math/4/a/5/4a5f9e8499dc0a3907fc05b75ec01609.png" /> is a set of triangles, then we can split it into two halves <img class="tex" alt="L(E):={E_1,E_2,\dots,E_{m/2}}" src="http://upload.wikimedia.org/math/4/e/d/4ed433aa71ab0b41dee53ea50e57ed06.png" /> and <img class="tex" alt="R(E):={E_{m/2+1},\dots,E_{m-1},E_m}" src="http://upload.wikimedia.org/math/3/0/7/3079eae29bfea791f1b60a4b690ecd75.png" />. We can do this to <span class="texhtml"><i>S</i></span> and <span class="texhtml"><i>T</i></span>, and we can calculate (ahead of time) the bounding spheres <span class="texhtml"><i>B</i>(<i>L</i>(<i>S</i>)),<i>B</i>(<i>R</i>(<i>S</i>))</span> and <span class="texhtml"><i>B</i>(<i>L</i>(<i>T</i>)),<i>B</i>(<i>R</i>(<i>T</i>))</span>. The hope here is that these bounding spheres are much smaller than <span class="texhtml"><i>B</i>(<i>S</i>)</span> and <span class="texhtml"><i>B</i>(<i>T</i>)</span>. And, if, for instance, <span class="texhtml"><i>B</i>(<i>S</i>)</span> and <span class="texhtml"><i>B</i>(<i>L</i>(<i>T</i>))</span> do not intersect, then there is no sense in checking any triangle in <span class="texhtml"><i>S</i></span> against any triangle in <span class="texhtml"><i>L</i>(<i>T</i>)</span>.</p>
<p>As a precomputation, we can take each physical body (represented by a set of triangles) and recursively decompose it into a <a href="/wiki/Binary_tree" title="Binary tree">binary tree</a>, where each node <span class="texhtml"><i>N</i></span> represents a set of triangles, and its two children represent <span class="texhtml"><i>L</i>(<i>N</i>)</span> and <span class="texhtml"><i>R</i>(<i>N</i>)</span>. At each node in the tree, as a we can precompute the bounding sphere <span class="texhtml"><i>B</i>(<i>N</i>)</span>.</p>
<p>When the time comes for testing a pair of objects for collision, their bounding sphere tree can be used to eliminate many pairs of triangles.</p>
<p>Many variants of the algorithms are obtained by choosing something other than a sphere for <span class="texhtml"><i>B</i>(<i>T</i>)</span>. If one chooses <a href="/wiki/Axis-aligned_bounding_box" title="Axis-aligned bounding box" class="mw-redirect">axis-aligned bounding boxes</a>, one gets AABBTrees. <a href="/wiki/Oriented_bounding_box" title="Oriented bounding box" class="mw-redirect">Oriented bounding box</a> trees are called OBBTrees. Some trees are easier to update if the underlying object changes. Some trees can accommodate higher order primitives such as <a href="/wiki/Spline_(mathematics)" title="Spline (mathematics)">splines</a> instead of simple triangles.</p>
<p><a name="Exact_pairwise_collision_detection" id="Exact_pairwise_collision_detection"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=7" title="Edit section: Exact pairwise collision detection">edit</a>]</span> <span class="mw-headline">Exact pairwise collision detection</span></h3>
<p>Once we're done pruning, we are left with a number of candidate pairs to check for exact collision detection.</p>
<p>A basic observation is that for any two <a href="/wiki/Convex_set" title="Convex set">convex</a> objects which are disjoint, one can find a plane in space so that one object lies completely on one side of that plane, and the other object lies on the opposite side of that plane. This allows the development of very fast collision detection algorithms for convex objects.</p>
<p>Early work in this area involved "<a href="/wiki/Separating_axis_theorem" title="Separating axis theorem">separating plane</a>" methods. Two triangles collide essentially only when they can not be separated by a plane going through three vertices. That is, if the triangles are <span class="texhtml"><i>v</i><sub>1</sub>,<i>v</i><sub>2</sub>,<i>v</i><sub>3</sub></span> and <span class="texhtml"><i>v</i><sub>4</sub>,<i>v</i><sub>5</sub>,<i>v</i><sub>6</sub></span> where each <span class="texhtml"><i>v</i><sub><i>j</i></sub></span> is a vector in <img class="tex" alt="\Bbb R^3" src="http://upload.wikimedia.org/math/c/3/5/c35ed5f43a2953196b55e5207a2c959e.png" />, then we can take three vertices, <span class="texhtml"><i>v</i><sub><i>i</i></sub>,<i>v</i><sub><i>j</i></sub>,<i>v</i><sub><i>k</i></sub></span>, find a plane going through all three vertices, and check to see if this is a separating plane. If any such plane is a separating plane, then the triangles are deemed to be disjoint. On the other hand, if none of these planes are separating planes, then the triangles are deemed to intersect. There are twenty such planes.</p>
<p>If the triangles are coplanar, this test is not entirely successful. One can either add some extra planes, for instance, planes that are normal to triangle edges, to fix the problem entirely. In other cases, objects that meet at a flat face must necessarily also meet at an angle elsewhere, hence the overall collision detection will be able to find the collision.</p>
<p>Better methods have since been developed. Very fast algorithms are available for finding the closest points on the surface of two convex polyhedral objects. Early work by M. C. Lin <sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup> used a variation on the <a href="/wiki/Simplex_algorithm" title="Simplex algorithm">simplex algorithm</a> from <a href="/wiki/Linear_programming" title="Linear programming">linear programming</a>. The <a href="/wiki/Gilbert-Johnson-Keerthi_distance_algorithm" title="Gilbert-Johnson-Keerthi distance algorithm" class="mw-redirect">Gilbert-Johnson-Keerthi distance algorithm</a> has superseded that approach. These algorithms approach constant time when applied repeatedly to pairs of stationary or slow-moving objects, when used with starting points from the previous collision check.</p>
<p>The end result of all this algorithmic work is that collision detection can be done efficiently for thousands of moving objects in real time on typical personal computers and game consoles.</p>
<p><a name="A_priori_pruning" id="A_priori_pruning"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=8" title="Edit section: A priori pruning">edit</a>]</span> <span class="mw-headline">A priori pruning</span></h3>
<p>Where most of the objects involved are fixed, as is typical of video games, a priori methods using precomputation can be used to speed up execution.</p>
<p>Pruning is also desirable here, both <i>n</i>-body pruning and pairwise pruning, but the algorithms must take time and the types of motions used in the underlying physical system into consideration.</p>
<p>When it comes to the exact pairwise collision detection, this is highly trajectory dependent, and one almost has to use a numerical <a href="/wiki/Root-finding_algorithm" title="Root-finding algorithm">root-finding algorithm</a> to compute the instant of impact.</p>
<p>As an example, consider two triangles moving in time <span class="texhtml"><i>v</i><sub>1</sub>(<i>t</i>),<i>v</i><sub>2</sub>(<i>t</i>),<i>v</i><sub>3</sub>(<i>t</i>)</span> and <span class="texhtml"><i>v</i><sub>4</sub>(<i>t</i>),<i>v</i><sub>5</sub>(<i>t</i>),<i>v</i><sub>6</sub>(<i>t</i>)</span>. At any point in time, the two triangles can be checked for intersection using the twenty planes previously mentioned. However, we can do better, since these twenty planes can all be tracked in time. If <span class="texhtml"><i>P</i>(<i>u</i>,<i>v</i>,<i>w</i>)</span> is the plane going through points <span class="texhtml"><i>u</i>,<i>v</i>,<i>w</i></span> in <img class="tex" alt="\Bbb R^3" src="http://upload.wikimedia.org/math/c/3/5/c35ed5f43a2953196b55e5207a2c959e.png" /> then there are twenty planes <span class="texhtml"><i>P</i>(<i>v</i><sub><i>i</i></sub>(<i>t</i>),<i>v</i><sub><i>j</i></sub>(<i>t</i>),<i>v</i><sub><i>k</i></sub>(<i>t</i>))</span> to track. Each plane needs to be tracked against three vertices, this gives sixty values to track. Using a root finder on these sixty functions produces the exact collision times for the two given triangles and the two given trajectory. We note here that if the trajectories of the vertices are assumed to be linear polynomials in <span class="texhtml"><i>t</i></span> then the final sixty functions are in fact cubic polynomials, and in this exceptional case, it is possible to locate the exact collision time using the formula for the roots of the cubic. Some numerical analysts suggest that using the formula for the roots of the cubic is not as numerically stable as using a root finder for polynomials.<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since June 2008" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup></p>
<p><a name="Spatial_partitioning" id="Spatial_partitioning"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=9" title="Edit section: Spatial partitioning">edit</a>]</span> <span class="mw-headline">Spatial partitioning</span></h3>
<p>Alternative algorithms are grouped under the <a href="/wiki/Spatial_partitioning" title="Spatial partitioning" class="mw-redirect">spatial partitioning</a> umbrella, which includes <a href="/wiki/Octree" title="Octree">octrees</a>, <a href="/wiki/Binary_space_partitioning" title="Binary space partitioning">binary space partitioning</a> (or BSP trees) and other, similar approaches. If one splits space into a number of simple cells, and if two objects can be shown not to be in the same cell, then they need not be checked for intersection. Since BSP trees can be precomputed, that approach is well suited to handling walls and fixed obstacles in games. These algorithms are generally older than the algorithms described above.</p>
<p><a name="Video_games" id="Video_games"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=10" title="Edit section: Video games">edit</a>]</span> <span class="mw-headline">Video games</span></h2>
<p>Video games have to split their very limited computing time between several tasks. Despite this resource limit, and the use of relatively primitive collision detection algorithms, programmers have been able to create believeable, if inexact, systems for use in games.</p>
<p>For a long time, video games had a very limited number of objects to treat, and so checking all pairs was not a problem. In two-dimensional games, in some cases, the hardware was able to efficiently detect and report overlapping pixels between <a href="/wiki/Sprite_(computer_graphics)" title="Sprite (computer graphics)">sprites</a> on the screen. In other cases, simply tiling the screen and binding each <i>sprite</i> into the tiles it overlaps provides sufficient pruning, and for pairwise checks, bounding rectangles or circles are used and deemed sufficiently accurate.</p>
<p>Three dimensional games have used spatial partitioning methods for <span class="texhtml"><i>n</i></span>-body pruning, and for a long time used one or a few spheres per actual 3D object for pairwise checks. Exact checks are very rare, except in games attempting to <a href="/wiki/Simulation_game" title="Simulation game" class="mw-redirect">simulate</a> reality closely. Even then, exact checks are not necessarily used in all cases.</p>
<p>Because games use simplified physics, stability is not as much of an issue.<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since June 2008" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup> Almost all games use <i>a posteriori</i> collision detection, and collisions are often resolved using very simple rules. For instance, if a character becomes embedded in a wall, he might be simply moved back to his last known good location. Some games will calculate the distance the character can move before getting embedded into a wall, and only allow him to move that far.</p>
<p>A slightly more sophisticated and striking effect is <a href="/wiki/Ragdoll_physics" title="Ragdoll physics">ragdoll physics</a>. If a video game character is disabled, instead of playing a preset animation, a simplified skeleton of the character is animated as if it were a rag doll. This rag doll falls limp, and might collide with itself and the environment, in which case it should behave appropriately.</p>
<p>In many cases for video games, approximating the characters by a point is sufficient for the purpose of collision detection with the environment. In this case, <a href="/wiki/Binary_space_partition" title="Binary space partition" class="mw-redirect">Binary space partitioning</a> trees provide a viable, efficient and simple algorithm for checking if a point is embedded in the scenery or not. Such a data structure can also be used to handle "resting position" situation gracefully when a character is running along the ground. Collisions between characters, and collisions with projectiles and hazards, are treated separately.</p>
<p>A robust simulator is one that will react to any input in a reasonable way. For instance, if we imagine a high speed <a href="/wiki/Racing_game" title="Racing game">racecar video game</a>, from one simulation step to the next, it is conceivable that the cars would advance a substantial distance along the race track. If there is a shallow obstacle on the track (such as a brick wall), it is not entirely unlikely that the car will completely leap over it, and this is very undesirable. In other instances, the "fixing" that the a posteriori algorithms require isn't implemented correctly, and characters find themselves embedded in walls, or falling off into a deep black void. These are the hallmarks of a mediocre collision detection and physical simulation system.</p>
<p><a name="Open_Source_Collision_Detection" id="Open_Source_Collision_Detection"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=11" title="Edit section: Open Source Collision Detection">edit</a>]</span> <span class="mw-headline">Open Source Collision Detection</span></h2>
<ul>
<li><a href="http://code.google.com/p/gjkd/" class="external text" title="http://code.google.com/p/gjkd/" rel="nofollow">GJKD</a> A 2D implementation of the Gilbert-Johnson-Keerthi (GJK) algorithm, written in D.</li>
<li><a href="http://code.google.com/p/mpr2d/" class="external text" title="http://code.google.com/p/mpr2d/" rel="nofollow">MPR2D</a> A 2D implementation of the Minkowski Portal Refinement (MPR) Algorithm, written in D.</li>
</ul>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=12" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> <cite style="font-style:normal" class="" id="CITEREFLin.2C_Ming_C1993">Lin, Ming C (1993). <i><a href="ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/COLLISION/thesis.pdf" class="external text" title="ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/COLLISION/thesis.pdf" rel="nofollow">Efficient Collision Detection for Animation and Robotics (thesis)</a></i>. University of California, Berkeley<span class="printonly">. <a href="ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/COLLISION/thesis.pdf" class="external free" title="ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/COLLISION/thesis.pdf" rel="nofollow">ftp://ftp.cs.unc.edu/pub/users/manocha/PAPERS/COLLISION/thesis.pdf</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Efficient+Collision+Detection+for+Animation+and+Robotics+%28thesis%29&amp;rft.aulast=Lin%2C+Ming+C&amp;rft.au=Lin%2C+Ming+C&amp;rft.date=1993&amp;rft.pub=University+of+California%2C+Berkeley&amp;rft_id=ftp%3A%2F%2Fftp.cs.unc.edu%2Fpub%2Fusers%2Fmanocha%2FPAPERS%2FCOLLISION%2Fthesis.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Collision_detection"><span style="display: none;">&#160;</span></span></li>
</ol>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=13" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/Bounding_volume" title="Bounding volume">Bounding volume</a></li>
<li><a href="/wiki/Game_physics" title="Game physics">Game physics</a></li>
<li><a href="/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm" title="Gilbert–Johnson–Keerthi distance algorithm">Gilbert–Johnson–Keerthi distance algorithm</a></li>
<li><a href="/wiki/Physics_engine" title="Physics engine">Physics engine</a></li>
<li><a href="/wiki/Ragdoll_physics" title="Ragdoll physics">Ragdoll physics</a></li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Collision_detection&amp;action=edit&amp;section=14" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://www.cs.unc.edu/~geom/collide/" class="external text" title="http://www.cs.unc.edu/~geom/collide/" rel="nofollow">University of California, Berkeley collision detection research web site</a></li>
<li><a href="http://web.comlab.ox.ac.uk/oucl/work/stephen.cameron/distances/" class="external text" title="http://web.comlab.ox.ac.uk/oucl/work/stephen.cameron/distances/" rel="nofollow">Prof. Steven Cameron (Oxford University) web site on collision detection</a></li>
<li><a href="http://demonstrations.wolfram.com/HowToAvoidACollision/" class="external text" title="http://demonstrations.wolfram.com/HowToAvoidACollision/" rel="nofollow">How to Avoid a Collision</a> by George Beck, <a href="/wiki/Wolfram_Demonstrations_Project" title="Wolfram Demonstrations Project">Wolfram Demonstrations Project</a>.</li>
<li><a href="http://3dcodingtutorial.com/Collision-Detection/Collision-Boxes.html" class="external text" title="http://3dcodingtutorial.com/Collision-Detection/Collision-Boxes.html" rel="nofollow">Basic collision detection in OpenGL</a>.</li>
<li><a href="http://www.kineocam.com/kcd.php" class="external text" title="http://www.kineocam.com/kcd.php" rel="nofollow">C++ collision detection library for large models</a>.</li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 926/1000000
Post-expand include size: 7029/2048000 bytes
Template argument size: 2467/2048000 bytes
Expensive parser function count: 3/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:171552-0!1!0!default!!en!2 and timestamp 20090403235256 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Collision_detection">http://en.wikipedia.org/wiki/Collision_detection</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Computational_physics" title="Category:Computational physics">Computational physics</a></span> | <span dir='ltr'><a href="/wiki/Category:Video_game_design" title="Category:Video game design">Video game design</a></span> | <span dir='ltr'><a href="/wiki/Category:Computer_graphics" title="Category:Computer graphics">Computer graphics</a></span> | <span dir='ltr'><a href="/wiki/Category:Computer_physics_engines" title="Category:Computer physics engines">Computer physics engines</a></span></div><div id="mw-hidden-catlinks" class="mw-hidden-cats-hidden">Hidden categories:&#32;<span dir='ltr'><a href="/wiki/Category:All_articles_with_unsourced_statements" title="Category:All articles with unsourced statements">All articles with unsourced statements</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_unsourced_statements_since_June_2008" title="Category:Articles with unsourced statements since June 2008">Articles with unsourced statements since June 2008</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Collision_detection" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Collision_detection" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Collision_detection&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Collision_detection&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Collision_detection" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Collision_detection" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Collision_detection" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Collision_detection&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Collision_detection&amp;oldid=278549399" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Collision_detection&amp;id=278549399">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Kollisionserkennung_(Algorithmische_Geometrie)">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Detecci%C3%B3n_de_colisiones">Español</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/D%C3%A9tection_de_collision">Français</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E5%BD%93%E3%81%9F%E3%82%8A%E5%88%A4%E5%AE%9A">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Wykrywanie_kolizji">Polski</a></li>
				<li class="interwiki-simple"><a href="http://simple.wikipedia.org/wiki/Collision_detection">Simple English</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 20 March 2009, at 15:44.</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv183 in 0.064 secs. --></body></html>
