<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Binary search tree,Data structures,AVL tree,Array,Associative array,Asymptotically optimal,B-tree,Balanced tree,Big-O notation,Big O notation,Binary Tree" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Binary_search_tree&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Binary_search_tree&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Binary search tree - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Binary_search_tree";
		var wgTitle = "Binary search tree";
		var wgAction = "view";
		var wgArticleId = "4320";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 279995292;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
<style type="text/css">/*<![CDATA[*/
.source-python {line-height: normal;}
.source-python li, .source-python pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for python
 * CSS class: source-python, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-python .de1, .source-python .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-python  {}
.source-python .head {}
.source-python .foot {}
.source-python .imp {font-weight: bold; color: red;}
.source-python .ln-xtra {color: #cc0; background-color: #ffc;}
.source-python li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-python li.li2 {font-weight: bold;}
.source-python .kw1 {color: #ff7700;font-weight:bold;}
.source-python .kw2 {color: #008000;}
.source-python .kw3 {color: #dc143c;}
.source-python .kw4 {color: #0000cd;}
.source-python .co1 {color: #808080; font-style: italic;}
.source-python .coMULTI {color: #808080; font-style: italic;}
.source-python .es0 {color: #000099; font-weight: bold;}
.source-python .br0 {color: #66cc66;}
.source-python .st0 {color: #483d8b;}
.source-python .nu0 {color: #ff4500;}
.source-python .me1 {color: black;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-cpp .de1, .source-cpp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-cpp  {}
.source-cpp .head {}
.source-cpp .foot {}
.source-cpp .imp {font-weight: bold; color: red;}
.source-cpp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-cpp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-cpp li.li2 {font-weight: bold;}
.source-cpp .kw1 {color: #0000ff;}
.source-cpp .kw2 {color: #0000ff;}
.source-cpp .kw3 {color: #0000dd;}
.source-cpp .kw4 {color: #0000ff;}
.source-cpp .co1 {color: #ff0000;}
.source-cpp .co2 {color: #339900;}
.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.source-cpp .es0 {color: #666666; font-weight: bold;}
.source-cpp .br0 {color: #000000;}
.source-cpp .st0 {color: #666666;}
.source-cpp .nu0 {color: #0000dd;}
.source-cpp .me1 {color: #00eeff;}
.source-cpp .me2 {color: #00eeff;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
</style>		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Binary_search_tree skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Binary search tree</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<div class="thumb tright">
<div class="thumbinner" style="width:202px;"><a href="/wiki/File:Binary_search_tree.svg" class="image" title="A binary search tree of size 9 and depth 3, with root 8 and leaves 1, 4, 7 and 13"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/200px-Binary_search_tree.svg.png" width="200" height="167" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Binary_search_tree.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
A binary search tree of size 9 and depth 3, with root 8 and leaves 1, 4, 7 and 13</div>
</div>
</div>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, a <b>binary search tree</b> (<b>BST</b>) is a <a href="/wiki/Binary_tree" title="Binary tree">binary tree</a> <a href="/wiki/Data_structure" title="Data structure">data structure</a> which has the following properties:</p>
<ul>
<li>Each node (item in the tree) has a distinct value.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
<li>The left <a href="/wiki/Tree_(data_structure)#subtrees" title="Tree (data structure)">subtree</a> of a node contains only values less than the node's value.</li>
<li>The right subtree of a node contains only values greater than the node's value.</li>
</ul>
<p>The major advantage of binary search trees over other data structures is that the related <a href="/wiki/Sorting_algorithm" title="Sorting algorithm">sorting algorithms</a> and <a href="/wiki/Search_algorithm" title="Search algorithm">search algorithms</a> such as <a href="/wiki/In-order_traversal" title="In-order traversal" class="mw-redirect">in-order traversal</a> can be very efficient.</p>
<p>Binary search trees can choose to allow or disallow duplicate values, depending on the implementation.</p>
<p>Binary search trees are a fundamental <a href="/wiki/Data_structure" title="Data structure">data structure</a> used to construct more abstract data structures such as <a href="/wiki/Set_(computer_science)" title="Set (computer science)">sets</a>, <a href="/wiki/Multiset" title="Multiset">multisets</a>, and <a href="/wiki/Associative_array" title="Associative array">associative arrays</a>.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Operations"><span class="tocnumber">1</span> <span class="toctext">Operations</span></a>
<ul>
<li class="toclevel-2"><a href="#Searching"><span class="tocnumber">1.1</span> <span class="toctext">Searching</span></a></li>
<li class="toclevel-2"><a href="#Insertion"><span class="tocnumber">1.2</span> <span class="toctext">Insertion</span></a></li>
<li class="toclevel-2"><a href="#Deletion"><span class="tocnumber">1.3</span> <span class="toctext">Deletion</span></a></li>
<li class="toclevel-2"><a href="#Traversal"><span class="tocnumber">1.4</span> <span class="toctext">Traversal</span></a></li>
<li class="toclevel-2"><a href="#Sort"><span class="tocnumber">1.5</span> <span class="toctext">Sort</span></a></li>
<li class="toclevel-2"><a href="#Example_for_a_Binary_Search_Tree_in_Python:"><span class="tocnumber">1.6</span> <span class="toctext">Example for a Binary Search Tree in Python:</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Types_of_binary_search_trees"><span class="tocnumber">2</span> <span class="toctext">Types of binary search trees</span></a>
<ul>
<li class="toclevel-2"><a href="#Performance_comparisons"><span class="tocnumber">2.1</span> <span class="toctext">Performance comparisons</span></a></li>
<li class="toclevel-2"><a href="#Optimal_binary_search_trees"><span class="tocnumber">2.2</span> <span class="toctext">Optimal binary search trees</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">3</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">4</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#Further_reading"><span class="tocnumber">5</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Operations" id="Operations"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=1" title="Edit section: Operations">edit</a>]</span> <span class="mw-headline">Operations</span></h2>
<p>Operations on a binary tree require comparisons between nodes. These comparisons are made with calls to a <a href="/w/index.php?title=Comparator_(computer_science)&amp;action=edit&amp;redlink=1" class="new" title="Comparator (computer science) (page does not exist)">comparator</a>, which is a <a href="/wiki/Subroutine" title="Subroutine">subroutine</a> that computes the total order (linear order) on any two values. This comparator can be explicitly or implicitly defined, depending on the language in which the BST is implemented.</p>
<p><a name="Searching" id="Searching"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=2" title="Edit section: Searching">edit</a>]</span> <span class="mw-headline">Searching</span></h3>
<p>Searching a binary tree for a specific value can be a <a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">recursive</a> or <a href="/wiki/Iteration#Computing" title="Iteration">iterative</a> process. This explanation covers a recursive method.</p>
<p>We begin by examining the <a href="/wiki/Tree_(data_structure)#root_nodes" title="Tree (data structure)">root node</a>. If the tree is null, the value we are searching for does not exist in the tree. Otherwise, if the value equals the root, the search is successful. If the value is less than the root, search the left subtree. Similarly, if it is greater than the root, search the right subtree. This process is repeated until the value is found or the indicated subtree is null. If the searched value is not found before a null subtree is reached, then the item must not be present in the tree.</p>
<p>Here is the search algorithm in the <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python programming language</a>:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-python">
 <span class="kw1">def</span> search_binary_tree<span class="br0">(</span>node, key<span class="br0">)</span>:
     <span class="kw1">if</span> node <span class="kw1">is</span> <span class="kw2">None</span>:
         <span class="kw1">return</span> <span class="kw2">None</span>  <span class="co1"># key not found</span>
     <span class="kw1">if</span> key &lt; node.<span class="me1">key</span>:
         <span class="kw1">return</span> search_binary_tree<span class="br0">(</span>node.<span class="me1">left</span>, key<span class="br0">)</span>
     <span class="kw1">elif</span> key &gt; node.<span class="me1">key</span>:
         <span class="kw1">return</span> search_binary_tree<span class="br0">(</span>node.<span class="me1">right</span>, key<span class="br0">)</span>
     <span class="kw1">else</span>:  <span class="co1"># key is equal to node key</span>
         <span class="kw1">return</span> node.<span class="me1">value</span>  <span class="co1"># found key</span>
</pre></div>
<p>This operation requires <a href="/wiki/Big_O_notation" title="Big O notation">O</a>(log <i>n</i>) time in the average case, but needs <a href="/wiki/Big_O_notation" title="Big O notation">O</a>(<i>n</i>) time in the worst-case, when the unbalanced tree resembles a <a href="/wiki/Linked_list" title="Linked list">linked list</a> (<a href="/wiki/Binary_Tree#Types_of_binary_trees" title="Binary Tree" class="mw-redirect">degenerate tree</a>).</p>
<p><a name="Insertion" id="Insertion"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=3" title="Edit section: Insertion">edit</a>]</span> <span class="mw-headline">Insertion</span></h3>
<p>Insertion begins as a search would begin; if the root is not equal to the value, we search the left or right subtrees as before. Eventually, we will reach an external node and add the value as its right or left child, depending on the node's value. In other words, we examine the root and recursively insert the new node to the left subtree if the new value is less than the root, or the right subtree if the new value is greater than or equal to the root.</p>
<p>Here's how a typical binary search tree insertion might be performed in <a href="/wiki/C%2B%2B_(programming_language)" title="C++ (programming language)" class="mw-redirect">C++</a>:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-cpp">
 <span class="coMULTI">/* Inserts the node pointed to by "newNode" into the subtree rooted at "treeNode" */</span>
 <span class="kw4">void</span> InsertNode<span class="br0">(</span>Node* &amp;treeNode, Node *newNode<span class="br0">)</span>
 <span class="br0">{</span>
     <span class="kw1">if</span> <span class="br0">(</span>treeNode == <span class="kw2">NULL</span><span class="br0">)</span>
       treeNode = newNode;
     <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span>newNode-&gt;key &lt; treeNode-&gt;key<span class="br0">)</span>
       InsertNode<span class="br0">(</span>treeNode-&gt;left, newNode<span class="br0">)</span>;
     <span class="kw1">else</span>
       InsertNode<span class="br0">(</span>treeNode-&gt;right, newNode<span class="br0">)</span>;
 <span class="br0">}</span>
</pre></div>
<p>The above "destructive" procedural variant modifies the tree in place. It uses only constant space, but the previous version of the tree is lost. Alternatively, as in the following <a href="/wiki/Python_(programming_language)" title="Python (programming language)">Python</a> example, we can reconstruct all ancestors of the inserted node; any reference to the original tree root remains valid, making the tree a <a href="/wiki/Persistent_data_structure" title="Persistent data structure">persistent data structure</a>:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-python">
 <span class="kw1">def</span> binary_tree_insert<span class="br0">(</span>node, key, value<span class="br0">)</span>:
     <span class="kw1">if</span> node <span class="kw1">is</span> <span class="kw2">None</span>:
         <span class="kw1">return</span> TreeNode<span class="br0">(</span><span class="kw2">None</span>, key, value, <span class="kw2">None</span><span class="br0">)</span>
 
     <span class="kw1">if</span> key == node.<span class="me1">key</span>:
         <span class="kw1">return</span> TreeNode<span class="br0">(</span>node.<span class="me1">left</span>, key, value, node.<span class="me1">right</span><span class="br0">)</span>
     <span class="kw1">if</span> key &lt; node.<span class="me1">key</span>:
         <span class="kw1">return</span> TreeNode<span class="br0">(</span>binary_tree_insert<span class="br0">(</span>node.<span class="me1">left</span>, key, value<span class="br0">)</span>, node.<span class="me1">key</span>, node.<span class="me1">value</span>, node.<span class="me1">right</span><span class="br0">)</span>
     <span class="kw1">else</span>:
         <span class="kw1">return</span> TreeNode<span class="br0">(</span>node.<span class="me1">left</span>, node.<span class="me1">key</span>, node.<span class="me1">value</span>, binary_tree_insert<span class="br0">(</span>node.<span class="me1">right</span>, key, value<span class="br0">)</span><span class="br0">)</span>
</pre></div>
<p>The part that is rebuilt uses Θ(log <i>n</i>) space in the average case and Ω(<i>n</i>) in the worst case (see <a href="/wiki/Big-O_notation" title="Big-O notation" class="mw-redirect">big-O notation</a>).</p>
<p>In either version, this operation requires time proportional to the height of the tree in the worst case, which is <a href="/wiki/Big_O_notation" title="Big O notation">O</a>(log <i>n</i>) time in the average case over all trees, but Ω(<i>n</i>) time in the worst case.</p>
<p>Another way to explain insertion is that in order to insert a new node in the tree, its value is first compared with the value of the root. If its value is less than the root's, it is then compared with the value of the root's left child. If its value is greater, it is compared with the root's right child. This process continues, until the new node is compared with a leaf node, and then it is added as this node's right or left child, depending on its value.</p>
<p>There are other ways of inserting nodes into a binary tree, but this is the only way of inserting nodes at the leaves and at the same time preserving the BST structure.</p>
<p><a name="Deletion" id="Deletion"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=4" title="Edit section: Deletion">edit</a>]</span> <span class="mw-headline">Deletion</span></h3>
<div class="thumb tright">
<div class="thumbinner" style="width:182px;"><a href="/wiki/File:BinarySearchTreeDeletionExamples.svg" class="image" title="Some examples of Binary Search Tree insertions and deletions."><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/4/4d/BinarySearchTreeDeletionExamples.svg/180px-BinarySearchTreeDeletionExamples.svg.png" width="180" height="109" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:BinarySearchTreeDeletionExamples.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Some examples of Binary Search Tree insertions and deletions.</div>
</div>
</div>
<p>There are several cases to be considered:</p>
<ul>
<li><b>Deleting a leaf:</b> Deleting a node with no children is easy, as we can simply remove it from the tree.</li>
<li><b>Deleting a node with one child:</b> Delete it and replace it with its child.</li>
<li><b>Deleting a node with two children:</b> Suppose the node to be deleted is called <i>N</i>. We replace the value of N with either its in-order successor (the left-most child of the right subtree) or the in-order predecessor (the right-most child of the left subtree).</li>
</ul>
<center>
<p><a href="/wiki/File:Binary_search_tree_delete.svg" class="image" title="Deleting a node with two children from a binary search tree"><img alt="Deleting a node with two children from a binary search tree" src="http://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Binary_search_tree_delete.svg/574px-Binary_search_tree_delete.svg.png" width="574" height="179" border="0" /></a></p>
</center>
<p>Once we find either the in-order successor or predecessor, swap it with N, and then delete it. Since both the successor and the predecessor must have fewer than two children, either one can be deleted using the previous two cases. A good implementation avoids consistently using one of these nodes, however, because this can <a href="/wiki/Balanced_tree" title="Balanced tree" class="mw-redirect">unbalance</a> the tree.</p>
<p>Here is <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> sample code for a recursive version of deletion.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-cpp">
<span class="kw4">struct</span> Binary_Search_Tree *Bst_Delete<span class="br0">(</span><span class="kw4">struct</span> Binary_Search_Tree *node, <span class="kw4">int</span> val<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">struct</span> Binary_Search_Tree *successor, *node_delete;
    <span class="kw1">if</span><span class="br0">(</span>node<span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span><span class="br0">(</span>node-&gt;val &gt; val<span class="br0">)</span>
            node-&gt;left = Bst_Delete<span class="br0">(</span>node-&gt;left, val<span class="br0">)</span>;
        <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>node-&gt;val &lt; val<span class="br0">)</span>
            node-&gt;right = Bst_Delete<span class="br0">(</span>node-&gt;right, val<span class="br0">)</span>;
        <span class="kw1">else</span>
        <span class="br0">{</span>
            <span class="kw1">if</span><span class="br0">(</span>node-&gt;left == <span class="kw2">NULL</span><span class="br0">)</span>
            <span class="br0">{</span>
                node_delete = node;
                node = node-&gt;right;
                <span class="kw3">free</span><span class="br0">(</span>node_delete<span class="br0">)</span>;
            <span class="br0">}</span>
            <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>node-&gt;right == <span class="kw2">NULL</span><span class="br0">)</span>
            <span class="br0">{</span>
                node_delete = node;
                node = node-&gt;left;
                <span class="kw3">free</span><span class="br0">(</span>node_delete<span class="br0">)</span>;
            <span class="br0">}</span>
            <span class="kw1">else</span> <span class="coMULTI">/* use inorder_predecessor every alternate delete for better tree balancing */</span>
            <span class="br0">{</span>
                successor = inorder_successor_Bst<span class="br0">(</span>node-&gt;right<span class="br0">)</span>;
                node-&gt;val = successor-&gt;val;
                node-&gt;right = Bst_Delete<span class="br0">(</span>node-&gt;right, successor-&gt;val<span class="br0">)</span>;     
            <span class="br0">}</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> node;
    <span class="br0">}</span>
    <span class="kw1">else</span> 
    <span class="br0">{</span>
        <span class="kw3">printf</span><span class="br0">(</span><span class="st0">"<span class="es0">\n</span>Node to be deleted not found<span class="es0">\n</span>"</span><span class="br0">)</span>;
        <span class="kw1">return</span> <span class="kw2">NULL</span>;
    <span class="br0">}</span>    
<span class="br0">}</span>
</pre></div>
<p>Although this operation does not always traverse the tree down to a leaf, this is always a possibility; thus in the worst case it requires time proportional to the height of the tree. It does not require more even when the node has two children, since it still follows a single path and does not visit any node twice.</p>
<p>Here is the code in Python:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-python">
<span class="kw1">def</span> findSuccessor<span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
    succ = <span class="kw2">None</span>
    <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">rightChild</span>:
        succ = <span class="kw2">self</span>.<span class="me1">rightChild</span>.<span class="me1">findMin</span><span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">else</span>:
        <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span> == <span class="kw2">self</span>:
            succ = <span class="kw2">self</span>.<span class="me1">parent</span>
        <span class="kw1">else</span>:
            <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = <span class="kw2">None</span>
            succ = <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">findSuccessor</span><span class="br0">(</span><span class="br0">)</span>
            <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = <span class="kw2">self</span>
        <span class="kw1">return</span> succ
 
<span class="kw1">def</span> findMin<span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
    n = <span class="kw2">self</span>
    <span class="kw1">while</span> n.<span class="me1">leftChild</span>:
        n = n.<span class="me1">leftChild</span>
    <span class="kw1">print</span> <span class="st0">'found min, key = '</span>, n.<span class="me1">key</span>
    <span class="kw1">return</span> n
 
<span class="kw1">def</span> spliceOut<span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
    <span class="kw1">if</span> <span class="br0">(</span><span class="kw1">not</span> <span class="kw2">self</span>.<span class="me1">leftChild</span> <span class="kw1">and</span> <span class="kw1">not</span> <span class="kw2">self</span>.<span class="me1">rightChild</span><span class="br0">)</span>:
        <span class="kw1">if</span> <span class="kw2">self</span> == <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span>:
            <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span> = <span class="kw2">None</span>
        <span class="kw1">else</span>:
            <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = <span class="kw2">None</span>
    <span class="kw1">elif</span> <span class="br0">(</span><span class="kw2">self</span>.<span class="me1">leftChild</span> <span class="kw1">or</span> <span class="kw2">self</span>.<span class="me1">rightChild</span><span class="br0">)</span>:
        <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">leftChild</span>:
            <span class="kw1">if</span> <span class="kw2">self</span> == <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span>:
                <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span> = <span class="kw2">self</span>.<span class="me1">leftChild</span>
            <span class="kw1">else</span>:
                <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = <span class="kw2">self</span>.<span class="me1">leftChild</span>
        <span class="kw1">else</span>:
            <span class="kw1">if</span> <span class="kw2">self</span> == <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span>:
                <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span> = <span class="kw2">self</span>.<span class="me1">rightChild</span>
            <span class="kw1">else</span>:
                <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = <span class="kw2">self</span>.<span class="me1">rightChild</span>
 
<span class="kw1">def</span> binary_tree_delete<span class="br0">(</span><span class="kw2">self</span>, key<span class="br0">)</span>:
    <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">key</span> == key:
        <span class="kw1">if</span> <span class="kw1">not</span> <span class="br0">(</span><span class="kw2">self</span>.<span class="me1">leftChild</span> <span class="kw1">or</span> <span class="kw2">self</span>.<span class="me1">rightChild</span><span class="br0">)</span>:
            <span class="kw1">if</span> <span class="kw2">self</span> == <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span>:
                <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span> = <span class="kw2">None</span>
            <span class="kw1">else</span>:
                <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = <span class="kw2">None</span>
        <span class="kw1">elif</span> <span class="br0">(</span><span class="kw2">self</span>.<span class="me1">leftChild</span> <span class="kw1">or</span> <span class="kw2">self</span>.<span class="me1">rightChild</span><span class="br0">)</span> <span class="kw1">and</span> <span class="br0">(</span><span class="kw1">not</span> <span class="br0">(</span><span class="kw2">self</span>.<span class="me1">leftChild</span> <span class="kw1">and</span> <span class="kw2">self</span>.<span class="me1">rightChild</span><span class="br0">)</span><span class="br0">)</span>:
            <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">leftChild</span>:
                <span class="kw1">if</span> <span class="kw2">self</span> == <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span>:
                    <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span> = <span class="kw2">self</span>.<span class="me1">leftChild</span>
                <span class="kw1">else</span>:
                    <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = <span class="kw2">self</span>.<span class="me1">leftChild</span>
            <span class="kw1">else</span>:
                <span class="kw1">if</span> <span class="kw2">self</span> == <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span>:
                    <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span> = <span class="kw2">self</span>.<span class="me1">rightChild</span>
                <span class="kw1">else</span>:
                    <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = <span class="kw2">self</span>.<span class="me1">rightchild</span>
        <span class="kw1">else</span>:
            succ = <span class="kw2">self</span>.<span class="me1">findSuccessor</span><span class="br0">(</span><span class="br0">)</span>
            succ.<span class="me1">spliceOut</span><span class="br0">(</span><span class="br0">)</span>
            <span class="kw1">if</span> <span class="kw2">self</span> == <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span>:
                <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">leftChild</span> = succ
            <span class="kw1">else</span>:
                <span class="kw2">self</span>.<span class="me1">parent</span>.<span class="me1">rightChild</span> = succ
            succ.<span class="me1">leftChild</span> = <span class="kw2">self</span>.<span class="me1">leftChild</span>
            succ.<span class="me1">rightChild</span> = <span class="kw2">self</span>.<span class="me1">rightChild</span>
    <span class="kw1">else</span>:
        <span class="kw1">if</span> key &lt; <span class="kw2">self</span>.<span class="me1">key</span>:
</pre></div>
<p><a name="Traversal" id="Traversal"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=5" title="Edit section: Traversal">edit</a>]</span> <span class="mw-headline">Traversal</span></h3>
<p>Once the binary search tree has been created, its elements can be retrieved <a href="/wiki/In-order_traversal" title="In-order traversal" class="mw-redirect">in-order</a> by recursively traversing the left subtree of the root node, accessing the node itself, then recursively traversing the right subtree of the node, continuing this pattern with each node in the tree as it's recursively accessed. The tree may also be traversed in <a href="/wiki/Pre-order_traversal" title="Pre-order traversal" class="mw-redirect">pre-order</a> or <a href="/wiki/Post-order_traversal" title="Post-order traversal" class="mw-redirect">post-order</a> traversals.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-python">
 <span class="kw1">def</span> traverse_binary_tree<span class="br0">(</span>treenode<span class="br0">)</span>:
     <span class="kw1">if</span> treenode <span class="kw1">is</span> <span class="kw2">None</span>: <span class="kw1">return</span>
     left, nodevalue, right = treenode
     traverse_binary_tree<span class="br0">(</span>left<span class="br0">)</span>
     visit<span class="br0">(</span>nodevalue<span class="br0">)</span>
     traverse_binary_tree<span class="br0">(</span>right<span class="br0">)</span>
</pre></div>
<p>Traversal requires <a href="/wiki/Big_O_notation#Related_asymptotic_notations" title="Big O notation">Ω(<i>n</i>)</a> time, since it must visit every node. This algorithm is also O(<i>n</i>), and so it is <a href="/wiki/Asymptotically_optimal" title="Asymptotically optimal" class="mw-redirect">asymptotically optimal</a>.</p>
<p><a name="Sort" id="Sort"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=6" title="Edit section: Sort">edit</a>]</span> <span class="mw-headline">Sort</span></h3>
<p>A binary search tree can be used to implement a simple but efficient <a href="/wiki/Sorting_algorithm" title="Sorting algorithm">sorting algorithm</a>. Similar to <a href="/wiki/Heapsort" title="Heapsort">heapsort</a>, we insert all the values we wish to sort into a new ordered data structure—in this case a binary search tree—and then traverse it in order, building our result:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-python">
 <span class="kw1">def</span> build_binary_tree<span class="br0">(</span>values<span class="br0">)</span>:
     tree = <span class="kw2">None</span>
     <span class="kw1">for</span> v <span class="kw1">in</span> values:
         tree = binary_tree_insert<span class="br0">(</span>tree, v<span class="br0">)</span>
     <span class="kw1">return</span> tree
 
 <span class="kw1">def</span> traverse_binary_tree<span class="br0">(</span>treenode<span class="br0">)</span>:
     <span class="kw1">if</span> treenode <span class="kw1">is</span> <span class="kw2">None</span>: <span class="kw1">return</span> <span class="br0">[</span><span class="br0">]</span>
     <span class="kw1">else</span>:
         left, value, right = treenode
         <span class="kw1">return</span> <span class="br0">(</span>traverse_binary_tree<span class="br0">(</span>left<span class="br0">)</span>, <span class="br0">[</span>value<span class="br0">]</span>, traverse_binary_tree<span class="br0">(</span>right<span class="br0">)</span><span class="br0">)</span>
</pre></div>
<p>The worst-case time of <code>build_binary_tree</code> is <span class="texhtml">Θ(<i>n</i><sup>2</sup>)</span>—if you feed it a sorted list of values, it chains them into a <a href="/wiki/Linked_list" title="Linked list">linked list</a> with no left subtrees. For example, <code>build_binary_tree([1, 2, 3, 4, 5])</code> yields the tree <code>(None, 1, (None, 2, (None, 3, (None, 4, (None, 5, None)))))</code>.</p>
<p>There are several schemes for overcoming this flaw with simple binary trees; the most common is the <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing binary search tree</a>. If this same procedure is done using such a tree, the overall worst-case time is <a href="/wiki/Big_O_notation" title="Big O notation">O</a>(<i>n</i>log <i>n</i>), which is <a href="/wiki/Asymptotically_optimal" title="Asymptotically optimal" class="mw-redirect">asymptotically optimal</a> for a <a href="/wiki/Comparison_sort" title="Comparison sort">comparison sort</a>. In practice, the poor <a href="/wiki/CPU_cache" title="CPU cache">cache</a> performance and added overhead in time and space for a tree-based sort (particularly for node <a href="/wiki/Dynamic_memory_allocation" title="Dynamic memory allocation">allocation</a>) make it inferior to other asymptotically optimal sorts such as <a href="/wiki/Heapsort" title="Heapsort">heapsort</a> for static list sorting. On the other hand, it is one of the most efficient methods of <i>incremental sorting</i>, adding items to a list over time while keeping the list sorted at all times...</p>
<p><a name="Example_for_a_Binary_Search_Tree_in_Python:" id="Example_for_a_Binary_Search_Tree_in_Python:"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=7" title="Edit section: Example for a Binary Search Tree in Python:">edit</a>]</span> <span class="mw-headline">Example for a Binary Search Tree in Python:</span></h3>
<div dir="ltr" style="text-align: left;">
<pre class="source-python">
<span class="kw1">class</span> Node:
    <span class="kw1">def</span> <span class="kw4">__init__</span><span class="br0">(</span><span class="kw2">self</span>, lchild=<span class="kw2">None</span>, rchild=<span class="kw2">None</span>, value=<span class="nu0">-1</span>, data=<span class="kw2">None</span><span class="br0">)</span>:
        <span class="kw2">self</span>.<span class="me1">lchild</span> = lchild
        <span class="kw2">self</span>.<span class="me1">rchild</span> = rchild
        <span class="kw2">self</span>.<span class="me1">value</span> = value
        <span class="kw2">self</span>.<span class="me1">data</span> = data
 
<span class="kw1">class</span> Bst:
    <span class="st0">""</span><span class="st0">"Implement Binary Search Tree."</span><span class="st0">""</span>
 
    <span class="kw1">def</span> <span class="kw4">__init__</span><span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
        <span class="kw2">self</span>.<span class="me1">l</span> = <span class="br0">[</span><span class="br0">]</span>  <span class="co1"># Nodes</span>
        <span class="kw2">self</span>.<span class="me1">root</span> = <span class="kw2">None</span>
 
    <span class="kw1">def</span> add<span class="br0">(</span><span class="kw2">self</span>, key, dt<span class="br0">)</span>:
        <span class="st0">""</span><span class="st0">"Add a node in tree."</span><span class="st0">""</span>
        <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">root</span> == <span class="kw2">None</span>:
            <span class="kw2">self</span>.<span class="me1">root</span> = Node<span class="br0">(</span>value=key, data=dt<span class="br0">)</span>
            <span class="kw2">self</span>.<span class="me1">l</span>.<span class="me1">append</span><span class="br0">(</span><span class="kw2">self</span>.<span class="me1">root</span><span class="br0">)</span>
            <span class="kw1">return</span> <span class="nu0">0</span>
        <span class="kw1">else</span>:
            <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">root</span>
            <span class="kw1">while</span> <span class="kw2">True</span>:
                <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">value</span> &gt; key:
                    <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span> == <span class="kw2">None</span>:
                        <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span> = Node<span class="br0">(</span>value=key, data=dt<span class="br0">)</span>
                        <span class="kw1">return</span> <span class="nu0">0</span>  <span class="co1"># Success</span>
                    <span class="kw1">else</span>:
                        <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span>
                <span class="kw1">elif</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">value</span> == key:
                    <span class="kw1">return</span> <span class="nu0">-1</span>  <span class="co1"># Value already in tree</span>
                <span class="kw1">else</span>:
                    <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span> == <span class="kw2">None</span>:
                        <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span> = Node<span class="br0">(</span>value=key, data=dt<span class="br0">)</span>
                        <span class="kw1">return</span> <span class="nu0">0</span>  <span class="co1"># Success</span>
                    <span class="kw1">else</span>:
                        <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span>
        <span class="kw1">return</span> <span class="nu0">-2</span>  <span class="co1"># Should never happen</span>
 
    <span class="kw1">def</span> search<span class="br0">(</span><span class="kw2">self</span>, key<span class="br0">)</span>:
        <span class="st0">""</span><span class="st0">"Search Tree for a key and return data; if not found return None."</span><span class="st0">""</span>
        <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">root</span>
        <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span> == <span class="kw2">None</span>:
            <span class="kw1">return</span> <span class="kw2">None</span>
 
        <span class="kw1">while</span> <span class="kw2">True</span>:
<span class="co1">#            print self.p.value, self.p.data</span>
            <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">value</span> &gt; key:
                <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span> == <span class="kw2">None</span>:
                    <span class="kw1">return</span> <span class="kw2">None</span>  <span class="co1"># Not found</span>
                <span class="kw1">else</span>:
                    <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span>
            <span class="kw1">elif</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">value</span> == key:
                <span class="kw1">return</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">data</span>
            <span class="kw1">else</span>:
                <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span> == <span class="kw2">None</span>:
                    <span class="kw1">return</span> <span class="kw2">None</span>  <span class="co1"># Not found</span>
                <span class="kw1">else</span>:
                    <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span>
        <span class="kw1">return</span> <span class="kw2">None</span>  <span class="co1"># Should never happen</span>
 
    <span class="kw1">def</span> deleteNode<span class="br0">(</span><span class="kw2">self</span>, key<span class="br0">)</span>:
        <span class="st0">""</span><span class="st0">"Delete node with value == key."</span><span class="st0">""</span>
        <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">root</span>.<span class="me1">value</span> == key:
            <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">root</span>.<span class="me1">rchild</span> == <span class="kw2">None</span>:
                <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">root</span>.<span class="me1">lchild</span> == <span class="kw2">None</span>:
                    <span class="kw2">self</span>.<span class="me1">root</span> = <span class="kw2">None</span>
                <span class="kw1">else</span>: <span class="kw2">self</span>.<span class="me1">root</span> = <span class="kw2">self</span>.<span class="me1">root</span>.<span class="me1">lchild</span>
            <span class="kw1">else</span>:
                <span class="kw2">self</span>.<span class="me1">root</span>.<span class="me1">rchild</span>.<span class="me1">lchild</span> = <span class="kw2">self</span>.<span class="me1">root</span>.<span class="me1">lchild</span>
                <span class="kw2">self</span>.<span class="me1">root</span> = <span class="kw2">self</span>.<span class="me1">root</span>.<span class="me1">rchild</span>
            <span class="kw1">return</span> <span class="nu0">1</span>
        <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">root</span>
        <span class="kw1">while</span> <span class="kw2">True</span>:
            <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">value</span> &gt; key:
                <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span> == <span class="kw2">None</span>:
                    <span class="kw1">return</span> <span class="nu0">0</span>  <span class="co1"># Not found anything to delete</span>
                <span class="kw1">elif</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span>.<span class="me1">value</span> == key:
                    <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span> = <span class="kw2">self</span>.<span class="me1">proceed</span><span class="br0">(</span><span class="kw2">self</span>.<span class="me1">p</span>, <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span><span class="br0">)</span>
                    <span class="kw1">return</span> <span class="nu0">1</span>
                <span class="kw1">else</span>:
                    <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">lchild</span>
            <span class="co1"># There's no way for self.p.value to be equal to key:</span>
            <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">value</span> &lt; key:
                <span class="kw1">if</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span> == <span class="kw2">None</span>:
                    <span class="kw1">return</span> <span class="nu0">0</span>  <span class="co1"># Not found anything to delete</span>
                <span class="kw1">elif</span> <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span>.<span class="me1">value</span> == key:
                    <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span> = <span class="kw2">self</span>.<span class="me1">proceed</span><span class="br0">(</span><span class="kw2">self</span>.<span class="me1">p</span>, <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span><span class="br0">)</span>
                    <span class="kw1">return</span> <span class="nu0">1</span>
                <span class="kw1">else</span>:
                    <span class="kw2">self</span>.<span class="me1">p</span> = <span class="kw2">self</span>.<span class="me1">p</span>.<span class="me1">rchild</span>
        <span class="kw1">return</span> <span class="nu0">0</span>
 
    <span class="kw1">def</span> proceed<span class="br0">(</span><span class="kw2">self</span>, parent, delValue<span class="br0">)</span>:
        <span class="kw1">if</span> delValue.<span class="me1">lchild</span> == <span class="kw2">None</span> <span class="kw1">and</span> delValue.<span class="me1">rchild</span> == <span class="kw2">None</span>:
            <span class="kw1">return</span> <span class="kw2">None</span>
        <span class="kw1">elif</span> delValue.<span class="me1">rchild</span> == <span class="kw2">None</span>:
            <span class="kw1">return</span> delValue.<span class="me1">lchild</span>
        <span class="kw1">else</span>:
            <span class="kw1">return</span> delValue.<span class="me1">rchild</span>
 
    <span class="kw1">def</span> sort<span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
        <span class="kw2">self</span>.__traverse__<span class="br0">(</span><span class="kw2">self</span>.<span class="me1">root</span>, mode=<span class="nu0">1</span><span class="br0">)</span>
 
    <span class="kw1">def</span> __traverse__<span class="br0">(</span><span class="kw2">self</span>, v, mode=<span class="nu0">0</span><span class="br0">)</span>:
        <span class="st0">""</span><span class="st0">"Traverse in: preorder = 0, inorder = 1, postorder = 2."</span><span class="st0">""</span>
        <span class="kw1">if</span> v == <span class="kw2">None</span>:
            <span class="kw1">return</span>
        <span class="kw1">if</span> mode == <span class="nu0">0</span>:
            <span class="kw1">print</span> <span class="br0">(</span>v.<span class="me1">value</span>, v.<span class="me1">data</span><span class="br0">)</span>
            <span class="kw2">self</span>.__traverse__<span class="br0">(</span>v.<span class="me1">lchild</span><span class="br0">)</span>
            <span class="kw2">self</span>.__traverse__<span class="br0">(</span>v.<span class="me1">rchild</span><span class="br0">)</span>
        <span class="kw1">elif</span> mode == <span class="nu0">1</span>:
            <span class="kw2">self</span>.__traverse__<span class="br0">(</span>v.<span class="me1">lchild</span>, <span class="nu0">1</span><span class="br0">)</span>
            <span class="kw1">print</span> <span class="br0">(</span>v.<span class="me1">value</span>, v.<span class="me1">data</span><span class="br0">)</span>
            <span class="kw2">self</span>.__traverse__<span class="br0">(</span>v.<span class="me1">rchild</span>, <span class="nu0">1</span><span class="br0">)</span>
        <span class="kw1">else</span>:
            <span class="kw2">self</span>.__traverse__<span class="br0">(</span>v.<span class="me1">lchild</span>, <span class="nu0">2</span><span class="br0">)</span>
            <span class="kw2">self</span>.__traverse__<span class="br0">(</span>v.<span class="me1">rchild</span>, <span class="nu0">2</span><span class="br0">)</span>
            <span class="kw1">print</span> <span class="br0">(</span>v.<span class="me1">value</span>, v.<span class="me1">data</span><span class="br0">)</span>
 
<span class="kw1">def</span> main<span class="br0">(</span><span class="br0">)</span>:
    tree = Bst<span class="br0">(</span><span class="br0">)</span>
    tree.<span class="me1">add</span><span class="br0">(</span><span class="nu0">4</span>, <span class="st0">"test1"</span><span class="br0">)</span>
    tree.<span class="me1">add</span><span class="br0">(</span><span class="nu0">10</span>, <span class="st0">"test2"</span><span class="br0">)</span>
    tree.<span class="me1">add</span><span class="br0">(</span><span class="nu0">23</span>, <span class="st0">"test3"</span><span class="br0">)</span>
    tree.<span class="me1">add</span><span class="br0">(</span><span class="nu0">1</span>, <span class="st0">"test4"</span><span class="br0">)</span>
    tree.<span class="me1">add</span><span class="br0">(</span><span class="nu0">3</span>, <span class="st0">"test5"</span><span class="br0">)</span>
    tree.<span class="me1">add</span><span class="br0">(</span><span class="nu0">2</span>, <span class="st0">"test6"</span><span class="br0">)</span>
    tree.<span class="me1">sort</span><span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">print</span> tree.<span class="me1">search</span><span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span>
    <span class="kw1">print</span> tree.<span class="me1">deleteNode</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span>
    <span class="kw1">print</span> tree.<span class="me1">deleteNode</span><span class="br0">(</span><span class="nu0">23</span><span class="br0">)</span>
    <span class="kw1">print</span> tree.<span class="me1">deleteNode</span><span class="br0">(</span><span class="nu0">4</span><span class="br0">)</span>
    <span class="kw1">print</span> tree.<span class="me1">search</span><span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span>
    tree.<span class="me1">sort</span><span class="br0">(</span><span class="br0">)</span>
<span class="kw1">if</span> __name__ == <span class="st0">"__main__"</span>: main<span class="br0">(</span><span class="br0">)</span>
</pre></div>
<p><a name="Types_of_binary_search_trees" id="Types_of_binary_search_trees"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=8" title="Edit section: Types of binary search trees">edit</a>]</span> <span class="mw-headline">Types of binary search trees</span></h2>
<p>There are many types of binary search trees. <a href="/wiki/AVL_tree" title="AVL tree">AVL trees</a> and <a href="/wiki/Red-black_tree" title="Red-black tree">red-black trees</a> are both forms of <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing binary search trees</a>. A <a href="/wiki/Splay_tree" title="Splay tree">splay tree</a> is a binary search tree that automatically moves frequently accessed elements nearer to the root. In a <a href="/wiki/Treap" title="Treap">treap</a> ("tree <a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">heap</a>"), each node also holds a priority and the parent node has higher priority than its children.</p>
<p>Two other titles describing binary search trees are that of a <b>complete</b> and <b>degenerate</b> tree.</p>
<p>A complete tree is a tree with n levels, where for each level d &lt;= n - 1, the number of existing nodes at level d is equal to 2<sup>d</sup>. This means all possible nodes exist at these levels. An additional requirement for a complete binary tree is that for the n<sup>th</sup> level, while every node does not have to exist, the nodes that do exist must fill from left to right.</p>
<p>A degenerate tree is a tree where for each parent node, there is only one associated child node. What this means is that in a performance measurement, the tree will essentially behave like a linked list data structure.</p>
<p><a name="Performance_comparisons" id="Performance_comparisons"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=9" title="Edit section: Performance comparisons">edit</a>]</span> <span class="mw-headline">Performance comparisons</span></h3>
<p>D. A. Heger (2004)<sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup> presented a performance comparison of binary search trees. <a href="/wiki/Treap" title="Treap">Treap</a> was found to have the best average performance, while <a href="/wiki/Red-black_tree" title="Red-black tree">red-black tree</a> was found to have the smallest amount of performance fluctuations.</p>
<p><a name="Optimal_binary_search_trees" id="Optimal_binary_search_trees"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=10" title="Edit section: Optimal binary search trees">edit</a>]</span> <span class="mw-headline">Optimal binary search trees</span></h3>
<p>If we don't plan on modifying a search tree, and we know exactly how often each item will be accessed, we can construct an <b>optimal binary search tree</b>, which is a search tree where the average cost of looking up an item (the <i>expected search cost</i>) is minimized.</p>
<p>Assume that we know the elements and that for each element, we know the proportion of future lookups which will be looking for that element. We can then use a <a href="/wiki/Dynamic_programming" title="Dynamic programming">dynamic programming</a> solution, detailed in section 15.5 of <i>Introduction to Algorithms (Second Edition)</i> by Thomas H. Cormen, to construct the tree with the least possible expected search cost.</p>
<p>Even if we only have estimates of the search costs, such a system can considerably speed up lookups on average. For example, if you have a BST of English words used in a <a href="/wiki/Spell_checker" title="Spell checker">spell checker</a>, you might balance the tree based on word frequency in <a href="/wiki/Text_corpus" title="Text corpus">text corpora</a>, placing words like "the" near the root and words like "agerasia" near the leaves. Such a tree might be compared with <a href="/wiki/Huffman_tree" title="Huffman tree" class="mw-redirect">Huffman trees</a>, which similarly seek to place frequently-used items near the root in order to produce a dense information encoding; however, Huffman trees only store data elements in leaves and these elements need not be ordered.</p>
<p>If we do not know the sequence in which the elements in the tree will be accessed in advance, we can use <a href="/wiki/Splay_tree" title="Splay tree">splay trees</a> which are asymptotically as good as any static search tree we can construct for any particular sequence of lookup operations.</p>
<p><b>Alphabetic trees</b> are Huffman trees with the additional constraint on order, or, equivalently, search trees with the modification that all elements are stored in the leaves. Faster algorithms exist for <b>optimal alphabetic binary trees</b> (OABTs).</p>
<p>Example:</p>
<pre>
 procedure Optimum Search Tree(f, f´, c)
 for j = 0 to n do
 c[j, j] = 0, F[j, j] = f´j
  for d = 1 to n do
   for i = 0 to (n − d) do
     j = i + d
     F[i, j] = F[i, j − 1] + f´ + f´j
     c[i, j] = MIN(i&lt;k&lt;=j){c[i, k − 1] + c[k, j]} + F[i, j]
</pre>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=11" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<div style="-moz-column-count:2; column-count:2;">
<ul>
<li><a href="/wiki/Binary_search" title="Binary search" class="mw-redirect">Binary search</a></li>
<li><a href="/wiki/Binary_tree" title="Binary tree">Binary tree</a></li>
<li><a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">Self-balancing binary search tree</a></li>
<li><a href="/wiki/Randomized_binary_search_tree" title="Randomized binary search tree" class="mw-redirect">Randomized binary search tree</a></li>
<li><a href="/wiki/B-tree" title="B-tree">B-tree</a></li>
<li><a href="/wiki/Data_structure" title="Data structure">Data structure</a></li>
<li><a href="/wiki/Trie" title="Trie">Trie</a></li>
<li><a href="/wiki/Ternary_search_tree" title="Ternary search tree">Ternary search tree</a></li>
<li><a href="/w/index.php?title=Elastic_binary_tree&amp;action=edit&amp;redlink=1" class="new" title="Elastic binary tree (page does not exist)">Elastic binary tree</a></li>
<li><a href="/wiki/Hash_table" title="Hash table">Hash table</a></li>
<li><a href="/wiki/Skip_list" title="Skip list">Skip list</a></li>
</ul>
</div>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=12" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<div class="references-small">
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> <cite style="font-style:normal" class="" id="CITEREFHeger2004">Heger, Dominique A. (2004), "<a href="http://www.upgrade-cepis.org/issues/2004/5/up5-5Mosaic.pdf" class="external text" title="http://www.upgrade-cepis.org/issues/2004/5/up5-5Mosaic.pdf" rel="nofollow">A Disquisition on The Performance Behavior of Binary Search Tree Data Structures</a>", <i>European Journal for the Informatics Professional</i> <b>5</b> (5)<span class="printonly">, <a href="http://www.upgrade-cepis.org/issues/2004/5/up5-5Mosaic.pdf" class="external free" title="http://www.upgrade-cepis.org/issues/2004/5/up5-5Mosaic.pdf" rel="nofollow">http://www.upgrade-cepis.org/issues/2004/5/up5-5Mosaic.pdf</a></span></cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.atitle=A+Disquisition+on+The+Performance+Behavior+of+Binary+Search+Tree+Data+Structures&amp;rft.jtitle=European+Journal+for+the+Informatics+Professional&amp;rft.aulast=Heger&amp;rft.aufirst=Dominique+A.&amp;rft.au=Heger%2C+Dominique+A.&amp;rft.date=2004&amp;rft.volume=5&amp;rft.issue=5&amp;rft_id=http%3A%2F%2Fwww.upgrade-cepis.org%2Fissues%2F2004%2F5%2Fup5-5Mosaic.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Binary_search_tree"><span style="display: none;">&#160;</span></span></li>
</ol>
</div>
<p><a name="Further_reading" id="Further_reading"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=13" title="Edit section: Further reading">edit</a>]</span> <span class="mw-headline">Further reading</span></h2>
<ul>
<li><a href="/wiki/Donald_Knuth" title="Donald Knuth">Donald Knuth</a>. <i>The Art of Computer Programming</i>, Volume 3: <i>Sorting and Searching</i>, Third Edition. Addison-Wesley, 1997. <a href="/wiki/Special:BookSources/0201896850" class="internal">ISBN 0-201-89685-0</a>. Section 6.2.2: Binary Tree Searching, pp.426–458.</li>
<li><a href="/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Thomas H. Cormen</a>, <a href="/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Charles E. Leiserson</a>, <a href="/wiki/Ronald_L._Rivest" title="Ronald L. Rivest" class="mw-redirect">Ronald L. Rivest</a>, and <a href="/wiki/Clifford_Stein" title="Clifford Stein">Clifford Stein</a>. <i><a href="/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i>, Second Edition. MIT Press and McGraw-Hill, 2001. <a href="/wiki/Special:BookSources/0262032937" class="internal">ISBN 0-262-03293-7</a>. Chapter 12: Binary search trees, pp.253–272. Section 15.5: Optimal binary search trees, pp.356–363.</li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Binary_search_tree&amp;action=edit&amp;section=14" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://jdserver.homelinux.org/wiki/index.php/Binary_Search_Tree" class="external text" title="http://jdserver.homelinux.org/wiki/index.php/Binary_Search_Tree" rel="nofollow">Full source code to an efficient implementation in C++</a></li>
<li><a href="http://wiki.portugal-a-programar.org/c:snippet:binary_search_tree" class="external text" title="http://wiki.portugal-a-programar.org/c:snippet:binary_search_tree" rel="nofollow">Implementation of Binary Search Trees in C</a></li>
<li><a href="http://www.24bytes.com/Binary-Search-Tree.html" class="external text" title="http://www.24bytes.com/Binary-Search-Tree.html" rel="nofollow">Implementation of Binary Search Trees in Java</a></li>
<li><a href="http://www.goletas.com/solutions/collections/" class="external text" title="http://www.goletas.com/solutions/collections/" rel="nofollow">Iterative Implementation of Binary Search Trees in C#</a></li>
<li><a href="http://cslibrary.stanford.edu/110/" class="external text" title="http://cslibrary.stanford.edu/110/" rel="nofollow">An introduction to binary trees from Stanford</a></li>
<li><a href="http://www.nist.gov/dads/HTML/binarySearchTree.html" class="external text" title="http://www.nist.gov/dads/HTML/binarySearchTree.html" rel="nofollow">Dictionary of Algorithms and Data Structures - Binary Search Tree</a></li>
<li><a href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/286239" class="external text" title="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/286239" rel="nofollow">Binary Search Tree Example in Python</a></li>
<li><a href="http://webpages.ull.es/users/jriera/Docencia/AVL/AVL%20tree%20applet.htm" class="external text" title="http://webpages.ull.es/users/jriera/Docencia/AVL/AVL%20tree%20applet.htm" rel="nofollow">Java Model illustrating the behaviour of binary search trees(In JAVA Applet)</a></li>
<li><a href="http://nova.umuc.edu/~jarc/idsv/lesson1.html" class="external text" title="http://nova.umuc.edu/~jarc/idsv/lesson1.html" rel="nofollow">Interactive Data Structure Visualizations - Binary Tree Traversals</a></li>
<li><a href="http://en.literateprograms.org/Category:Binary_search_tree" class="external text" title="http://en.literateprograms.org/Category:Binary_search_tree" rel="nofollow">Literate implementations of binary search trees in various languages</a> on LiteratePrograms</li>
<li><a href="http://people.ksp.sk/~kuko/bak/index.html" class="external text" title="http://people.ksp.sk/~kuko/bak/index.html" rel="nofollow">BST Tree Applet</a> by Kubo Kovac</li>
</ul>
<table class="navbox" cellspacing="0" style=";">
<tr>
<td style="padding:2px;">
<table cellspacing="0" class="nowraplinks collapsible autocollapse" style="width:100%;background:transparent;color:inherit;;">
<tr>
<th style=";" colspan="2" class="navbox-title">
<div style="float:left; width:6em;text-align:left;">
<div class="noprint plainlinksneverexpand navbar" style="background:none; padding:0; font-weight:normal;;;border:none;; font-size:xx-small;"><a href="/wiki/Template:Data_structures" title="Template:Data structures"><span title="View this template" style=";;border:none;">v</span></a>&#160;•&#160;<a href="/wiki/Template_talk:Data_structures" title="Template talk:Data structures"><span title="Discussion about this template" style=";;border:none;">d</span></a>&#160;•&#160;<a href="http://en.wikipedia.org/w/index.php?title=Template:Data_structures&amp;action=edit" class="external text" title="http://en.wikipedia.org/w/index.php?title=Template:Data_structures&amp;action=edit" rel="nofollow"><span title="Edit this template" style=";;border:none;;">e</span></a></div>
</div>
<span style="font-size:110%;"><a href="/wiki/Data_structure" title="Data structure">Data structures</a></span></th>
</tr>
<tr style="height:2px;">
<td></td>
</tr>
<tr>
<td class="navbox-group" style=";;"><a href="/wiki/Array" title="Array">Arrays</a></td>
<td style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em"><a href="/wiki/Associative_array" title="Associative array">Associative array</a></div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<td class="navbox-group" style=";;"><a href="/wiki/List_(computing)" title="List (computing)">Lists</a></td>
<td style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em"><a href="/wiki/Deque" title="Deque">Deque</a>&#160;• <a href="/wiki/Linked_list" title="Linked list">Linked list</a>&#160;• <a href="/wiki/Queue_(data_structure)" title="Queue (data structure)">Queue</a>&#160;• <a href="/wiki/Stack_(data_structure)" title="Stack (data structure)">Stack</a></div>
</td>
</tr>
<tr style="height:2px">
<td></td>
</tr>
<tr>
<td class="navbox-group" style=";;"><a href="/wiki/Tree_(data_structure)" title="Tree (data structure)">Trees</a></td>
<td style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<div style="padding:0em 0.25em"><a href="/wiki/B-tree" title="B-tree">B-tree</a>&#160;• <strong class="selflink">Binary search tree</strong>&#160;• <a href="/wiki/Heap_(data_structure)" title="Heap (data structure)">Heap</a></div>
</td>
</tr>
</table>
</td>
</tr>
</table>
<p><span id="interwiki-pt-fa"></span></p>


<!-- 
NewPP limit report
Preprocessor node count: 952/1000000
Post-expand include size: 13104/2048000 bytes
Template argument size: 2708/2048000 bytes
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:4320-0!1!0!default!!en!2 and timestamp 20090328124011 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Binary_search_tree">http://en.wikipedia.org/wiki/Binary_search_tree</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Articles_with_example_C%2B%2B_code" title="Category:Articles with example C++ code">Articles with example C++ code</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_Python_code" title="Category:Articles with example Python code">Articles with example Python code</a></span> | <span dir='ltr'><a href="/wiki/Category:Binary_trees" title="Category:Binary trees">Binary trees</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Binary_search_tree" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Binary_search_tree" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Binary_search_tree&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Binary_search_tree&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Binary_search_tree" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Binary_search_tree" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Binary_search_tree" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Binary_search_tree&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Binary_search_tree&amp;oldid=279995292" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Binary_search_tree&amp;id=279995292">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-cs"><a href="http://cs.wikipedia.org/wiki/Bin%C3%A1rn%C3%AD_vyhled%C3%A1vac%C3%AD_strom">Česky</a></li>
				<li class="interwiki-da"><a href="http://da.wikipedia.org/wiki/Bin%C3%A6rt_s%C3%B8getr%C3%A6">Dansk</a></li>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Bin%C3%A4rer_Suchbaum">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/%C3%81rbol_binario_de_b%C3%BAsqueda">Español</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Arbre_binaire_de_recherche">Français</a></li>
				<li class="interwiki-ko"><a href="http://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%83%90%EC%83%89_%ED%8A%B8%EB%A6%AC">한국어</a></li>
				<li class="interwiki-id"><a href="http://id.wikipedia.org/wiki/Pohon_biner_terurut">Bahasa Indonesia</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Albero_binario_di_ricerca">Italiano</a></li>
				<li class="interwiki-he"><a href="http://he.wikipedia.org/wiki/%D7%A2%D7%A5_%D7%97%D7%99%D7%A4%D7%95%D7%A9">עברית</a></li>
				<li class="interwiki-nl"><a href="http://nl.wikipedia.org/wiki/Binaire_zoekboom">Nederlands</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/2%E5%88%86%E6%8E%A2%E7%B4%A2%E6%9C%A8">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Binarne_drzewo_poszukiwa%C5%84">Polski</a></li>
				<li class="interwiki-pt"><a href="http://pt.wikipedia.org/wiki/%C3%81rvore_de_busca_bin%C3%A1ria">Português</a></li>
				<li class="interwiki-ro"><a href="http://ro.wikipedia.org/wiki/Arbore_binar_de_c%C4%83utare">Română</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0">Русский</a></li>
				<li class="interwiki-sk"><a href="http://sk.wikipedia.org/wiki/Bin%C3%A1rny_vyh%C4%BEad%C3%A1vac%C3%AD_strom">Slovenčina</a></li>
				<li class="interwiki-fi"><a href="http://fi.wikipedia.org/wiki/Bin%C3%A4%C3%A4rinen_hakupuu">Suomi</a></li>
				<li class="interwiki-sv"><a href="http://sv.wikipedia.org/wiki/Bin%C3%A4rt_s%C3%B6ktr%C3%A4d">Svenska</a></li>
				<li class="interwiki-th"><a href="http://th.wikipedia.org/wiki/%E0%B8%95%E0%B9%89%E0%B8%99%E0%B9%84%E0%B8%A1%E0%B9%89%E0%B8%84%E0%B9%89%E0%B8%99%E0%B8%AB%E0%B8%B2%E0%B9%81%E0%B8%9A%E0%B8%9A%E0%B8%97%E0%B8%A7%E0%B8%B4%E0%B8%A0%E0%B8%B2%E0%B8%84">ไทย</a></li>
				<li class="interwiki-vi"><a href="http://vi.wikipedia.org/wiki/C%C3%A2y_t%C3%ACm_ki%E1%BA%BFm_nh%E1%BB%8B_ph%C3%A2n">Tiếng Việt</a></li>
				<li class="interwiki-uk"><a href="http://uk.wikipedia.org/wiki/%D0%91%D1%96%D0%BD%D0%B0%D1%80%D0%BD%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D1%88%D1%83%D0%BA%D1%83">Українська</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 27 March 2009, at 12:20.</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv176 in 0.061 secs. --></body></html>
