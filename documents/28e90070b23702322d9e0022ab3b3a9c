<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Red-black tree,Articles with unsourced statements since February 2009,2-3 tree,2-4 tree,AVL tree,Amortized analysis,Analysis of algorithms,Associative array,B-tree,Big-O notation,Binary search tree" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Red-black_tree&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Red-black_tree&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Red-black tree - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Red-black_tree";
		var wgTitle = "Red-black tree";
		var wgAction = "view";
		var wgArticleId = "26397";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 282468693;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-c .de1, .source-c .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-c  {}
.source-c .head {}
.source-c .foot {}
.source-c .imp {font-weight: bold; color: red;}
.source-c .ln-xtra {color: #cc0; background-color: #ffc;}
.source-c li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-c li.li2 {font-weight: bold;}
.source-c .kw1 {color: #b1b100;}
.source-c .kw2 {color: #000000; font-weight: bold;}
.source-c .kw3 {color: #000066;}
.source-c .kw4 {color: #993333;}
.source-c .co1 {color: #808080; font-style: italic;}
.source-c .co2 {color: #339933;}
.source-c .coMULTI {color: #808080; font-style: italic;}
.source-c .es0 {color: #000099; font-weight: bold;}
.source-c .br0 {color: #66cc66;}
.source-c .st0 {color: #ff0000;}
.source-c .nu0 {color: #cc66cc;}
.source-c .me1 {color: #202020;}
.source-c .me2 {color: #202020;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
</style>		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Red-black_tree skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Red-black tree</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p>A <b>red-black tree</b> is a type of <a href="/wiki/Self-balancing_binary_search_tree" title="Self-balancing binary search tree">self-balancing binary search tree</a>, a <a href="/wiki/Data_structure" title="Data structure">data structure</a> used in <a href="/wiki/Computer_science" title="Computer science">computer science</a>, typically used to implement <a href="/wiki/Associative_array" title="Associative array">associative arrays</a>. The original structure was invented in 1972 by <a href="/wiki/Rudolf_Bayer" title="Rudolf Bayer">Rudolf Bayer</a><sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since February 2009" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup> who called them "symmetric binary <a href="/wiki/B-tree" title="B-tree">B-trees</a>", but acquired its modern name in a paper in 1978 by <a href="/wiki/Leonidas_J._Guibas" title="Leonidas J. Guibas">Leonidas J. Guibas</a> and <a href="/wiki/Robert_Sedgewick_(computer_scientist)" title="Robert Sedgewick (computer scientist)">Robert Sedgewick</a>.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup> It is complex, but has good worst-case <a href="/wiki/Analysis_of_algorithms" title="Analysis of algorithms">running time</a> for its operations and is efficient in practice: it can search, insert, and delete in <a href="/wiki/Big-O_notation" title="Big-O notation" class="mw-redirect">O</a>(log <i>n</i>) time, where <i>n</i> is total number of elements in the tree. Put <i>very</i> simply, a red-black tree is a binary search tree which inserts and removes intelligently, to ensure the tree is reasonably balanced.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Terminology"><span class="tocnumber">1</span> <span class="toctext">Terminology</span></a></li>
<li class="toclevel-1"><a href="#Properties"><span class="tocnumber">2</span> <span class="toctext">Properties</span></a></li>
<li class="toclevel-1"><a href="#Analogy_to_B-trees_of_order_4"><span class="tocnumber">3</span> <span class="toctext">Analogy to B-trees of order 4</span></a></li>
<li class="toclevel-1"><a href="#Applications_and_related_data_structures"><span class="tocnumber">4</span> <span class="toctext">Applications and related data structures</span></a></li>
<li class="toclevel-1"><a href="#Operations"><span class="tocnumber">5</span> <span class="toctext">Operations</span></a>
<ul>
<li class="toclevel-2"><a href="#Insertion"><span class="tocnumber">5.1</span> <span class="toctext">Insertion</span></a></li>
<li class="toclevel-2"><a href="#Removal"><span class="tocnumber">5.2</span> <span class="toctext">Removal</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Proof_of_asymptotic_bounds"><span class="tocnumber">6</span> <span class="toctext">Proof of asymptotic bounds</span></a></li>
<li class="toclevel-1"><a href="#Complexity"><span class="tocnumber">7</span> <span class="toctext">Complexity</span></a></li>
<li class="toclevel-1"><a href="#Notes"><span class="tocnumber">8</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">9</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">10</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Terminology" id="Terminology"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=1" title="Edit section: Terminology">edit</a>]</span> <span class="mw-headline">Terminology</span></h2>
<p>A red-black tree is a special type of <a href="/wiki/Binary_tree" title="Binary tree">binary tree</a>, used in <a href="/wiki/Computer_science" title="Computer science">computer science</a> to organize pieces of comparable <a href="/wiki/Data" title="Data">data</a>, such as numbers.</p>
<p>In red-black trees, the <a href="/wiki/Tree_(data_structure)#Leaf_nodes" title="Tree (data structure)">leaf nodes</a> are not relevant and do not contain data. These leaves need not be explicit in computer memory — a null child pointer can encode the fact that this child is a leaf — but it simplifies some algorithms for operating on red-black trees if the leaves really are explicit nodes. To save memory, sometimes a single <i>sentinel</i> node performs the role of all leaf nodes; all references from <a href="/wiki/Tree_(data_structure)#Internal_nodes" title="Tree (data structure)">internal nodes</a> to leaf nodes then point to the sentinel node.</p>
<p>Red-black trees, like all <a href="/wiki/Binary_search_tree" title="Binary search tree">binary search trees</a>, allow efficient <a href="/wiki/In-order_traversal" title="In-order traversal" class="mw-redirect">in-order traversal</a> of elements provided that there is a way to locate the parent of any node. The search-time results from the traversal from root to leaf, and therefore a balanced tree, having the least possible tree height, results in O(log <i>n</i>) search time.</p>
<p><a name="Properties" id="Properties"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=2" title="Edit section: Properties">edit</a>]</span> <span class="mw-headline">Properties</span></h2>
<div class="thumb tright">
<div class="thumbinner" style="width:502px;"><a href="/wiki/File:Red-black_tree_example.svg" class="image" title="An example of a red-black tree"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png" width="500" height="241" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Red-black_tree_example.svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
An example of a red-black tree</div>
</div>
</div>
<p>A red-black tree is a <a href="/wiki/Binary_search_tree" title="Binary search tree">binary search tree</a> where each node has a <i>color</i> attribute, the value of which is either <i>red</i> or <i>black</i>. In addition to the ordinary requirements imposed on binary search trees, the following additional requirements of any valid red-black tree apply:</p>
<ol>
<li>A node is either red or black.</li>
<li>The root is black. (This rule is used in some definitions and not others. Since the root can always be changed from red to black but not necessarily vice-versa this rule has little effect on analysis.)</li>
<li>All leaves are black.</li>
<li>Both children of every red node are black.</li>
<li>Every simple path from a node to a descendant leaf contains the same number of black nodes.</li>
</ol>
<p>These constraints enforce a critical property of red-black trees: that the longest path from the root to a leaf is no more than twice as long as the shortest path from the root to a leaf in that tree. The result is that the tree is roughly balanced. Since operations such as inserting, deleting, and finding values require worst-case time proportional to the height of the tree, this theoretical upper bound on the height allows red-black trees to be efficient in the worst-case, unlike ordinary <a href="/wiki/Binary_search_tree" title="Binary search tree">binary search trees</a>.</p>
<p>To see why these properties guarantee this, it suffices to note that no path can have two red nodes in a row, due to property 4. The shortest possible path has all black nodes, and the longest possible path alternates between red and black nodes. Since all maximal paths have the same number of black nodes, by property 5, this shows that no path is more than twice as long as any other path.</p>
<p>In many of the presentations of tree data structures, it is possible for a node to have only one child, and leaf nodes contain data. It is possible to present red-black trees in this paradigm, but it changes several of the properties and complicates the algorithms. For this reason, this article uses "null leaves", which contain no data and merely serve to indicate where the tree ends, as shown above. These nodes are often omitted in drawings, resulting in a tree which seems to contradict the above principles, but which in fact does not. A consequence of this is that all internal (non-leaf) nodes have two children, although one or both of those children may be null leaves.</p>
<p>Some explain a red-black tree as a binary search tree whose edges, instead of nodes, are colored in red or black, but this does not make any difference. The color of a node in this article's terminology corresponds to the color of the edge connecting the node to its parent, except that the root node is always black (property 2) whereas the corresponding edge does not exist.</p>
<p><a name="Analogy_to_B-trees_of_order_4" id="Analogy_to_B-trees_of_order_4"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=3" title="Edit section: Analogy to B-trees of order 4">edit</a>]</span> <span class="mw-headline">Analogy to B-trees of order 4</span></h2>
<div class="thumb tright">
<div class="thumbinner" style="width:502px;"><a href="/wiki/File:Red-black_tree_example_(B-tree_analogy).svg" class="image" title="The same red-black tree as in the example above, seen as a B-tree."><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Red-black_tree_example_%28B-tree_analogy%29.svg/500px-Red-black_tree_example_%28B-tree_analogy%29.svg.png" width="500" height="179" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Red-black_tree_example_(B-tree_analogy).svg" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
The same red-black tree as in the example above, seen as a B-tree.</div>
</div>
</div>
<p>A red-black tree is similar in structure to a <a href="/wiki/B-tree" title="B-tree">B-tree</a> of order 4, where each node can contain between 1 to 3 values and (accordingly) between 2 to 4 child pointers. In such B-tree, each node will contain only one value matching the value in a black node of the red-black tree, with an optional value before and/or after it in the same node, both matching an equivalent red node of the red-black tree.</p>
<p>One way to see this equivalence is to "move up" the red nodes in a graphical representation of the red-black tree, so that they align horizontally with their parent black node, by creating together a horizontal cluster. In the B-tree, or in the modified graphical representation of the red-black tree, all leaf nodes are at the same depth.</p>
<p>The red-black tree is then structurally equivalent to a B-tree of order 4, with a minimum fill factor of 33% of values per cluster with a maximum capacity of 3 values.</p>
<p>However, the conversion of the structurally equivalent B-tree back to a red-black tree can produce multiple results. Effectively, if a B-tree cluster contains only 1 value, the minimum (and has two child pointers), then this value will be black in the red-black tree. If the cluster contains 3 values, then the central value will be black and each value stored on its sides will be red in the red-black tree. However if the cluster contains two values, each one can become the black node in the red-black tree (and the other one will be red).</p>
<p>So the order-4 B-tree does not maintain which of the values contained in each cluster is the root black tree for the whole cluster and the parent of the other values in the same cluster. Despite this, the operations on red-black trees are more economical because you don't have to maintain the vector of values (it may be costly if values are stored directly in each node rather than being stored by simple reference. But B-tree nodes are more economical in space, because you don't need to store the colors attribute for each node (instead you have to know which slot in the vector of 3 values of the cluster is used; if values are stored by references, for example they are objects, you just need to be able to make a distinction with null references, and so the cluster is just represented by a vector containing 3 slots for value pointers plus 4 slots for child references in the tree). In that case, the B-tree can be more compact in memory, it will increase the data locality.</p>
<p>The same analogy can be made with B-trees with larger orders that can be structurally equivalent to a colored binary tree: you just need more colors. Suppose that you add blue, then the blue-red-black tree defined like red-black trees but with the additional constraint that no two successive nodes in the hierarchy will be blue and all blue nodes will be children of a red node, then it becomes equivalent to a B-tree whose clusters will have at most 7 values in the following colors: blue, red, blue, black, blue, red, blue (For each cluster, there will be at most 1 black node, 2 red nodes, and 4 blue nodes).</p>
<p>For moderate volumes of values, insertions and deletions in a colored binary tree are faster compared to B-trees because colored trees don't attempt to maximize the fill factor of each horizontal cluster of nodes (only the minimum fill factor is guaranteed in colored binary trees, limiting the number of splits or junctions of clusters). B-trees will be faster for performing rotations (because rotations will frequently occur within the same cluster rather than with multiple separate nodes in a colored binary tree). However for storing large volumes, B-trees will be much faster as they will be more compact by grouping several children in the same cluster where they can be accessed locally.</p>
<p>All optimizations possible in B-trees to increase the average fill factors of clusters are possible in the equivalent multicolored binary tree. Notably, maximizing the average fill factor in a structurally equivalent B-tree is the same as reducing the total height of the multicolored tree, by increasing the number of non-black nodes. The worst case occurs when all nodes in a colored binary tree are black, the best case occurs when only a third of them are black (and the other two thirds are red nodes).</p>
<p><a name="Applications_and_related_data_structures" id="Applications_and_related_data_structures"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=4" title="Edit section: Applications and related data structures">edit</a>]</span> <span class="mw-headline">Applications and related data structures</span></h2>
<p>Red-black trees offer worst-case guarantees for insertion time, deletion time, and search time. Not only does this make them valuable in time-sensitive applications such as <a href="/wiki/Real-time_computing" title="Real-time computing">real-time applications</a>, but it makes them valuable building blocks in other data structures which provide worst-case guarantees; for example, many data structures used in <a href="/wiki/Computational_geometry" title="Computational geometry">computational geometry</a> can be based on red-black trees.</p>
<p>The <a href="/wiki/AVL_tree" title="AVL tree">AVL tree</a> is another structure supporting O(log <i>n</i>) search, insertion, and removal. It is more rigidly balanced than Red-Black trees, leading to slower insertion and removal but faster retrieval.</p>
<p>Red-black trees are also particularly valuable in <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, where they are one of the most common <a href="/wiki/Persistent_data_structure" title="Persistent data structure">persistent data structures</a>, used to construct <a href="/wiki/Associative_array" title="Associative array">associative arrays</a> and <a href="/wiki/Set_(computer_science)" title="Set (computer science)">sets</a> which can retain previous versions after mutations. The persistent version of red-black trees requires O(log <i>n</i>) space for each insertion or deletion, in addition to time.</p>
<p>Red-black trees are an <a href="/wiki/Isometry" title="Isometry">isometry</a> of <a href="/wiki/2-4_tree" title="2-4 tree" class="mw-redirect">2-4 trees</a>. In other words, for every 2-4 tree, there is a corresponding red-black tree with data elements in the same order. The insertion and deletion operations on 2-4 trees are also equivalent to color-flipping and rotations in red-black trees. This makes 2-4 trees an important tool for understanding the logic behind red-black trees, and this is why many introductory algorithm texts introduce 2-4 trees just before red-black trees, even though 2-4 trees are not often used in practice.</p>
<p>In 2008, <a href="/wiki/Robert_Sedgewick_(computer_scientist)" title="Robert Sedgewick (computer scientist)">Sedgewick</a> introduced a simpler version of red-black trees called <a href="http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" class="external text" title="http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" rel="nofollow">Left-Leaning Red-Black Trees</a> by eliminating a previously unspecified degree of freedom in the implementation. The LLRB maintains an additional invariant that all red links must lean left except during inserts and deletes. Red-black trees can be made isometric to either <a href="/wiki/2-3_tree" title="2-3 tree">2-3 trees</a> <a href="http://www.cs.princeton.edu/courses/archive/fall08/cos226/lectures/10BalancedTrees-2x2.pdf" class="external autonumber" title="http://www.cs.princeton.edu/courses/archive/fall08/cos226/lectures/10BalancedTrees-2x2.pdf" rel="nofollow">[1]</a>, or 2-4 trees <a href="http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" class="external autonumber" title="http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf" rel="nofollow">[2]</a>, for any sequence of operations. The 2-4 tree isometry was described in 1978 by Sedgewick. With 2-4 trees, the isometry is resolved by a "color flip," corresponding to a split, in which the red color of two children nodes leaves the children and moves to the parent node.</p>
<p><a name="Operations" id="Operations"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=5" title="Edit section: Operations">edit</a>]</span> <span class="mw-headline">Operations</span></h2>
<p>Read-only operations on a red-black tree require no modification from those used for <a href="/wiki/Binary_search_tree" title="Binary search tree">binary search trees</a>, because every red-black tree is a special case of a simple binary search tree. However, the immediate result of an insertion or removal may violate the properties of a red-black tree. Restoring the red-black properties requires a small number (<a href="/wiki/Big-O_notation" title="Big-O notation" class="mw-redirect">O</a>(log <i>n</i>) or <a href="/wiki/Amortized_analysis" title="Amortized analysis">amortized O(1)</a>) of color changes (which are very quick in practice) and no more than three <a href="/wiki/Tree_rotation" title="Tree rotation">tree rotations</a> (two for insertion). Although insert and delete operations are complicated, their times remain O(log <i>n</i>).</p>
<p><a name="Insertion" id="Insertion"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=6" title="Edit section: Insertion">edit</a>]</span> <span class="mw-headline">Insertion</span></h3>
<p>Insertion begins by adding the node much <a href="/wiki/Binary_search_tree#Insertion" title="Binary search tree">as we would in a simple binary search tree</a> and coloring it red. Whereas in the binary search tree, we always add a leaf, in the red-black tree leaves contain no information, so instead we add a red interior node, with two black leaves, in place of an existing black leaf.</p>
<p>What happens next depends on the color of other nearby nodes. The term <i>uncle node</i> will be used to refer to the sibling of a node's parent, as in human family trees. Note that:</p>
<ul>
<li>Property 3 (All leaves are black) always holds.</li>
<li>Property 4 (Both children of every red node are black) is threatened only by adding a red node, repainting a black node red, or a rotation.</li>
<li>Property 5 (All paths from any given node to its leaf nodes contain the same number of black nodes) is threatened only by adding a black node, repainting a red node black, or a rotation.</li>
</ul>
<dl>
<dd><i>Note</i>: The label <b>N</b> will be used to denote the node being inserted; <b>P</b> will denote <b>N'</b>s parent node, <b>G</b> will denote <b>N'</b>s grandparent, and <b>U</b> will denote <b>N'</b>s uncle. Note that in between some cases, the roles and labels of the nodes are exchanged, but in each case, every label continues to represent the same node it represented at the beginning of the case. Any color shown in the diagram is either assumed in its case or implied by these assumptions.</dd>
</dl>
<p>Each case will be demonstrated with example <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a> code. The uncle and grandparent nodes can be found by these functions:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">struct</span> node *
grandparent<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n != <span class="kw2">NULL</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>n-&gt;parent != <span class="kw2">NULL</span><span class="br0">)</span><span class="br0">)</span>
		<span class="kw1">return</span> n-&gt;parent-&gt;parent;
	<span class="kw1">else</span>
		<span class="kw1">return</span> <span class="kw2">NULL</span>;
<span class="br0">}</span>
 
<span class="kw4">struct</span> node *
uncle<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *g = grandparent<span class="br0">(</span>n<span class="br0">)</span>;
	<span class="kw1">if</span> <span class="br0">(</span>g == <span class="kw2">NULL</span><span class="br0">)</span>
		<span class="kw1">return</span> <span class="kw2">NULL</span>; <span class="co1">// No grandparent means no uncle</span>
	<span class="kw1">if</span> <span class="br0">(</span>n-&gt;parent == g-&gt;left<span class="br0">)</span>
		<span class="kw1">return</span> g-&gt;right;
	<span class="kw1">else</span>
		<span class="kw1">return</span> g-&gt;left;
<span class="br0">}</span>
</pre></div>
<p><b>Case 1:</b> The new node <b>N</b> is at the root of the tree. In this case, it is repainted black to satisfy Property 2 (The root is black). Since this adds one black node to every path at once, Property 5 (All paths from any given node to its leaf nodes contain the same number of black nodes) is not violated.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
insert_case1<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>n-&gt;parent == <span class="kw2">NULL</span><span class="br0">)</span>
		n-&gt;color = BLACK;
	<span class="kw1">else</span>
		insert_case2<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<p><b>Case 2:</b> The new node's parent <b>P</b> is black, so Property 4 (Both children of every red node are black) is not invalidated. In this case, the tree is still valid. Property 5 (All paths from any given node to its leaf nodes contain the same number of black nodes) is not threatened, because the new node <b>N</b> has two black leaf children, but because <b>N</b> is red, the paths through each of its children have the same number of black nodes as the path through the leaf it replaced, which was black, and so this property remains satisfied.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
insert_case2<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>n-&gt;parent-&gt;color == BLACK<span class="br0">)</span>
		<span class="kw1">return</span>; <span class="coMULTI">/* Tree is still valid */</span>
	<span class="kw1">else</span>
		insert_case3<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<dl>
<dd><i>Note:</i> In the following cases it can be assumed that <b>N</b> has a grandparent node <b>G</b>, because its parent <b>P</b> is red, and if it were the root, it would be black. Thus, <b>N</b> also has an uncle node <b>U</b>, although it may be a leaf in cases 4 and 5.</dd>
</dl>
<table>
<tr>
<td>
<div class="floatright"><a href="/wiki/File:Red-black_tree_insert_case_3.png" class="image" title="Diagram of case 3"><img alt="Diagram of case 3" src="http://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png" width="300" height="139" border="0" /></a></div>
<p><b>Case 3:</b> If both the parent <b>P</b> and the uncle <b>U</b> are red, then both nodes can be repainted black and the grandparent <b>G</b> becomes red (to maintain Property 5 (All paths from any given node to its leaf nodes contain the same number of black nodes)). Now, the new red node <b>N</b> has a black parent. Since any path through the parent or uncle must pass through the grandparent, the number of black nodes on these paths has not changed. However, the grandparent <b>G</b> may now violate properties 2 (The root is black) or 4 (Both children of every red node are black) (property 4 possibly being violated since <b>G</b> may have a red parent). To fix this, this entire procedure is recursively performed on <b>G</b> from case 1. Note that this is a tail-recursive call, so it could be rewritten as a loop; since this is the only loop, and any rotations occur after this loop, this proves that a constant number of rotations occur.</p>
</td>
</tr>
</table>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
insert_case3<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *u = uncle<span class="br0">(</span>n<span class="br0">)</span>, *g;
 
	<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>u != <span class="kw2">NULL</span><span class="br0">)</span> &amp;&amp; <span class="br0">(</span>u-&gt;color == RED<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
		n-&gt;parent-&gt;color = BLACK;
		u-&gt;color = BLACK;
		g = grandparent<span class="br0">(</span>n<span class="br0">)</span>;
		g-&gt;color = RED;
		insert_case1<span class="br0">(</span>g<span class="br0">)</span>;
	<span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
		insert_case4<span class="br0">(</span>n<span class="br0">)</span>;
	<span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<dl>
<dd><i>Note:</i> In the remaining cases, it is assumed that the parent node <b>P</b> is the left child of its parent. If it is the right child, <i>left</i> and <i>right</i> should be reversed throughout cases 4 and 5. The code samples take care of this.</dd>
</dl>
<table>
<tr>
<td>
<div class="floatleft"><a href="/wiki/File:Red-black_tree_insert_case_4.png" class="image" title="Diagram of case 4"><img alt="Diagram of case 4" src="http://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png" width="283" height="138" border="0" /></a></div>
<p><b>Case 4:</b> The parent <b>P</b> is red but the uncle <b>U</b> is black; also, the new node <b>N</b> is the right child of <b>P</b>, and <b>P</b> in turn is the left child of its parent <b>G</b>. In this case, a <a href="/wiki/Tree_rotation" title="Tree rotation">left rotation</a> that switches the roles of the new node <b>N</b> and its parent <b>P</b> can be performed; then, the former parent node <b>P</b> is dealt with using Case 5 (relabeling <b>N</b> and <b>P</b>) because property 4 (Both children of every red node are black) is still violated. The rotation causes some paths (those in the sub-tree labelled "1") to pass through the new node where they did not before, but both these nodes are red, so Property 5 (All paths from any given node to its leaf nodes contain the same number of black nodes) is not violated by the rotation.</p>
</td>
</tr>
</table>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
insert_case4<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *g = grandparent<span class="br0">(</span>n<span class="br0">)</span>;
 
	<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n == n-&gt;parent-&gt;right<span class="br0">)</span> &amp;&amp; <span class="br0">(</span>n-&gt;parent == g-&gt;left<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
		rotate_left<span class="br0">(</span>n-&gt;parent<span class="br0">)</span>;
		n = n-&gt;left;
	<span class="br0">}</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n == n-&gt;parent-&gt;left<span class="br0">)</span> &amp;&amp; <span class="br0">(</span>n-&gt;parent == g-&gt;right<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
		rotate_right<span class="br0">(</span>n-&gt;parent<span class="br0">)</span>;
		n = n-&gt;right;
	<span class="br0">}</span>
	insert_case5<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<table>
<tr>
<td>
<div class="floatright"><a href="/wiki/File:Red-black_tree_insert_case_5.png" class="image" title="Diagram of case 5"><img alt="Diagram of case 5" src="http://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png" width="310" height="138" border="0" /></a></div>
<p><b>Case 5:</b> The parent <b>P</b> is red but the uncle <b>U</b> is black, the new node <b>N</b> is the left child of <b>P</b>, and <b>P</b> is the left child of its parent <b>G</b>. In this case, a <a href="/wiki/Tree_rotation" title="Tree rotation">right rotation</a> on the parent of <b>P</b> is performed; the result is a tree where the former parent <b>P</b> is now the parent of both the new node <b>N</b> and the former grandparent <b>G</b>. <b>G</b> is known to be black, since its former child <b>P</b> could not have been red otherwise. Then, the colors of <b>P</b> and <b>G</b> are switched, and the resulting tree satisfies Property 4 (Both children of every red node are black). Property 5 (All paths from any given node to its leaf nodes contain the same number of black nodes) also remains satisfied, since all paths that went through any of these three nodes went through <b>G</b> before, and now they all go through <b>P</b>. In each case, this is the only black node of the three.</p>
</td>
</tr>
</table>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
insert_case5<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *g = grandparent<span class="br0">(</span>n<span class="br0">)</span>;
 
	n-&gt;parent-&gt;color = BLACK;
	g-&gt;color = RED;
	<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n == n-&gt;parent-&gt;left<span class="br0">)</span> &amp;&amp; <span class="br0">(</span>n-&gt;parent == g-&gt;left<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
		rotate_right<span class="br0">(</span>g<span class="br0">)</span>;
	<span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
		<span class="coMULTI">/*
		 * Here, (n == n-&gt;parent-&gt;right) &amp;&amp; (n-&gt;parent == g-&gt;right).
		 */</span>
		rotate_left<span class="br0">(</span>g<span class="br0">)</span>;
	<span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<p>Note that inserting is actually <a href="/wiki/In-place_algorithm" title="In-place algorithm">in-place</a>, since all the calls above use <a href="/wiki/Tail_recursion" title="Tail recursion">tail recursion</a>.</p>
<p><a name="Removal" id="Removal"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=7" title="Edit section: Removal">edit</a>]</span> <span class="mw-headline">Removal</span></h3>
<p>In a normal binary search tree, when deleting a node with two non-leaf children, we find either the maximum element in its left subtree or the minimum element in its right subtree, and move its value into the node being deleted (as shown <a href="/wiki/Binary_search_tree#Deletion" title="Binary search tree">here</a>). We then delete the node we copied the value from, which must have less than two non-leaf children. Because merely copying a value does not violate any red-black properties, this reduces the problem of deleting to the problem of deleting a node with at most one non-leaf child. It does not matter whether this node is the node we originally wanted to delete or the node we copied the value from.</p>
<p>For the remainder of this discussion we can assume we are deleting a node with at most one non-leaf child, which we will call its child (if it has only leaf children, let one of them be its child). If we are deleting a red node, we can simply replace it with its child, which must be black. All paths through the deleted node will simply pass through one less red node, and both the deleted node's parent and child must be black, so properties 3 (All leaves, including <i>null</i>s, are black) and 4 (Both children of every red node are black) still hold. Another simple case is when the deleted node is black and its child is red. Simply removing a black node could break Properties 4 (Both children of every red node are black) and 5 (All paths from any given node to its leaf nodes contain the same number of black nodes), but if we repaint its child black, both of these properties are preserved.</p>
<p>The complex case is when both the node to be deleted and its child are black. We begin by replacing the node to be deleted with its child. We will call (or <i>label</i>) this child (in its new position) <b>N</b>, and its sibling (its new parent's other child) <b>S</b>. In the diagrams below, we will also use <b>P</b> for <b>N'</b>s new parent, <b>S<sub>L</sub></b> for <b>S'</b>s left child, and <b>S<sub>R</sub></b> for <b>S'</b>s right child (it can be shown that <b>S</b> cannot be a leaf).</p>
<dl>
<dd><i>Note</i>: In between some cases, we exchange the roles and labels of the nodes, but in each case, every label continues to represent the same node it represented at the beginning of the case. Any color shown in the diagram is either assumed in its case or implied by these assumptions. White represents an unknown color (either red or black).</dd>
</dl>
<p>We will find the sibling using this function:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">struct</span> node *
sibling<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>n == n-&gt;parent-&gt;left<span class="br0">)</span>
		<span class="kw1">return</span> n-&gt;parent-&gt;right;
	<span class="kw1">else</span>
		<span class="kw1">return</span> n-&gt;parent-&gt;left;
<span class="br0">}</span>
</pre></div>
<dl>
<dd><i>Note</i>: In order that the tree remains well-defined, we need that every null leaf remains a leaf after all transformations (that it will not have any children). If the node we are deleting has a non-leaf (non-null) child <b>N</b>, it is easy to see that the property is satisfied. If, on the other hand, <b>N</b> would be a null leaf, it can be verified from the diagrams (or code) for all the cases that the property is satisfied as well.</dd>
</dl>
<p>We can perform the steps outlined above with the following code, where the function <code>replace_node</code> substitutes <code>child</code> into <code>n</code>'s place in the tree. For convenience, code in this section will assume that null leaves are represented by actual node objects rather than NULL (the code in the <i>Insertion</i> section works with either representation).</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
delete_one_child<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="coMULTI">/*
	 * Precondition: n has at most one non-null child.
	 */</span>
	<span class="kw4">struct</span> node *child = is_leaf<span class="br0">(</span>n-&gt;right<span class="br0">)</span> ? n-&gt;left : n-&gt;right;
 
	replace_node<span class="br0">(</span>n, child<span class="br0">)</span>;
	<span class="kw1">if</span> <span class="br0">(</span>n-&gt;color == BLACK<span class="br0">)</span> <span class="br0">{</span>
		<span class="kw1">if</span> <span class="br0">(</span>child-&gt;color == RED<span class="br0">)</span>
			child-&gt;color = BLACK;
		<span class="kw1">else</span>
			delete_case1<span class="br0">(</span>child<span class="br0">)</span>;
	<span class="br0">}</span>
	free<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<dl>
<dd><i>Note</i>: If <b>N</b> is a null leaf and we do not want to represent null leaves as actual node objects, we can modify the algorithm by first calling delete_case1() on its parent (the node that we delete, <code>n</code> in the code above) and deleting it afterwards. We can do this because the parent is black, so it behaves in the same way as a null leaf (and is sometimes called a 'phantom' leaf). And we can safely delete it at the end as <code>n</code> will remain a leaf after all operations, as shown above.</dd>
</dl>
<p>If both <b>N</b> and its original parent are black, then deleting this original parent causes paths which proceed through <b>N</b> to have one fewer black node than paths that do not. As this violates Property 5 (All paths from any given node to its leaf nodes contain the same number of black nodes), the tree must be rebalanced. There are several cases to consider:</p>
<p><b>Case 1:</b> <b>N</b> is the new root. In this case, we are done. We removed one black node from every path, and the new root is black, so the properties are preserved.</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
delete_case1<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>n-&gt;parent != <span class="kw2">NULL</span><span class="br0">)</span>
		delete_case2<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<dl>
<dd><i>Note</i>: In cases 2, 5, and 6, we assume <b>N</b> is the left child of its parent <b>P</b>. If it is the right child, <i>left</i> and <i>right</i> should be reversed throughout these three cases. Again, the code examples take both cases into account.</dd>
</dl>
<table>
<tr>
<td>
<div class="floatright"><a href="/wiki/File:Red-black_tree_delete_case_2.png" class="image" title="Diagram of case 2"><img alt="Diagram of case 2" src="http://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png" width="298" height="136" border="0" /></a></div>
<p><b>Case 2:</b> <b>S</b> is red. In this case we reverse the colors of <b>P</b> and <b>S</b>, and then <a href="/wiki/Tree_rotation" title="Tree rotation">rotate</a> left at <b>P</b>, turning <b>S</b> into <b>N'</b>s grandparent. Note that <b>P</b> has to be black as it had a red child. Although all paths still have the same number of black nodes, now <b>N</b> has a black sibling and a red parent, so we can proceed to step 4, 5, or 6. (Its new sibling is black because it was once the child of the red <b>S</b>.) In later cases, we will relabel <b>N'</b>s new sibling as <b>S</b>.</p>
</td>
</tr>
</table>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
delete_case2<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *s = sibling<span class="br0">(</span>n<span class="br0">)</span>;
 
	<span class="kw1">if</span> <span class="br0">(</span>s-&gt;color == RED<span class="br0">)</span> <span class="br0">{</span>
		n-&gt;parent-&gt;color = RED;
		s-&gt;color = BLACK;
		<span class="kw1">if</span> <span class="br0">(</span>n == n-&gt;parent-&gt;left<span class="br0">)</span>
			rotate_left<span class="br0">(</span>n-&gt;parent<span class="br0">)</span>;
		<span class="kw1">else</span>
			rotate_right<span class="br0">(</span>n-&gt;parent<span class="br0">)</span>;
	<span class="br0">}</span> 
	delete_case3<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<table>
<tr>
<td>
<div class="floatleft"><a href="/wiki/File:Red-black_tree_delete_case_3.png" class="image" title="Diagram of case 3"><img alt="Diagram of case 3" src="http://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png" width="313" height="132" border="0" /></a></div>
<p><b>Case 3:</b> <b>P</b>, <b>S</b>, and <b>S'</b>s children are black. In this case, we simply repaint <b>S</b> red. The result is that all paths passing through <b>S</b>, which are precisely those paths <i>not</i> passing through <b>N</b>, have one less black node. Because deleting <b>N'</b>s original parent made all paths passing through <b>N</b> have one less black node, this evens things up. However, all paths through <b>P</b> now have one fewer black node than paths that do not pass through <b>P</b>, so Property 5 (All paths from any given node to its leaf nodes contain the same number of black nodes) is still violated. To correct this, we perform the rebalancing procedure on <b>P</b>, starting at case 1.</p>
</td>
</tr>
</table>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
delete_case3<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *s = sibling<span class="br0">(</span>n<span class="br0">)</span>;
 
	<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n-&gt;parent-&gt;color == BLACK<span class="br0">)</span> &amp;&amp;
	    <span class="br0">(</span>s-&gt;color == BLACK<span class="br0">)</span> &amp;&amp;
	    <span class="br0">(</span>s-&gt;left-&gt;color == BLACK<span class="br0">)</span> &amp;&amp;
	    <span class="br0">(</span>s-&gt;right-&gt;color == BLACK<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
		s-&gt;color = RED;
		delete_case1<span class="br0">(</span>n-&gt;parent<span class="br0">)</span>;
	<span class="br0">}</span> <span class="kw1">else</span>
		delete_case4<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<table>
<tr>
<td>
<div class="floatright"><a href="/wiki/File:Red-black_tree_delete_case_4.png" class="image" title="Diagram of case 4"><img alt="Diagram of case 4" src="http://upload.wikimedia.org/wikipedia/commons/d/d7/Red-black_tree_delete_case_4.png" width="313" height="132" border="0" /></a></div>
<p><b>Case 4:</b> <b>S</b> and <b>S'</b>s children are black, but <b>P</b> is red. In this case, we simply exchange the colors of <b>S</b> and <b>P</b>. This does not affect the number of black nodes on paths going through <b>S</b>, but it does add one to the number of black nodes on paths going through <b>N</b>, making up for the deleted black node on those paths.</p>
</td>
</tr>
</table>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
delete_case4<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *s = sibling<span class="br0">(</span>n<span class="br0">)</span>;
 
	<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n-&gt;parent-&gt;color == RED<span class="br0">)</span> &amp;&amp;
	    <span class="br0">(</span>s-&gt;color == BLACK<span class="br0">)</span> &amp;&amp;
	    <span class="br0">(</span>s-&gt;left-&gt;color == BLACK<span class="br0">)</span> &amp;&amp;
	    <span class="br0">(</span>s-&gt;right-&gt;color == BLACK<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
		s-&gt;color = RED;
		n-&gt;parent-&gt;color = BLACK;
	<span class="br0">}</span> <span class="kw1">else</span>
		delete_case5<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<table>
<tr>
<td>
<div class="floatleft"><a href="/wiki/File:Red-black_tree_delete_case_5.png" class="image" title="Diagram of case 5"><img alt="Diagram of case 5" src="http://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png" width="247" height="133" border="0" /></a></div>
<p><b>Case 5:</b> <b>S</b> is black, <b>S'</b>s left child is red, <b>S'</b>s right child is black, and <b>N</b> is the left child of its parent. In this case we rotate right at <b>S</b>, so that <b>S'</b>s left child becomes <b>S'</b>s parent and <b>N'</b>s new sibling. We then exchange the colors of <b>S</b> and its new parent. All paths still have the same number of black nodes, but now <b>N</b> has a black sibling whose right child is red, so we fall into case 6. Neither <b>N</b> nor its parent are affected by this transformation. (Again, for case 6, we relabel <b>N'</b>s new sibling as <b>S</b>.)</p>
</td>
</tr>
</table>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
delete_case5<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *s = sibling<span class="br0">(</span>n<span class="br0">)</span>;
 
	<span class="kw1">if</span>  <span class="br0">(</span>s-&gt;color == BLACK<span class="br0">)</span> <span class="br0">{</span> <span class="coMULTI">/* this if statement is trivial, 
due to Case 2 (even though Case two changed the sibling to a sibling's child, 
the sibling's child can't be red, since no red parent can have a red child). */</span>
<span class="co1">// the following statements just force the red to be on the left of the left of the parent, </span>
<span class="co1">// or right of the right, so case six will rotate correctly.</span>
		<span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n == n-&gt;parent-&gt;left<span class="br0">)</span> &amp;&amp;
		    <span class="br0">(</span>s-&gt;right-&gt;color == BLACK<span class="br0">)</span> &amp;&amp;
		    <span class="br0">(</span>s-&gt;left-&gt;color == RED<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span> <span class="co1">// this last test is trivial too due to cases 2-4.</span>
			s-&gt;color = RED;
			s-&gt;left-&gt;color = BLACK;
			rotate_right<span class="br0">(</span>s<span class="br0">)</span>;
		<span class="br0">}</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">(</span><span class="br0">(</span>n == n-&gt;parent-&gt;right<span class="br0">)</span> &amp;&amp;
		           <span class="br0">(</span>s-&gt;left-&gt;color == BLACK<span class="br0">)</span> &amp;&amp;
		           <span class="br0">(</span>s-&gt;right-&gt;color == RED<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span><span class="co1">// this last test is trivial too due to cases 2-4.</span>
			s-&gt;color = RED;
			s-&gt;right-&gt;color = BLACK;
			rotate_left<span class="br0">(</span>s<span class="br0">)</span>;
		<span class="br0">}</span>
	<span class="br0">}</span>
	delete_case6<span class="br0">(</span>n<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
<table>
<tr>
<td>
<div class="floatright"><a href="/wiki/File:Red-black_tree_delete_case_6.png" class="image" title="Diagram of case 6"><img alt="Diagram of case 6" src="http://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png" width="299" height="143" border="0" /></a></div>
<p><b>Case 6:</b> <b>S</b> is black, <b>S'</b>s right child is red, and <b>N</b> is the left child of its parent <b>P</b>. In this case we rotate left at <b>P</b>, so that <b>S</b> becomes the parent of <b>P</b> and <b>S'</b>s right child. We then exchange the colors of <b>P</b> and <b>S</b>, and make <b>S'</b>s right child black. The subtree still has the same color at its root, so Properties 4 (Both children of every red node are black) and 5 (All paths from any given node to its leaf nodes contain the same number of black nodes) are not violated. However, <b>N</b> now has one additional black ancestor: either <b>P</b> has become black, or it was black and <b>S</b> was added as a black grandparent. Thus, the paths passing through <b>N</b> pass through one additional black node.</p>
<p>Meanwhile, if a path does not go through <b>N</b>, then there are two possibilities:</p>
<ul>
<li>It goes through <b>N'</b>s new sibling. Then, it must go through <b>S</b> and <b>P</b>, both formerly and currently, as they have only exchanged colors and places. Thus the path contains the same number of black nodes.</li>
<li>It goes through <b>N'</b>s new uncle, <b>S'</b>s right child. Then, it formerly went through <b>S</b>, <b>S'</b>s parent, and <b>S'</b>s right child (which was red), but now only goes through <b>S</b>, which has assumed the color of its former parent, and <b>S'</b>s right child, which has changed from red to black (assuming <b>S'</b>s color: black). The net effect is that this path goes through the same number of black nodes.</li>
</ul>
<p>Either way, the number of black nodes on these paths does not change. Thus, we have restored Properties 4 (Both children of every red node are black) and 5 (All paths from any given node to its leaf nodes contain the same number of black nodes). The white node in the diagram can be either red or black, but must refer to the same color both before and after the transformation.</p>
</td>
</tr>
</table>
<div dir="ltr" style="text-align: left;">
<pre class="source-c">
<span class="kw4">void</span>
delete_case6<span class="br0">(</span><span class="kw4">struct</span> node *n<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">struct</span> node *s = sibling<span class="br0">(</span>n<span class="br0">)</span>;
 
	s-&gt;color = n-&gt;parent-&gt;color;
        n-&gt;parent-&gt;color = BLACK;
 
	<span class="kw1">if</span> <span class="br0">(</span>n == n-&gt;parent-&gt;left<span class="br0">)</span> <span class="br0">{</span>
                s-&gt;right-&gt;color = BLACK;
		rotate_left<span class="br0">(</span>n-&gt;parent<span class="br0">)</span>;
	<span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
		s-&gt;left-&gt;color = BLACK;
		rotate_right<span class="br0">(</span>n-&gt;parent<span class="br0">)</span>;
	<span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
<p>Again, the function calls all use <a href="/wiki/Tail_recursion" title="Tail recursion">tail recursion</a>, so the algorithm is <a href="/wiki/In-place_algorithm" title="In-place algorithm">in-place</a>. In the algorithm above, all cases are chained in order, except in delete case 3 where it can recurse to case 1 back to the parent node: this is the only case where an in-place implementation will effectively loop (after only one rotation in case 3).</p>
<p>Additionally, no tail recursion ever occurs on a child node, so the tail recursion loop can only move from a child back to its successive ancestors. No more than O(log <i>n</i>) loops back to case 1 will occur (where <i>n</i> is the total number of nodes in the tree before deletion). If a rotation occurs in case 2 (which is the only possibility of rotation within the loop of cases 1–3), then the parent of the node <b>N</b> becomes red after the rotation and we will exit the loop. Therefore at most one rotation will occur within this loop. Since no more than two additional rotations will occur after exiting the loop, at most three rotations occur in total.</p>
<p><a name="Proof_of_asymptotic_bounds" id="Proof_of_asymptotic_bounds"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=8" title="Edit section: Proof of asymptotic bounds">edit</a>]</span> <span class="mw-headline">Proof of asymptotic bounds</span></h2>
<p>A red black tree which contains <i>n</i> internal nodes has a height of O(log(n)).</p>
<p>Definitions:</p>
<ul>
<li>h(<i>v</i>) = height of subtree rooted at node <i>v</i></li>
<li>bh(<i>v</i>) = the number of black nodes (not counting <i>v</i> if it is black) from <i>v</i> to any leaf in the subtree (called the black-height).</li>
</ul>
<p><b>Lemma:</b> A subtree rooted at node <i>v</i> has at least <span class="texhtml">2<sup><i>b</i><i>h</i>(<i>v</i>)</sup> − 1</span> internal nodes.</p>
<p>Proof of Lemma (by induction height):</p>
<p>Basis: h(<i>v</i>) = 0</p>
<p>If <i>v</i> has a height of zero then it must be <i>null</i>, therefore bh(<i>v</i>) = 0. So:</p>
<dl>
<dd><span class="texhtml">2<sup><i>b</i><i>h</i>(<i>v</i>)</sup> − 1 = 2<sup>0</sup> − 1 = 1 − 1 = 0</span></dd>
</dl>
<p>Inductive Step: <i>v</i> such that h(<i>v</i>) = k, has at least <span class="texhtml">2<sup><i>b</i><i>h</i>(<i>v</i>)</sup> − 1</span> internal nodes implies that <span class="texhtml"><i>v</i>'</span> such that h(<span class="texhtml"><i>v</i>'</span>) = k+1 has at least <span class="texhtml">2<sup><i>b</i><i>h</i>(<i>v</i>')</sup> − 1</span> internal nodes.</p>
<p>Since <span class="texhtml"><i>v</i>'</span> has h(<span class="texhtml"><i>v</i>'</span>) &gt; 0 it is an internal node. As such it has two children each of which has a black-height of either bh(<span class="texhtml"><i>v</i>'</span>) or bh(<span class="texhtml"><i>v</i>'</span>)-1 (depending on whether the child is red or black). By the inductive hypothesis each child has at least <span class="texhtml">2<sup><i>b</i><i>h</i>(<i>v</i>') − 1</sup> − 1</span> internal nodes, so <span class="texhtml"><i>v</i>'</span> has at least:</p>
<dl>
<dd><span class="texhtml">2<sup><i>b</i><i>h</i>(<i>v</i>') − 1</sup> − 1 + 2<sup><i>b</i><i>h</i>(<i>v</i>') − 1</sup> − 1 + 1 = 2<sup><i>b</i><i>h</i>(<i>v</i>')</sup> − 1</span></dd>
</dl>
<p>internal nodes.</p>
<p>Using this lemma we can now show that the height of the tree is logarithmic. Since at least half of the nodes on any path from the root to a leaf are black (property 4 of a red black tree), the black-height of the root is at least h(root)/2. By the lemma we get:</p>
<dl>
<dd><img class="tex" alt="
n \geq 2^{{h(\text{root}) \over 2}} - 1 \leftrightarrow \; \log_2{(n+1)} \geq {h(\text{root}) \over 2} \leftrightarrow \; h(\text{root}) \leq 2\log_2{(n+1)}.
" src="http://upload.wikimedia.org/math/e/5/c/e5cc954022122cf14c04b677798e49f7.png" /></dd>
</dl>
<p>Therefore the height of the root is O(log(n)).</p>
<p><a name="Complexity" id="Complexity"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=9" title="Edit section: Complexity">edit</a>]</span> <span class="mw-headline">Complexity</span></h2>
<p>In the tree code there is only one loop where the node of the root of the red-black property that we wish to restore, x, can be moved up the tree by one level at each iteration.</p>
<p>Since the original height of the tree is O(log n), there are O(log n) iterations. So overall the insert routine has O(log n) complexity.</p>
<p><a name="Notes" id="Notes"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=10" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline">Notes</span></h2>
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> Leonidas J. Guibas, Robert Sedgewick: A Dichromatic Framework for Balanced Trees FOCS 1978: 8-21</li>
</ol>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=11" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<ul>
<li><a href="http://mathworld.wolfram.com/Red-BlackTree.html" class="external text" title="http://mathworld.wolfram.com/Red-BlackTree.html" rel="nofollow">Mathworld: Red-Black Tree</a></li>
<li><a href="http://www.eli.sdsu.edu/courses/fall95/cs660/notes/RedBlackTree/RedBlack.html#RTFToC2" class="external text" title="http://www.eli.sdsu.edu/courses/fall95/cs660/notes/RedBlackTree/RedBlack.html#RTFToC2" rel="nofollow">San Diego State University: CS 660: Red-Black tree notes</a>, by Roger Whitney</li>
<li><a href="/wiki/Thomas_H._Cormen" title="Thomas H. Cormen">Thomas H. Cormen</a>, <a href="/wiki/Charles_E._Leiserson" title="Charles E. Leiserson">Charles E. Leiserson</a>, <a href="/wiki/Ronald_L._Rivest" title="Ronald L. Rivest" class="mw-redirect">Ronald L. Rivest</a>, and <a href="/wiki/Clifford_Stein" title="Clifford Stein">Clifford Stein</a>. <i><a href="/wiki/Introduction_to_Algorithms" title="Introduction to Algorithms">Introduction to Algorithms</a></i>, Second Edition. MIT Press and McGraw-Hill, 2001. <a href="/wiki/Special:BookSources/0262032937" class="internal">ISBN 0-262-03293-7</a> . Chapter 13: Red-Black Trees, pp.273–301.</li>
<li><cite style="font-style:normal" class="web" id="CITEREFPfaff2004">Pfaff, Ben (June 2004). <a href="http://www.stanford.edu/~blp/papers/libavl.pdf" class="external text" title="http://www.stanford.edu/~blp/papers/libavl.pdf" rel="nofollow">"Performance Analysis of BSTs in System Software"</a> (PDF). <a href="/wiki/Stanford_university" title="Stanford university" class="mw-redirect">Stanford University</a><span class="printonly">. <a href="http://www.stanford.edu/~blp/papers/libavl.pdf" class="external free" title="http://www.stanford.edu/~blp/papers/libavl.pdf" rel="nofollow">http://www.stanford.edu/~blp/papers/libavl.pdf</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Performance+Analysis+of+BSTs+in+System+Software&amp;rft.atitle=&amp;rft.aulast=Pfaff&amp;rft.aufirst=Ben&amp;rft.au=Pfaff%2C+Ben&amp;rft.date=June+2004&amp;rft.pub=%5B%5BStanford+university%7CStanford+University%5D%5D&amp;rft_id=http%3A%2F%2Fwww.stanford.edu%2F%7Eblp%2Fpapers%2Flibavl.pdf&amp;rfr_id=info:sid/en.wikipedia.org:Red-black_tree"><span style="display: none;">&#160;</span></span></li>
<li><cite style="font-style:normal" class="web" id="CITEREFOkasaki">Okasaki, Chris. <a href="http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps" class="external text" title="http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps" rel="nofollow">"Red-Black Trees in a Functional Setting"</a> (PS)<span class="printonly">. <a href="http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps" class="external free" title="http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps" rel="nofollow">http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps</a></span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Red-Black+Trees+in+a+Functional+Setting&amp;rft.atitle=&amp;rft.aulast=Okasaki&amp;rft.aufirst=Chris&amp;rft.au=Okasaki%2C+Chris&amp;rft_id=http%3A%2F%2Fwww.eecs.usma.edu%2Fwebs%2Fpeople%2Fokasaki%2Fjfp99.ps&amp;rfr_id=info:sid/en.wikipedia.org:Red-black_tree"><span style="display: none;">&#160;</span></span></li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Red-black_tree&amp;action=edit&amp;section=12" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li>In the <a href="/wiki/C%2B%2B" title="C++">C++</a> <a href="/wiki/Standard_Template_Library" title="Standard Template Library">Standard Template Library</a>, the containers <code>std::set&lt;Value&gt;</code> and <code>std::map&lt;Key,Value&gt;</code> are often based on red-black trees</li>
<li><a href="http://www.stanford.edu/~blp/avl/libavl.html/Red_002dBlack-Trees.html" class="external text" title="http://www.stanford.edu/~blp/avl/libavl.html/Red_002dBlack-Trees.html" rel="nofollow">Red-Black Tree in GNU libavl C library by Ben Pfaff</a></li>
<li><a href="http://web.mit.edu/~emin/www/source_code/red_black_tree/index.html" class="external text" title="http://web.mit.edu/~emin/www/source_code/red_black_tree/index.html" rel="nofollow">Red-Black Tree C Code</a></li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 1016/1000000
Post-expand include size: 7226/2048000 bytes
Template argument size: 2698/2048000 bytes
Expensive parser function count: 1/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:26397-0!1!0!default!!en!2 and timestamp 20090408014743 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Red-black_tree">http://en.wikipedia.org/wiki/Red-black_tree</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Articles_containing_proofs" title="Category:Articles containing proofs">Articles containing proofs</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_C_code" title="Category:Articles with example C code">Articles with example C code</a></span> | <span dir='ltr'><a href="/wiki/Category:B-tree" title="Category:B-tree">B-tree</a></span></div><div id="mw-hidden-catlinks" class="mw-hidden-cats-hidden">Hidden categories:&#32;<span dir='ltr'><a href="/wiki/Category:All_articles_with_unsourced_statements" title="Category:All articles with unsourced statements">All articles with unsourced statements</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_unsourced_statements_since_February_2009" title="Category:Articles with unsourced statements since February 2009">Articles with unsourced statements since February 2009</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Red-black_tree" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Red-black_tree" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Red-black_tree&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Red-black_tree&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Red-black_tree" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Red-black_tree" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Red-black_tree" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Red-black_tree&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Red-black_tree&amp;oldid=282468693" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Red-black_tree&amp;id=282468693">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-cs"><a href="http://cs.wikipedia.org/wiki/%C4%8Cerveno-%C4%8Dern%C3%BD_strom">Česky</a></li>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Rot-Schwarz-Baum">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/%C3%81rbol_rojo-negro">Español</a></li>
				<li class="interwiki-fa"><a href="http://fa.wikipedia.org/wiki/%D8%AF%D8%B1%D8%AE%D8%AA_%D9%82%D8%B1%D9%85%D8%B2-%D8%B3%DB%8C%D8%A7%D9%87">فارسی</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Arbre_bicolore">Français</a></li>
				<li class="interwiki-ko"><a href="http://ko.wikipedia.org/wiki/%EB%A0%88%EB%93%9C-%EB%B8%94%EB%9E%99_%ED%8A%B8%EB%A6%AC">한국어</a></li>
				<li class="interwiki-hr"><a href="http://hr.wikipedia.org/wiki/Crveno-crno_stablo">Hrvatski</a></li>
				<li class="interwiki-id"><a href="http://id.wikipedia.org/wiki/Pohon_merah-hitam">Bahasa Indonesia</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Albero_rosso-nero">Italiano</a></li>
				<li class="interwiki-he"><a href="http://he.wikipedia.org/wiki/%D7%A2%D7%A5_%D7%90%D7%93%D7%95%D7%9D_%D7%A9%D7%97%D7%95%D7%A8">עברית</a></li>
				<li class="interwiki-lt"><a href="http://lt.wikipedia.org/wiki/Raudonai-Juodas_medis">Lietuvių</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E8%B5%A4%E9%BB%92%E6%9C%A8">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Drzewo_czerwono-czarne">Polski</a></li>
				<li class="interwiki-pt"><a href="http://pt.wikipedia.org/wiki/%C3%81rvore_rubro-negra">Português</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D1%81%D0%BD%D0%BE-%D1%87%D1%91%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">Русский</a></li>
				<li class="interwiki-sr"><a href="http://sr.wikipedia.org/wiki/%D0%A6%D1%80%D0%B2%D0%B5%D0%BD%D0%BE-%D1%86%D1%80%D0%BD%D0%BE_%D1%81%D1%82%D0%B0%D0%B1%D0%BB%D0%BE">Српски / Srpski</a></li>
				<li class="interwiki-fi"><a href="http://fi.wikipedia.org/wiki/Punamusta_puu">Suomi</a></li>
				<li class="interwiki-sv"><a href="http://sv.wikipedia.org/wiki/R%C3%B6d-svart_tr%C3%A4d">Svenska</a></li>
				<li class="interwiki-vi"><a href="http://vi.wikipedia.org/wiki/C%C3%A2y_%C4%91%E1%BB%8F_%C4%91en">Tiếng Việt</a></li>
				<li class="interwiki-tr"><a href="http://tr.wikipedia.org/wiki/K%C4%B1rm%C4%B1z%C4%B1-Siyah_A%C4%9Fa%C3%A7">Türkçe</a></li>
				<li class="interwiki-uk"><a href="http://uk.wikipedia.org/wiki/%D0%A7%D0%B5%D1%80%D0%B2%D0%BE%D0%BD%D0%BE-%D1%87%D0%BE%D1%80%D0%BD%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">Українська</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 8 April 2009, at 01:43.</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv166 in 0.059 secs. --></body></html>
