<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Rete algorithm,AI production,Action selection mechanism,Algorithm,Artificial Intelligence (journal),Attribute (computing),Backward chaining,BizTalk,Business analyst,CLIPS programming language,Carnegie Mellon University" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Rete_algorithm&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Rete_algorithm&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Rete algorithm - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Rete_algorithm";
		var wgTitle = "Rete algorithm";
		var wgAction = "view";
		var wgArticleId = "172566";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 265914088;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Rete_algorithm skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Rete algorithm</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<p>The <b>Rete algorithm</b> is an efficient <a href="/wiki/Pattern_matching" title="Pattern matching">pattern matching</a> <a href="/wiki/Algorithm" title="Algorithm">algorithm</a> for implementing <a href="/wiki/Production_rule_system" title="Production rule system" class="mw-redirect">production rule systems</a>. The Rete algorithm was designed by Dr <a href="/wiki/Charles_Forgy" title="Charles Forgy">Charles L. Forgy</a> of <a href="/wiki/Carnegie_Mellon_University" title="Carnegie Mellon University">Carnegie Mellon University</a>, first published in a working paper in 1974, and later elaborated in his 1979 Ph.D. thesis and a 1982 paper (see <a href="#References" title="">References</a>). Rete has become the basis for many popular expert system shells, including <a href="/wiki/CLIPS_programming_language" title="CLIPS programming language" class="mw-redirect">CLIPS</a>, <a href="/wiki/Jess_programming_language" title="Jess programming language">Jess</a>, <a href="/wiki/Drools" title="Drools">Drools</a>, <a href="/wiki/BizTalk" title="BizTalk" class="mw-redirect">BizTalk Rules Engine</a> and <a href="/wiki/Soar_(cognitive_architecture)" title="Soar (cognitive architecture)">Soar</a>. The word 'Rete' is taken from the Latin for 'net'. The same word is used in modern Italian to mean <a href="http://en.wiktionary.org/wiki/Network" class="extiw" title="wiktionary:Network">network</a>. Rete is generally pronounced <span title="Representation in the International Phonetic Alphabet (IPA)" class="IPA"><a href="/wiki/Help:IPA_for_English" title="Help:IPA for English" class="mw-redirect">/'riː tiː/</a></span> ('ree-tee'), but a common academic pronunciation is <span title="Representation in the International Phonetic Alphabet (IPA)" class="IPA"><a href="/wiki/Help:IPA_for_English" title="Help:IPA for English" class="mw-redirect">/'reɪ tiː/</a></span> ('ray-tee'), which is closer to modern Italian pronunciation. Other variant pronunciations include <span title="Representation in the International Phonetic Alphabet (IPA)" class="IPA"><a href="/wiki/Help:IPA_for_English" title="Help:IPA for English" class="mw-redirect">/riːt/</a></span> ('reet') and, rarely, <span title="Representation in the International Phonetic Alphabet (IPA)" class="IPA"><a href="/wiki/Help:IPA_for_English" title="Help:IPA for English" class="mw-redirect">/rε 'teɪ/</a></span> ('re-tay').</p>
<p>A <a href="/wiki/Na%C3%AFve_algorithm" title="Naïve algorithm">naïve implementation</a> of an expert system might check each <a href="/wiki/Rule_of_inference" title="Rule of inference">rule</a> against the known <a href="/wiki/Fact" title="Fact">facts</a> in the <a href="/wiki/Knowledge_base" title="Knowledge base">knowledge base</a>, firing that rule if necessary, then moving on to the next rule (and looping back to the first rule when finished). For even moderate sized rules and facts knowledge-bases, this naïve approach performs far too slowly. The Rete algorithm provides the basis for a more efficient implementation. A Rete-based expert system builds a network of <a href="/wiki/Vertex_(graph_theory)" title="Vertex (graph theory)">nodes</a>, where each node (except the root) corresponds to a pattern occurring in the left-hand-side (the condition part) of a rule. The path from the <a href="/wiki/Root_node" title="Root node" class="mw-redirect">root node</a> to a <a href="/wiki/Leaf_node" title="Leaf node">leaf node</a> defines a complete rule left-hand-side. Each node has a memory of facts which satisfy that pattern. This structure is essentially a generalized <a href="/wiki/Trie" title="Trie">trie</a>. As new facts are asserted or modified, they propagate along the network, causing nodes to be annotated when that fact matches that pattern. When a fact or combination of facts causes all of the patterns for a given rule to be satisfied, a leaf node is reached and the corresponding rule is triggered.</p>
<p>The Rete algorithm is designed to sacrifice <a href="/wiki/Computer_memory" title="Computer memory">memory</a> for increased speed. In most cases, the speed increase over naïve implementations is several orders of magnitude (because Rete performance is theoretically independent of the number of rules in the system). In very large expert systems, however, the original Rete algorithm tends to run into memory consumption problems. Other algorithms, both novel and Rete-based, have since been designed which require less memory.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Description"><span class="tocnumber">1</span> <span class="toctext">Description</span></a>
<ul>
<li class="toclevel-2"><a href="#Alpha_Network"><span class="tocnumber">1.1</span> <span class="toctext">Alpha Network</span></a></li>
<li class="toclevel-2"><a href="#Beta_Network"><span class="tocnumber">1.2</span> <span class="toctext">Beta Network</span></a></li>
<li class="toclevel-2"><a href="#Conflict_Resolution"><span class="tocnumber">1.3</span> <span class="toctext">Conflict Resolution</span></a></li>
<li class="toclevel-2"><a href="#Production_Execution"><span class="tocnumber">1.4</span> <span class="toctext">Production Execution</span></a></li>
<li class="toclevel-2"><a href="#Existential_and_Universal_Quantifications"><span class="tocnumber">1.5</span> <span class="toctext">Existential and Universal Quantifications</span></a></li>
<li class="toclevel-2"><a href="#Memory_Indexing"><span class="tocnumber">1.6</span> <span class="toctext">Memory Indexing</span></a></li>
<li class="toclevel-2"><a href="#Removal_of_WMEs_and_WME_lists"><span class="tocnumber">1.7</span> <span class="toctext">Removal of WMEs and WME lists</span></a></li>
<li class="toclevel-2"><a href="#Handling_OR.E2.80.99ed_conditions"><span class="tocnumber">1.8</span> <span class="toctext">Handling OR’ed conditions</span></a></li>
<li class="toclevel-2"><a href="#Diagram"><span class="tocnumber">1.9</span> <span class="toctext">Diagram</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Miscellaneous_Considerations"><span class="tocnumber">2</span> <span class="toctext">Miscellaneous Considerations</span></a></li>
<li class="toclevel-1"><a href="#Optimisation_and_Performance"><span class="tocnumber">3</span> <span class="toctext">Optimisation and Performance</span></a></li>
<li class="toclevel-1"><a href="#Rete_II"><span class="tocnumber">4</span> <span class="toctext">Rete II</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">5</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">7</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Description" id="Description"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=1" title="Edit section: Description">edit</a>]</span> <span class="mw-headline">Description</span></h2>
<p>The Rete algorithm provides a generalized logical description of an implementation of functionality responsible for matching data <a href="/wiki/Tuple" title="Tuple">tuples</a> (‘facts’) against <a href="/wiki/AI_production" title="AI production" class="mw-redirect">productions</a> (‘<a href="/wiki/Rule" title="Rule">rules</a>’) in a pattern-matching <a href="/wiki/Production_system" title="Production system">production system</a> (a category of <a href="/wiki/Rule_engine" title="Rule engine" class="mw-redirect">rule engine</a>). A production consists of one or more conditions and a set of actions which may be undertaken for each complete set of facts that match the conditions. Conditions test fact <a href="/wiki/Attribute_(computing)" title="Attribute (computing)">attributes</a>, including fact type specifiers/identifiers. The Rete algorithm exhibits the following major characteristics:</p>
<ul>
<li>It reduces or eliminates certain types of redundancy through the use of node sharing.</li>
<li>It stores partial matches when performing <a href="/wiki/Logical_conjunction" title="Logical conjunction">joins</a> between different fact types. This, in turn, allows production systems to avoid complete re-evaluation of all facts each time changes are made to the production system’s working memory. Instead, the production system needs only to evaluate the changes (deltas) to working memory.</li>
<li>It allows for efficient removal of memory elements when facts are retracted from working memory.</li>
</ul>
<p>The Rete algorithm is widely used to implement matching functionality within pattern-matching engines that exploit a match-resolve-act cycle to support <a href="/wiki/Forward_chaining" title="Forward chaining">forward chaining</a> and <a href="/wiki/Inference" title="Inference">inferencing</a>.</p>
<p>Retes are <a href="/wiki/Directed_acyclic_graph" title="Directed acyclic graph">directed acyclic graphs</a> that represent higher-level rule sets. They are generally represented at run-time using a network of in-memory objects. These networks match rule conditions (patterns) to facts (relational data tuples). Rete networks act as a type of relational query processor, performing <a href="/wiki/Projection_(relational_algebra)" title="Projection (relational algebra)">projections</a>, <a href="/wiki/Selection_(relational_algebra)" title="Selection (relational algebra)">selections</a> and joins conditionally on arbitrary numbers of data tuples.</p>
<p>Productions (rules) are typically captured and defined by <a href="/wiki/Business_analyst" title="Business analyst">analysts</a> and <a href="/wiki/Software_developer" title="Software developer">developers</a> using some high-level rules language. They are collected into rule sets which are then translated, often at run time, into an executable Rete.</p>
<p>When facts are ‘asserted’ to working memory, the engine creates ‘working memory elements’ (WMEs) for each fact. Facts are n-tuples, and may therefore contain an arbitrary number of data items. Each WME may hold an entire n-tuple, or, alternatively, each fact may be represented by a set of WMEs where each WME contains a fixed-length tuple. In this case, tuples are typically triplets (3-tuples).</p>
<p>Each WME enters the Rete network at a single root node. The root node passes each WME on to its child nodes, and each WME may then be propagated through the network, possibly being stored in intermediate memories, until it arrives at a terminal node.</p>
<p><a name="Alpha_Network" id="Alpha_Network"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=2" title="Edit section: Alpha Network">edit</a>]</span> <span class="mw-headline">Alpha Network</span></h3>
<p>The ‘left’ (alpha) side of the node graph forms a discrimination network responsible for selecting individual WMEs based on simple conditional tests which match WME attributes against constant values. Nodes in the discrimination network may also perform tests that compare two or more attributes of the same WME. If a WME is successfully matched against the conditions represented by one node, it is passed to the next node. In most engines, the immediate child nodes of the root node are used to test the entity identifier or fact type of each WME. Hence, all the WMEs which represent the same <a href="/wiki/Entity" title="Entity">entity</a> type typically traverse a given branch of nodes in the discrimination network.</p>
<p>Within the discrimination network, each branch of alpha nodes (also called 1-input nodes) terminates at a memory, called an ‘alpha’ memory. These memories store collections of WMEs that match each condition in each node in a given node branch. WMEs that fail to match at least one condition in a branch are not materialised within the corresponding alpha memory. Alpha node branches may fork in order to minimise condition redundancy.</p>
<p>A possible variation is to introduce additional memories for each intermediate node in the discrimination network. This increases the overhead of the Rete, but may have advantages in situations where rules are dynamically added to or removed from the Rete, making it easier to vary the topography of the discrimination network dynamically.</p>
<p>An alternative implementation is described by <a href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" class="external text" title="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" rel="nofollow">Doorenbos</a>. In this case, the discrimination network is replaced by a set of memories and an <a href="/wiki/Index_(information_technology)" title="Index (information technology)">index</a>. The index may be implemented using a <a href="/wiki/Hash_table" title="Hash table">hash table</a>. Each memory holds WMEs that match a single conditional pattern, and the index is used to reference memories by their pattern. This approach is only practical when WMEs represent fixed-length tuples, and the length of each tuple is short (e.g., 3-tuples). In addition, the approach only applies to conditional patterns that perform <a href="/wiki/Equality_(mathematics)" title="Equality (mathematics)">equality</a> tests against <a href="/wiki/Variable#Constants" title="Variable">constant</a> values. When a WME enters the Rete, the index is used to locate a set of memories whose conditional pattern matches the WME attributes, and the WME is then added directly to each of these memories. In itself, this implementation contains no 1-input nodes. However, in order to implement non-equality tests, the Rete may contain additional 1-input node networks through which WMEs are passed before being placed in a memory. Alternatively, non-equality tests may be performed in the beta network described below.</p>
<p><a name="Beta_Network" id="Beta_Network"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=3" title="Edit section: Beta Network">edit</a>]</span> <span class="mw-headline">Beta Network</span></h3>
<p>The ‘right’ (beta) side of the graph chiefly performs joins between different WMEs. It is optional, and is only included if required. It consists of 2-input nodes where each node has a ‘left’ and a ‘right’ input. Each beta node sends its output to a ‘beta’ memory.</p>
<p>Beta nodes process tokens. A token is a unit of storage within a memory and also a unit of exchange between memories and nodes. In many implementations, tokens are introduced within alpha memories where they are used to hold single WMEs. These tokens are then passed to the beta network.</p>
<p>Each beta node performs its work and, as a result, may create new tokens to hold a list of WMEs representing a partial match. These extended tokens are then stored in beta memories, and passed to subsequent beta nodes. In this case, the beta nodes typically pass lists of WMEs through the beta network by copying existing WME lists from each received token into new tokens and then adding a further WMEs to the lists as a result of performing a join or some other action. The new tokens are then stored in the output memory.</p>
<p>A common variation is to build <a href="/wiki/Linked_list" title="Linked list">linked lists</a> of tokens where each token holds a single WME. In this case, lists of WMEs for a partial match are represented by the linked list of tokens. This approach may be more optimal because it eliminates the need to copy lists of WMEs from one token to another. Instead, a beta node needs only to create a new token to hold a WME it wishes to join to the partial match list, and then link the new token to a parent token stored in the input beta memory. The new token now forms the head of the token list, and is stored in the output beta memory.</p>
<p>In descriptions of Rete, it is common to refer to token passing within the beta network. In this article, however, we will describe data propagation in terms of WME lists, rather than tokens, in recognition of different implementation options and the underlying purpose and use of tokens. As any one WME list passes through the beta network, new WMEs may be added to it, and the list may be stored in beta memories. A WME list in a beta memory represents a partial match for the conditions in a given production.</p>
<p>WME lists that reach the end of a branch of beta nodes represent a complete match for a single production, and are passed to terminal nodes. These nodes are sometimes called ‘p-nodes’, where ‘p’ stands for ‘production’. Each terminal node represents a single production, and each WME list that arrives at a terminal node represents a complete set of matching WMEs for the conditions in that production. For each WME list it receives, a production node will ‘activate’ a new production instance on the ‘agenda’. Agendas are typically implemented as <a href="/wiki/Priority_queue" title="Priority queue">prioritised queues</a>.</p>
<p>Beta nodes typically perform joins between WME lists stored in beta memories and individual WMEs stored in alpha memories. Each beta node is associated with two input memories. An alpha memory holds WM and performs ‘right’ activations on the beta node each time it stores a new WME. A beta memory holds WME lists and performs ‘left’ activations on the beta node each time it stores a new WME list. When a join node is right-activated, it compares one or more attributes of the newly stored WME from its input alpha memory against given attributes of specific WMEs in each WME list contained in the input beta memory. When a join node is left-activated it traverses a single newly stored WME list in the beta memory, retrieving specific attribute values of given WMEs. It compares these values with attribute values of each WME in the alpha memory.</p>
<p>Each beta node outputs WME lists which are either stored in a beta memory or sent directly to a terminal node. WME lists are stored in beta memories whenever the engine will perform additional left activations on subsequent beta nodes.</p>
<p>Logically, a beta node at the head of a branch of beta nodes is a special case because it takes no input from any beta memory higher in the network. Different engines handle this issue in different ways. Some engines use specialised adapter nodes to connect alpha memories to the left input of beta nodes. Other engines allow beta nodes to take input directly from two alpha memories, treating one as a ‘left’ input and the other as a ‘right’ input. In both cases, ‘head’ beta nodes take their input from two alpha memories.</p>
<p>In order to eliminate node redundancies, any one alpha or beta memory may be used to perform activations on multiple beta nodes. As well as join nodes, the beta network may contain additional node types, some of which are described below. If a Rete contains no beta network, alpha nodes feed tokens, each containing a single WME, directly to p-nodes. In this case, there may be no need to store WMEs in alpha memories.</p>
<p><a name="Conflict_Resolution" id="Conflict_Resolution"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=4" title="Edit section: Conflict Resolution">edit</a>]</span> <span class="mw-headline">Conflict Resolution</span></h3>
<p>During any one match-resolve-act cycle, the engine will find all possible matches for the facts currently asserted to working memory. Once all the current matches have been found, and corresponding production instances have been activated on the agenda, the engine determines an order in which the production instances may be ‘fired’. This is termed ‘conflict resolution’, and the list of activated production instances is termed the ‘conflict set’. The order may be based on rule priority (salience), rule order, the time at which facts contained in each instance were asserted to the working memory, the complexity of each production or some other criteria. Many engines allow rule developers to select between different conflict resolution strategies or to chain a selection of multiple strategies.</p>
<p>Conflict resolution is not defined as part of the Rete algorithm, but is used alongside the algorithm. Some specialised production systems do not perform conflict resolution.</p>
<p><a name="Production_Execution" id="Production_Execution"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=5" title="Edit section: Production Execution">edit</a>]</span> <span class="mw-headline">Production Execution</span></h3>
<p>Having performed conflict resolution, the engine now ‘fires’ the first production instance, executing a list of actions associated with the production. The actions act on the data represented by the production instance’s WME list.</p>
<p>By default, the engine will continue to fire each production instance in order until all production instances have been fired. Each production instance will fire only once, at most, during any one match-resolve-act cycle. This characteristic is termed ‘refraction’. However, the sequence of production instance firings may be interrupted at any stage by performing changes to the working memory. Rule actions can contain instructions to assert or retract WMEs from the ‘working memory’ of the engine. Each time any single production instance performs one or more such changes, the engine immediately enters a new match-resolve-act cycle. This includes ‘updates’ to WMEs currently in the working memory. Updates are represented by retracting and then re-asserting the WME. The engine undertakes matching of the changed data which, in turn, may result in changes to the list of production instances on the agenda. Hence, after the actions for any one specific production instance have been executed, previously activated instances may have been de-activated and removed from the agenda, and new instances may have been activated.</p>
<p>As part of the new match-resolve-act cycle, the engine performs conflict resolution on the agenda and then executes the current first instance. The engine continues to fire production instances, and to enter new match-resolve-act cycles, until no further production instances exist on the agenda. At this point the rule engine is deemed to have completed its work, and halts.</p>
<p>Some engines support advanced refraction strategies in which certain production instances executed in a previous cycle are not re-executed in the new cycle, even though they may still exist on the agenda.</p>
<p>It is possible for the engine to enter into never-ending loops in which the agenda never reaches the empty state. For this reason, most engines support explicit ‘halt’ verbs that can be invoked from production action lists. They may also provide automatic <a href="/wiki/Cycle_detection" title="Cycle detection">loop detection</a> in which never-ending loops are automatically halted after a given number of iterations. Some engines support a model in which, instead of halting when the agenda is empty, the engine enters a wait state until new facts are asserted externally.</p>
<p>As for conflict resolution, the firing of activated production instances is not a feature of the Rete algorithm. However, it is a central feature of engines that use Rete networks. Some of the optimisations offered by Rete networks are only useful in scenarios where the engine performs multiple match-resolve-act cycles.</p>
<p><a name="Existential_and_Universal_Quantifications" id="Existential_and_Universal_Quantifications"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=6" title="Edit section: Existential and Universal Quantifications">edit</a>]</span> <span class="mw-headline">Existential and Universal Quantifications</span></h3>
<p>Conditional tests are most commonly used to perform selections and joins on individual tuples. However, by implementing additional beta node types, it is possible for Rete networks to perform <a href="/wiki/Quantification" title="Quantification">quantifications</a>. <a href="/wiki/Existential_quantification" title="Existential quantification">Existential quantification</a> involves testing for the existence of at least one set of matching WMEs in working memory. <a href="/wiki/Universal_quantification" title="Universal quantification">Universal quantification</a> involves testing that an entire set of WMEs in working memory meets a given condition. A variation of universal quantification might test that a given number of WMEs, drawn from a set of WMEs, meets a given criteria. This might be in terms of testing for either an exact number or a minimum number of matches.</p>
<p>Quantification is not universally implemented in Rete engines, and, where it is supported, several variations exist. A variant of existential quantification referred to as ‘negation’ is widely, though not universally, supported, and is described in seminal documents. Existentially negated conditions and conjunctions involve the use of specialised beta nodes that test for non-existence of matching WMEs or sets of WMEs. These nodes propagate WME lists only when no match is found. The exact implementation of negation varies. In one approach, the node maintains a simple count on each WME list it receives from its left input. The count specifies the number of matches found with WMEs received from the right input. The node only propagates WME lists whose count is zero. In another approach, the node maintains an additional memory on each WME list received from the left input. These memories are a form of beta memory, and store WME lists for each match with WMEs received on the right input. If a WME list does not have any WME lists in its memory, it is propagated down the network. In this approach, negation nodes generally activate further beta nodes directly, rather than storing their output in an additional beta memory. Negation nodes provide a form of '<a href="/wiki/Negation_as_failure" title="Negation as failure">negation as failure</a>'.</p>
<p>When changes are made to working memory, a WME list that previously matched no WMEs may now match newly asserted WMEs. In this case, the propagated WME list and all its extended copies need to be retracted from beta memories further down the network. The second approach described above is often used to support efficient mechanisms for removal of WME lists. When WME lists are removed, any corresponding production instances are de-activated and removed from the agenda.</p>
<p>Existential quantification can be performed by combining two negation beta nodes. This represents the semantics of <a href="/wiki/Double_negation" title="Double negation" class="mw-redirect">double negation</a> (e.g., ‘If NOT NOT any matching WMEs, then…’). This is a common approach taken by several production systems.</p>
<p><a name="Memory_Indexing" id="Memory_Indexing"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=7" title="Edit section: Memory Indexing">edit</a>]</span> <span class="mw-headline">Memory Indexing</span></h3>
<p>The Rete algorithm does not mandate any specific approach to indexing the working memory. However, most modern production systems provide indexing mechanisms. In some cases, only beta memories are indexed, whilst in others, indexing is used for both alpha and beta memories. A good indexing strategy is a major factor in deciding the overall performance of a production system, especially when executing rule sets that result in highly combinatorial pattern matching (i.e., intensive use of beta join nodes), or, for some engines, when executing rules sets that perform a significant number of WME retractions during multiple match-resolve-act cycles. Memories are often implemented using combinations of hash tables, and hash values are used to perform conditional joins on subsets of WME lists and WMEs, rather than on the entire contents of memories. This, in turn, often significantly reduces the number of evaluations performed by the Rete network.</p>
<p><a name="Removal_of_WMEs_and_WME_lists" id="Removal_of_WMEs_and_WME_lists"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=8" title="Edit section: Removal of WMEs and WME lists">edit</a>]</span> <span class="mw-headline">Removal of WMEs and WME lists</span></h3>
<p>When a WME is retracted from working memory, it must be removed from every alpha memory in which it is stored. In addition, WME lists that contain the WME must be removed from beta memories, and activated production instances for these WME lists must be de-activated and removed from the agenda. Several implementation variations exist, including tree-based and rematch-based removal. Memory indexing may be used in some cases to optimise removal.</p>
<p><a name="Handling_OR.E2.80.99ed_conditions" id="Handling_OR.E2.80.99ed_conditions"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=9" title="Edit section: Handling OR’ed conditions">edit</a>]</span> <span class="mw-headline">Handling OR’ed conditions</span></h3>
<p>When defining productions in a rule set, it is common to allow conditions to be grouped using an ‘OR’ <a href="/wiki/Logical_connective" title="Logical connective">connective</a>. In many production systems, this is handled by interpreting a single production containing multiple OR’ed patterns as the equivalent of multiple productions. The resulting Rete network contains sets of terminal nodes which, together, represent single productions. This approach disallows any form of short-circuiting of the OR’ed conditions. It can also, in some cases, lead to duplicate production instances being activated on the agenda where the same set of WMEs match multiple internal productions. Some engines provide agenda de-duplication in order to handle this issue.</p>
<p><a name="Diagram" id="Diagram"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=10" title="Edit section: Diagram">edit</a>]</span> <span class="mw-headline">Diagram</span></h3>
<p>The following diagram illustrates the basic Rete topography, and shows the associations between different node types and memories.</p>
<div class="center">
<div class="thumb tnone">
<div class="thumbinner" style="width:182px;"><a href="/wiki/File:Rete.JPG" class="image" title="Illustrates the basic Rete."><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/9/92/Rete.JPG/180px-Rete.JPG" width="180" height="126" border="0" class="thumbimage" /></a>
<div class="thumbcaption">
<div class="magnify"><a href="/wiki/File:Rete.JPG" class="internal" title="Enlarge"><img src="/skins-1.5/common/images/magnify-clip.png" width="15" height="11" alt="" /></a></div>
Illustrates the basic Rete.</div>
</div>
</div>
</div>
<ul>
<li>Most implementations use type nodes to perform the first level of selection on n-tuple working memory elements. Type nodes can be considered as specialized select nodes. They discriminate between different tuple relation types.</li>
<li>The diagram does not illustrate the use of specialized nodes types such as negated conjunction nodes. Some engines implement several different node specialisations in order to extend functionality and maximise optimisation.</li>
<li>The diagram provides a logical view of the Rete. Implementations may differ in physical detail. In particular, the diagram shows ‘dummy’ inputs providing right activations at the head of beta node branches. Engines may implement other approaches, such as adapters that allow alpha memories to perform right activations directly.</li>
<li>The diagram does not illustrate all node-sharing possibilities.</li>
</ul>
<p>For a more detailed and complete description of the Rete algorithm, see chapter 2 of Production Matching for Large Learning Systems by Robert Doorenbos (see link below).</p>
<p><a name="Miscellaneous_Considerations" id="Miscellaneous_Considerations"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=11" title="Edit section: Miscellaneous Considerations">edit</a>]</span> <span class="mw-headline">Miscellaneous Considerations</span></h2>
<p>Although not defined by the Rete algorithm, some engines provide extended functionality to support greater control of <a href="/wiki/Truth_maintenance_systems" title="Truth maintenance systems" class="mw-redirect">truth maintenance</a>. For example, when a match is found for one production, this may result in the assertion of new WMEs which, in turn, match the conditions for another production. If a subsequent change to working memory causes the first match to become invalid, it may be that this implies that the second match is also invalid. The Rete algorithm does not define any mechanism to define and handle these logical truth dependencies automatically. Some engines, however, support additional functionality in which truth dependencies can be automatically maintained. In this case, the retraction of one WME may lead to the automatic retraction of additional WMEs in order to maintain logical truth assertions.</p>
<p>The Rete algorithm does not define any approach to justification. Justification refers to mechanisms commonly required in <a href="/wiki/Expert_systems" title="Expert systems" class="mw-redirect">expert</a> and decision systems in which, at its simplest, the system reports each of the inner decisions used to reach some final conclusion. For example, an expert system might justify a conclusion that an animal is an elephant by reporting that it is large, grey, has big ears, a trunk and tusks. Some engines provide built-in justification systems in conjunction with their implementation of the Rete algorithm.</p>
<p>This article does not provide an exhaustive description of every possible variation or extension of the Rete algorithm. Other considerations and innovations exist. For example, engines may provide specialised support within the Rete network in order to apply pattern-matching rule processing to specific <a href="/wiki/Data_types" title="Data types" class="mw-redirect">data types</a> and sources such as <a href="/wiki/Object_(computer_science)" title="Object (computer science)">programmatic objects</a>, <a href="/wiki/XML" title="XML">XML</a> data or <a href="/wiki/Table_(database)" title="Table (database)">relational data tables</a>. Another example concerns additional time-stamping facilities provided by many engines for each WME entering a Rete network, and the use these time-stamps in conjunction with conflict resolution strategies. Engines exhibit significant variation in the way they allow programmatic access to the engine and its working memory, and may extend the basic Rete model to support forms of parallel and distributed processing.</p>
<p><a name="Optimisation_and_Performance" id="Optimisation_and_Performance"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=12" title="Edit section: Optimisation and Performance">edit</a>]</span> <span class="mw-headline">Optimisation and Performance</span></h2>
<p>Several optimisations for Rete have been identified and described in academic literature. Several of these, however, apply only in very specific scenarios, and therefore often have little or no application in a general-purpose rules engine. In addition, alternative algorithms such as TREAT and LEAPS have been formulated which may provide additional performance improvements. There are currently very few commercial or open source examples of productions systems that support these alternative algorithms.</p>
<p>The Rete algorithm is orientated to scenarios where forward chaining and ‘inferencing’ is used to calculate new facts from existing facts, or to filter and discard facts in order to arrive at some conclusion. It is also exploited as a reasonably efficient mechanism for performing highly combinatorial evaluations of facts where large numbers of joins must be performed between fact tuples. Other approaches to performing rule evaluation, such as the use of <a href="/wiki/Decision_trees" title="Decision trees" class="mw-redirect">decision trees</a>, or the implementation of sequential engines, may be more appropriate for simple scenarios, and should be considered as possible alternatives.</p>
<p><a name="Rete_II" id="Rete_II"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=13" title="Edit section: Rete II">edit</a>]</span> <span class="mw-headline">Rete II</span></h2>
<p>In the 1980s Charles L. Forgy developed a successor to the Rete algorithm named <b>Rete II</b> <a href="http://www.pst.com/rete2.htm" class="external autonumber" title="http://www.pst.com/rete2.htm" rel="nofollow">[1]</a>. Unlike the original Rete (which is public domain) this algorithm was not disclosed. Rete II claims better performance for more complex problems (even <a href="http://www.pst.com/benchcr2.htm" class="external text" title="http://www.pst.com/benchcr2.htm" rel="nofollow">orders of magnitude</a>), and is officially implemented in CLIPS/R2.</p>
<p>Rete II can be characterized by two areas of improvement; specific optimizations relating to the general performance of the Rete network (including the use of hashed memories in order to increase performance with larger sets of data), and the inclusion of a <a href="/wiki/Backward_chaining" title="Backward chaining">backward chaining</a> algorithm tailored to run on top of the Rete network. Backward chaining alone can account for the most extreme changes in benchmarks relating to Rete vs. Rete II.</p>
<p>Jess (at least versions 5.0 and later) also adds a backward chaining algorithm on top of the Rete network, but it cannot be said to fully implement Rete II, in part due to the fact that no full specification is publicly available.</p>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=14" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<div class="references-small" style="margin-left:1.5em;">
<ul>
<li><a href="/wiki/Charles_Forgy" title="Charles Forgy">Charles Forgy</a>, "A network match routine for production systems." Working Paper, 1974.</li>
<li>Charles Forgy, "On the efficient implementation of production systems." Ph.D. Thesis, Carnegie-Mellon University, 1979.</li>
<li>Charles Forgy, "Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem", <i><a href="/wiki/Artificial_Intelligence_(journal)" title="Artificial Intelligence (journal)">Artificial Intelligence</a></i>, 19, pp 17-37, 1982</li>
</ul>
</div>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=15" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/Action_selection_mechanism" title="Action selection mechanism" class="mw-redirect">Action selection mechanism</a></li>
<li><a href="/wiki/Expert_system" title="Expert system">Expert system</a></li>
<li><a href="/wiki/Inference_engine" title="Inference engine">Inference engine</a></li>
<li><a href="/wiki/OPS5" title="OPS5">OPS5</a></li>
<li><a href="/wiki/Production_system" title="Production system">Production system</a></li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Rete_algorithm&amp;action=edit&amp;section=16" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" class="external text" title="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf" rel="nofollow">Production Matching for Large Learning Systems - R Doorenbos</a>Detailed and accessible description of Rete, also describes a variant named Rete/UL, optimised for large systems (PDF)</li>
<li><a href="http://www.cut-the-knot.org/classes/Last.shtml" class="external text" title="http://www.cut-the-knot.org/classes/Last.shtml" rel="nofollow">According to the Rules</a> (A short introduction from <a href="/wiki/Cut-the-knot" title="Cut-the-knot" class="mw-redirect">cut-the-knot</a>)</li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 46/1000000
Post-expand include size: 620/2048000 bytes
Template argument size: 185/2048000 bytes
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:172566-0!1!0!default!!en!2 and timestamp 20090407140621 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Rete_algorithm">http://en.wikipedia.org/wiki/Rete_algorithm</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Expert_systems" title="Category:Expert systems">Expert systems</a></span> | <span dir='ltr'><a href="/wiki/Category:Decision_theory" title="Category:Decision theory">Decision theory</a></span> | <span dir='ltr'><a href="/wiki/Category:Pattern_matching" title="Category:Pattern matching">Pattern matching</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Rete_algorithm" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Rete_algorithm" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Rete_algorithm&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Rete_algorithm&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Rete_algorithm" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Rete_algorithm" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Rete_algorithm" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Rete_algorithm&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Rete_algorithm&amp;oldid=265914088" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Rete_algorithm&amp;id=265914088">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Algoritmo_Rete">Español</a></li>
				<li class="interwiki-fa"><a href="http://fa.wikipedia.org/wiki/%D8%A7%D9%84%DA%AF%D9%88%D8%B1%DB%8C%D8%AA%D9%85_%D8%AA%D9%88%D8%B1%DB%8C%D9%86%D9%87">فارسی</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Algorithme_de_Rete">Français</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Algoritmo_rete">Italiano</a></li>
				<li class="interwiki-nl"><a href="http://nl.wikipedia.org/wiki/Rete-algoritme">Nederlands</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/Rete%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0">日本語</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 23 January 2009, at 14:09 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv102 in 0.069 secs. --></body></html>
