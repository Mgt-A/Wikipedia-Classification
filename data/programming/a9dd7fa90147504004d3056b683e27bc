<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="GUI software testing,Artificial intelligence,Command line interface,Computer science,Finite State Machine,GUI,Genetic algorithms,Graphical user interface,Microsoft,Model-based testing,Model-view-controller" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=GUI_software_testing&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=GUI_software_testing&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>GUI software testing - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "GUI_software_testing";
		var wgTitle = "GUI software testing";
		var wgAction = "view";
		var wgArticleId = "8261215";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 287310507;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-GUI_software_testing skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">GUI software testing</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<div class="noprint tright portal" style="border:solid #aaa 1px;margin:0.5em 0 0.5em 0.5em;">
<table style="background:#f9f9f9; font-size:85%; line-height:110%;">
<tr>
<td><a href="/wiki/File:Portal.svg" class="image" title="Portal.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Portal.svg/28px-Portal.svg.png" width="28" height="28" border="0" /></a></td>
<td style="padding:0 0.2em;"><i><b><a href="/wiki/Portal:Software_Testing" title="Portal:Software Testing">Software Testing portal</a></b></i></td>
</tr>
</table>
</div>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>GUI software testing</b> is the process of testing a product that uses a <a href="/wiki/Graphical_user_interface" title="Graphical user interface">graphical user interface</a>, to ensure it meets its written specifications. This is normally done through the use of a variety of <a href="/wiki/Test_case" title="Test case">test cases</a>.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Testing_GUI_Applications"><span class="tocnumber">1</span> <span class="toctext">Testing GUI Applications</span></a></li>
<li class="toclevel-1"><a href="#Test_Case_Generation"><span class="tocnumber">2</span> <span class="toctext">Test Case Generation</span></a></li>
<li class="toclevel-1"><a href="#Planning_and_artificial_intelligence"><span class="tocnumber">3</span> <span class="toctext">Planning and artificial intelligence</span></a></li>
<li class="toclevel-1"><a href="#Event_Flow_Graphs"><span class="tocnumber">4</span> <span class="toctext">Event Flow Graphs</span></a></li>
<li class="toclevel-1"><a href="#Running_the_test_cases"><span class="tocnumber">5</span> <span class="toctext">Running the test cases</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">7</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Testing_GUI_Applications" id="Testing_GUI_Applications"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=GUI_software_testing&amp;action=edit&amp;section=1" title="Edit section: Testing GUI Applications">edit</a>]</span> <span class="mw-headline">Testing GUI Applications</span></h2>
<p>Most clients in client/server and web-based systems deliver system functionality using a <a href="/wiki/GUI" title="GUI" class="mw-redirect">GUI</a>. When testing complete systems, the tester must grapple with the additional functionality provided by the GUI. GUIs make testing systems more difficult for many reasons: the event-driven nature of GUIs, unsolicited events, many ways in/many ways out and the infinite input domain problems make it likely that the programmer has introduced errors because he could not test every path.</p>
<p>Available literature on testing GUIs almost exclusively tends to focus on tools as the solution to the GUI testing problem. With few exceptions, papers on this topic pay attention to GUI test design, but have concentrated on how automated regression-test suites can be built and maintained.</p>
<p><a name="Test_Case_Generation" id="Test_Case_Generation"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=GUI_software_testing&amp;action=edit&amp;section=2" title="Edit section: Test Case Generation">edit</a>]</span> <span class="mw-headline">Test Case Generation</span></h2>
<p>To generate a ‘good’ set of <a href="/wiki/Test_case" title="Test case">test cases</a>, the test designer must be certain that their suite covers all the functionality of the system and also has to be sure that the suite fully exercises the <a href="/wiki/GUI" title="GUI" class="mw-redirect">GUI</a> itself. The difficulty in accomplishing this task is twofold: one has to deal with domain size and then one has to deal with sequences. In addition, the tester faces more difficulty when they have to do <a href="/wiki/Regression_testing" title="Regression testing">regression testing</a>.</p>
<p>The size problem can be easily illustrated. Unlike a <a href="/wiki/Command_line_interface" title="Command line interface" class="mw-redirect">CLI</a> (command line interface) system, a GUI has many operations that need to be tested. A very small program such as <a href="/wiki/Microsoft" title="Microsoft">Microsoft</a> <a href="/wiki/WordPad" title="WordPad">WordPad</a> has 325 possible GUI operations<sup id="cite_ref-one_0-0" class="reference"><a href="#cite_note-one-0" title=""><span>[</span>1<span>]</span></a></sup>. In a large program, the number of operations can easily be an <a href="/wiki/Order_of_magnitude" title="Order of magnitude">order of magnitude</a> larger.</p>
<p>The second problem is the sequencing problem. Some functionality of the system may only be accomplishable by following some complex sequence of GUI events. For example, to open a file a user may have to click on the File Menu and then select the Open operation, and then use a dialog box to specify the file name, and then focus the application on the newly opened window. Obviously, increasing the number of possible operations increases the sequencing problem exponentially. This can become a serious issue when the tester is creating test cases manually.</p>
<p><a href="/wiki/Regression_testing" title="Regression testing">Regression testing</a> becomes a problem with GUIs as well. This is because the GUI may change significantly across versions of the application, even though the underlying application may not. A test designed to follow a certain path through the GUI may not be able to follow that path since a button, menu item, or dialog may have changed location or appearance.</p>
<p>These issues have driven the GUI testing problem domain towards automation. Many different techniques have been proposed to automatically generate test suites that are complete and that simulate user behavior.</p>
<p>Most of the techniques used to test GUIs attempt to build on techniques previously used to test CLI programs. However, most of these have scaling problems when they are applied to GUI’s. For example, <a href="/wiki/Finite_State_Machine" title="Finite State Machine" class="mw-redirect">Finite State Machine</a>-based modeling<sup id="cite_ref-two_1-0" class="reference"><a href="#cite_note-two-1" title=""><span>[</span>2<span>]</span></a></sup><sup id="cite_ref-three_2-0" class="reference"><a href="#cite_note-three-2" title=""><span>[</span>3<span>]</span></a></sup> — where a system is modeled as a finite state machine and a program is used to generate test cases that exercise all states — can work well on a system that has a limited number of states but may become overly complex and unwieldy for a GUI (see also <a href="/wiki/Model-based_testing" title="Model-based testing">model-based testing</a>).</p>
<p><a name="Planning_and_artificial_intelligence" id="Planning_and_artificial_intelligence"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=GUI_software_testing&amp;action=edit&amp;section=3" title="Edit section: Planning and artificial intelligence">edit</a>]</span> <span class="mw-headline">Planning and artificial intelligence</span></h2>
<p>A novel approach to test suite generation, adapted from a <b>CLI</b> technique<sup id="cite_ref-four_3-0" class="reference"><a href="#cite_note-four-3" title=""><span>[</span>4<span>]</span></a></sup>. involves using a planning system<sup id="cite_ref-Mem01_4-0" class="reference"><a href="#cite_note-Mem01-4" title=""><span>[</span>5<span>]</span></a></sup>. Planning is a well-studied technique from the <a href="/wiki/Artificial_intelligence" title="Artificial intelligence">artificial intelligence</a> (AI) domain that attempts to solve problems that involve four parameters:</p>
<ul>
<li>an initial state,</li>
<li>a goal state,</li>
<li>a set of operators, and</li>
<li>a set of objects to operate on.</li>
</ul>
<p>Planning systems determine a path from the initial state to the goal state by using the operators. An extremely simple planning problem would be one where you had two words and one operation called ‘change a letter’ that allowed you to change one letter in a word to another letter – the goal of the problem would be to change one word into another.</p>
<p>For GUI testing, the problem is a bit more complex. In <sup id="cite_ref-one_0-1" class="reference"><a href="#cite_note-one-0" title=""><span>[</span>1<span>]</span></a></sup> the authors used a planner called IPP<sup id="cite_ref-five_5-0" class="reference"><a href="#cite_note-five-5" title=""><span>[</span>6<span>]</span></a></sup> to demonstrate this technique. The method used is very simple to understand. First, the systems UI is analyzed to determine what operations are possible. These operations become the operators used in the planning problem. Next an initial system state is determined. Next a goal state is determined that the tester feels would allow exercising of the system. Lastly the planning system is used to determine a path from the initial state to the goal state. This path becomes the test plan.</p>
<p>Using a planner to generate the test cases has some specific advantages over manual generation. A planning system, by its very nature, generates solutions to planning problems in a way that is very beneficial to the tester:</p>
<ol>
<li>The plans are always valid. What this means is that the output of the system can be one of two things, a valid and correct plan that uses the operators to attain the goal state or no plan at all. This is beneficial because much time can be wasted when manually creating a test suite due to invalid test cases that the tester thought would work but didn’t.</li>
<li>A planning system pays attention to order. Often to test a certain function, the test case must be complex and follow a path through the GUI where the operations are performed in a specific order. When done manually, this can lead to errors and also can be quite difficult and time consuming to do.</li>
<li>Finally, and most importantly, a planning system is goal oriented. What this means and what makes this fact so important is that the tester is focusing test suite generation on what is most important, testing the functionality of the system.</li>
</ol>
<p>When manually creating a test suite, the tester is more focused on how to test a function (i.&#160;e. the specific path through the GUI). By using a planning system, the path is taken care of and the tester can focus on what function to test. An additional benefit of this is that a planning system is not restricted in any way when generating the path and may often find a path that was never anticipated by the tester. This problem is a very important one to combat<sup id="cite_ref-six_6-0" class="reference"><a href="#cite_note-six-6" title=""><span>[</span>7<span>]</span></a></sup>.</p>
<p>Another interesting method of generating GUI test cases uses the theory that good GUI test coverage can be attained by simulating a novice user. One can speculate that an expert user of a system will follow a very direct and predictable path through a GUI and a novice user would follow a more random path. The theory therefore is that if we used an expert to test the GUI, many possible system states would never be achieved. A novice user, however, would follow a much more varied, meandering and unexpected path to achieve the same goal so it’s therefore more desirable to create test suites that simulate novice usage because they will test more.</p>
<p>The difficulty lies in generating test suites that simulate ‘novice’ system usage. Using <a href="/wiki/Genetic_algorithms" title="Genetic algorithms" class="mw-redirect">Genetic algorithms</a> is one proposed way to solve this problem<sup id="cite_ref-six_6-1" class="reference"><a href="#cite_note-six-6" title=""><span>[</span>7<span>]</span></a></sup>. Novice paths through the system are not random paths. First, a novice user will learn over time and generally won’t make the same mistakes repeatedly, and, secondly, a novice user is not analogous to a group of monkeys trying to type Hamlet, but someone who is following a plan and probably has some domain or system knowledge.</p>
<p>Genetic algorithms work as follows: a set of ‘genes’ are created randomly and then are subjected to some task. The genes that complete the task best are kept and the ones that don’t are discarded. The process is again repeated with the surviving genes being replicated and the rest of the set filled in with more random genes. Eventually one gene (or a small set of genes if there is some threshold set) will be the only gene in the set and is naturally the best fit for the given problem.</p>
<p>For the purposes of the GUI testing, the method works as follows. Each gene is essentially a list of random integer values of some fixed length. Each of these genes represents a path through the GUI. For example, for a given tree of widgets, the first value in the gene (each value is called an allele) would select the widget to operate on, the following alleles would then fill in input to the widget depending on the number of possible inputs to the widget (for example a pull down list box would have one input…the selected list value). The success of the genes are scored by a criterion that rewards the best ‘novice’ behavior.</p>
<p>The system to do this testing described in<sup id="cite_ref-six_6-2" class="reference"><a href="#cite_note-six-6" title=""><span>[</span>7<span>]</span></a></sup> can be extended to any windowing system but is described on the X window system. The <a href="/wiki/X_Window" title="X Window" class="mw-redirect">X Window</a> system provides functionality (via <a href="/wiki/Category:X_servers" title="Category:X servers">XServer</a> and the editers' protocol) to dynamically send GUI input to and get GUI output from the program without directly using the GUI. For example, one can call XSendEvent() to simulate a click on a pull-down menu, and so forth. This system allows researchers to automate the gene creation and testing so for any given application under test, a set of novice user test cases can be created.</p>
<p><a name="Event_Flow_Graphs" id="Event_Flow_Graphs"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=GUI_software_testing&amp;action=edit&amp;section=4" title="Edit section: Event Flow Graphs">edit</a>]</span> <span class="mw-headline">Event Flow Graphs</span></h2>
<p>A recent breakthrough<sup id="cite_ref-efg_7-0" class="reference"><a href="#cite_note-efg-7" title=""><span>[</span>8<span>]</span></a></sup> in the field of automated GUI testing is a new graph model called the event-flow graph that represents events and event interactions. In much the same way as a control-flow graph represents all possible execution paths in a program, and a data-flow graph represents all possible definitions and uses of a memory location, the event-flow model represents all possible sequences of events that can be executed on the GUI. A GUI is decomposed into a hierarchy of modal dialogues; this hierarchy is represented as an integration tree; each modal dialogue is represented as an event-flow graph that shows all possible event execution paths in the dialogue.</p>
<p><a name="Running_the_test_cases" id="Running_the_test_cases"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=GUI_software_testing&amp;action=edit&amp;section=5" title="Edit section: Running the test cases">edit</a>]</span> <span class="mw-headline">Running the test cases</span></h2>
<p>At first the strategies were migrated and adapted from the CLI testing strategies. A popular method used in the CLI environment is capture/playback. Capture playback is a system where the system screen is “captured” as a bitmapped graphic at various times during system testing. This capturing allowed the tester to “play back” the testing process and compare the screens at the output phase of the test with expected screens. This validation could be automated since the screens would be identical if the case passed and different if the case failed.</p>
<p>Using capture/playback worked quite well in the CLI world but there are significant problems when one tries to implement it on a GUI-based system <sup id="cite_ref-seven_8-0" class="reference"><a href="#cite_note-seven-8" title=""><span>[</span>9<span>]</span></a></sup>. The most obvious problem one finds is that the screen in a GUI system may look different while the state of the underlying system is the same, making automated validation extremely difficult. This is because a GUI allows graphical objects to vary in appearance and placement on the screen. Fonts may be different, window colors or sizes may vary but the system output is basically the same. This would be obvious to a user, but not obvious to an automated validation system.</p>
<p>To combat this and other problems, testers have gone ‘under the hood’ and collected GUI interaction data from the underlying windowing system <sup id="cite_ref-eight_9-0" class="reference"><a href="#cite_note-eight-9" title=""><span>[</span>10<span>]</span></a></sup>. By capturing the window ‘events’ into logs the interactions with the system are now in a format that is decoupled from the appearance of the GUI. Now, only the event streams are captured. There is some filtering of the event streams necessary since the streams of events are usually very detailed and most events aren’t directly relevant to the problem. This approach can be made easier by using an <a href="/wiki/Model-view-controller" title="Model-view-controller" class="mw-redirect">MVC</a> architecture for example and making the view (i.&#160;e. the GUI here) as simple as possible while the model and the controller hold all the logic. Another approach is to use an <a href="/wiki/Web_application" title="Web application">HTML interface</a> or a <a href="/wiki/Three-tier_(computing)" title="Three-tier (computing)" class="mw-redirect">three-tier architecture</a> that makes it also possible to better separate the user interface from the rest of the application.</p>
<p>Another way to run tests on a GUI is to build a driver into the GUI so that commands or events can be sent to the software from another program<sup id="cite_ref-six_6-3" class="reference"><a href="#cite_note-six-6" title=""><span>[</span>7<span>]</span></a></sup>. This method of directly sending events to and receiving events from a system is highly desirable when testing, since the input and output testing can be fully automated and user error is eliminated.</p>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=GUI_software_testing&amp;action=edit&amp;section=6" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<div class="references-small">
<ol class="references">
<li id="cite_note-one-0">^ <a href="#cite_ref-one_0-0" title=""><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-one_0-1" title=""><sup><i><b>b</b></i></sup></a> Atif M. Memon, M.E. Pollack and M.L. Soffa. Using a Goal-driven Approach to Generate Test Cases for GUIs.</li>
<li id="cite_note-two-1"><b><a href="#cite_ref-two_1-0" title="">^</a></b> J.M. Clarke. Automated test generation from a Behavioral Model. In Proceedings of Pacific Northwest Software Quality Conference. IEEE Press, May 1998.</li>
<li id="cite_note-three-2"><b><a href="#cite_ref-three_2-0" title="">^</a></b> S. Esmelioglu and L. Apfelbaum. Automated Test generation, execution and reporting. In Proceedings of Pacific Northwest Software Quality Conference. IEEE Press, October 1997.</li>
<li id="cite_note-four-3"><b><a href="#cite_ref-four_3-0" title="">^</a></b> A. Howe, A. von Mayrhauser and R.T. Mraz. Test case generation as an AI planning problem. Automated Software Engineering, 4:77-106, 1997.</li>
<li id="cite_note-Mem01-4"><b><a href="#cite_ref-Mem01_4-0" title="">^</a></b> “Hierarchical GUI Test Case Generation Using Automated Planning” by Atif M. Memon, Martha E. Pollack, and Mary Lou Soffa. IEEE Trans. Softw. Eng., vol. 27, no. 2, 2001, pp. 144-155, IEEE Press.</li>
<li id="cite_note-five-5"><b><a href="#cite_ref-five_5-0" title="">^</a></b> J. Koehler, B. Nebel, J. Hoffman and Y. Dimopoulos. Extending planning graphs to an ADL subset. Lecture Notes in Computer Science, 1348:273, 1997.</li>
<li id="cite_note-six-6">^ <a href="#cite_ref-six_6-0" title=""><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-six_6-1" title=""><sup><i><b>b</b></i></sup></a> <a href="#cite_ref-six_6-2" title=""><sup><i><b>c</b></i></sup></a> <a href="#cite_ref-six_6-3" title=""><sup><i><b>d</b></i></sup></a> D.J. Kasik and H.G. George. Toward automatic generation of novice user test scripts. In M.J. Tauber, V. Bellotti, R. Jeffries, J.D. Mackinlay, and J. Nielsen, editors, Proceedings of the Conference on Human Factors in Computing Systems&#160;: Common Ground, pages 244-251, New York, 13-18 Apr. 1996, ACM Press.</li>
<li id="cite_note-efg-7"><b><a href="#cite_ref-efg_7-0" title="">^</a></b> “An event-flow model of GUI-based applications for testing” by Atif M. Memon. Software Testing, Verification and Reliability, vol. 17, no. 3, 2007, pp. 137-157, John Wiley and Sons Ltd. <a href="http://www.cs.umd.edu/~atif/papers/MemonSTVR2007-abstract.html" class="external autonumber" title="http://www.cs.umd.edu/~atif/papers/MemonSTVR2007-abstract.html" rel="nofollow">[1]</a></li>
<li id="cite_note-seven-8"><b><a href="#cite_ref-seven_8-0" title="">^</a></b> L.R. Kepple. The black art of GUI testing. Dr. Dobb’s Journal of Software Tools, 19(2):40, Feb. 1994.</li>
<li id="cite_note-eight-9"><b><a href="#cite_ref-eight_9-0" title="">^</a></b> M.L. Hammontree, J.J. Hendrickson and B.W. Hensley. Integrated data capture and analysis tools for research and testing on graphical user interfaces. In P. Bauersfeld, J. Bennett and G. Lynch, editors, Proceedings of the Conference on Human Factors in Computing System, pages 431-432, New York, NY, USA, May 1992. ACM Press.</li>
</ol>
</div>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=GUI_software_testing&amp;action=edit&amp;section=7" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li>Article <a href="http://www.methodsandtools.com/archive/archive.php?id=37" class="external text" title="http://www.methodsandtools.com/archive/archive.php?id=37" rel="nofollow">GUI Testing Checklist</a></li>
<li><a href="http://www.testingfaqs.org/t-gui.html" class="external text" title="http://www.testingfaqs.org/t-gui.html" rel="nofollow">GUI Test Drivers</a> Lists and describes tools rsp. frameworks in different programming languages</li>
<li><a href="http://www.youtube.com/watch?v=6LdsIVvxISU" class="external free" title="http://www.youtube.com/watch?v=6LdsIVvxISU" rel="nofollow">http://www.youtube.com/watch?v=6LdsIVvxISU</a> A talk at the Google Test Automation Conference by <a href="http://www.cs.umd.edu/~atif" class="external text" title="http://www.cs.umd.edu/~atif" rel="nofollow">Prof. Atif M Memon</a> on Model-Based GUI Testing.</li>
<li><a href="http://www.gerrardconsulting.com/GUI/TestGui.html" class="external text" title="http://www.gerrardconsulting.com/GUI/TestGui.html" rel="nofollow">Testing GUI Applications</a></li>
<li><a href="/wiki/Xnee" title="Xnee">Xnee</a>, a program that can be used to record and replay test.</li>
<li><a href="http://www.osec.ro/en/index.php/GUI_Automated_Tests/" class="external text" title="http://www.osec.ro/en/index.php/GUI_Automated_Tests/" rel="nofollow">GUI Automated Tests</a>, a program that can be used to record user actions (mouse and keyboard), to play recorded actions, to validate desktop after each action, create reports and has built-in integration with Cruise Control.</li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 223/1000000
Post-expand include size: 476/2048000 bytes
Template argument size: 32/2048000 bytes
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:8261215-0!1!0!default!!en!2 and timestamp 20090501194734 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/GUI_software_testing">http://en.wikipedia.org/wiki/GUI_software_testing</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Software_testing" title="Category:Software testing">Software testing</a></span> | <span dir='ltr'><a href="/wiki/Category:GUI_automation" title="Category:GUI automation">GUI automation</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/GUI_software_testing" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:GUI_software_testing" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=GUI_software_testing&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=GUI_software_testing&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=GUI_software_testing" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/GUI_software_testing" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/GUI_software_testing" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=GUI_software_testing&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=GUI_software_testing&amp;oldid=287310507" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=GUI_software_testing&amp;id=287310507">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Testowanie_graficznego_interfejsu_u%C5%BCytkownika">Polski</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 1 May 2009, at 19:47 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv77 in 0.098 secs. --></body></html>
