<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Combinatory logic,APL (programming language),Alonzo Church,Applicative computing systems,Associative,B,C,K,W System,B,C,K,W system,Belgium,Beta normal form,Big O notation,Categorical abstract machine" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Combinatory_logic&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Combinatory_logic&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Combinatory logic - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Combinatory_logic";
		var wgTitle = "Combinatory logic";
		var wgAction = "view";
		var wgArticleId = "149848";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 259894237;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Combinatory_logic skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Combinatory logic</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<table class="metadata plainlinks ambox ambox-move" style="">
<tr>
<td class="mbox-image">
<div style="width: 52px;"><a href="/wiki/File:Mergefrom.svg" class="image" title="Mergefrom.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/commons/thumb/0/0f/Mergefrom.svg/50px-Mergefrom.svg.png" width="50" height="20" border="0" /></a></div>
</td>
<td class="mbox-text" style="">It has been suggested that <i><a href="/wiki/SKI_combinator_calculus" title="SKI combinator calculus">SKI combinator calculus</a></i> be <a href="/wiki/Wikipedia:Merging_and_moving_pages" title="Wikipedia:Merging and moving pages" class="mw-redirect">merged</a> into this article or section. (<a href="/wiki/Talk:Combinatory_logic#Merger_proposal" title="Talk:Combinatory logic">Discuss</a>)</td>
</tr>
</table>
<div class="dablink">Not to be confused with <a href="/wiki/Combinational_logic" title="Combinational logic">combinational logic</a>, a topic in digital electronics.</div>
<p><b>Combinatory logic</b> is a notation introduced by <a href="/wiki/Moses_Sch%C3%B6nfinkel" title="Moses Schönfinkel">Moses Schönfinkel</a> and <a href="/wiki/Haskell_Curry" title="Haskell Curry">Haskell Curry</a> to eliminate the need for <a href="/wiki/Variable" title="Variable">variables</a> in <a href="/wiki/Mathematical_logic" title="Mathematical logic">mathematical logic</a>. It has more recently been used in computer science as a theoretical model of computation and also as a basis for the design of <a href="/wiki/Functional_programming_languages" title="Functional programming languages" class="mw-redirect">functional programming languages</a>. It is based on <b>combinators</b>. A combinator is a <a href="/wiki/Higher-order_function" title="Higher-order function">higher-order function</a> which, for defining a result from its arguments, solely uses function application and earlier defined combinators.</p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Combinatory_logic_in_mathematics"><span class="tocnumber">1</span> <span class="toctext">Combinatory logic in mathematics</span></a></li>
<li class="toclevel-1"><a href="#Combinatory_logic_in_computing"><span class="tocnumber">2</span> <span class="toctext">Combinatory logic in computing</span></a></li>
<li class="toclevel-1"><a href="#Summary_of_the_lambda_calculus"><span class="tocnumber">3</span> <span class="toctext">Summary of the lambda calculus</span></a></li>
<li class="toclevel-1"><a href="#Combinatory_calculi"><span class="tocnumber">4</span> <span class="toctext">Combinatory calculi</span></a>
<ul>
<li class="toclevel-2"><a href="#Combinatory_terms"><span class="tocnumber">4.1</span> <span class="toctext">Combinatory terms</span></a></li>
<li class="toclevel-2"><a href="#Reduction_in_combinatory_logic"><span class="tocnumber">4.2</span> <span class="toctext">Reduction in combinatory logic</span></a></li>
<li class="toclevel-2"><a href="#Examples_of_combinators"><span class="tocnumber">4.3</span> <span class="toctext">Examples of combinators</span></a></li>
<li class="toclevel-2"><a href="#Completeness_of_the_S-K_basis"><span class="tocnumber">4.4</span> <span class="toctext">Completeness of the S-K basis</span></a>
<ul>
<li class="toclevel-3"><a href="#Conversion_of_a_lambda_term_to_an_equivalent_combinatorial_term"><span class="tocnumber">4.4.1</span> <span class="toctext">Conversion of a lambda term to an equivalent combinatorial term</span></a></li>
<li class="toclevel-3"><a href="#Explanation_of_the_T.5B.C2.A0.5D_transformation"><span class="tocnumber">4.4.2</span> <span class="toctext">Explanation of the T[&#160;] transformation</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Simplifications_of_the_transformation"><span class="tocnumber">4.5</span> <span class="toctext">Simplifications of the transformation</span></a>
<ul>
<li class="toclevel-3"><a href="#.CE.B7-reduction"><span class="tocnumber">4.5.1</span> <span class="toctext">η-reduction</span></a></li>
<li class="toclevel-3"><a href="#One-point_basis"><span class="tocnumber">4.5.2</span> <span class="toctext">One-point basis</span></a></li>
<li class="toclevel-3"><a href="#Combinators_B.2C_C"><span class="tocnumber">4.5.3</span> <span class="toctext">Combinators B, C</span></a>
<ul>
<li class="toclevel-4"><a href="#CLK_versus_CLI_calculus"><span class="tocnumber">4.5.3.1</span> <span class="toctext">CL<sub>K</sub> versus CL<sub>I</sub> calculus</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2"><a href="#Reverse_conversion"><span class="tocnumber">4.6</span> <span class="toctext">Reverse conversion</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Undecidability_of_combinatorial_calculus"><span class="tocnumber">5</span> <span class="toctext">Undecidability of combinatorial calculus</span></a></li>
<li class="toclevel-1"><a href="#Applications"><span class="tocnumber">6</span> <span class="toctext">Applications</span></a>
<ul>
<li class="toclevel-2"><a href="#Compilation_of_functional_languages"><span class="tocnumber">6.1</span> <span class="toctext">Compilation of functional languages</span></a></li>
<li class="toclevel-2"><a href="#Logic"><span class="tocnumber">6.2</span> <span class="toctext">Logic</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#Further_reading"><span class="tocnumber">9</span> <span class="toctext">Further reading</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">10</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Combinatory_logic_in_mathematics" id="Combinatory_logic_in_mathematics"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=1" title="Edit section: Combinatory logic in mathematics">edit</a>]</span> <span class="mw-headline">Combinatory logic in mathematics</span></h2>
<p>Combinatory logic was originally intended as a 'pre-logic' that would clarify the role of <a href="/wiki/Quantifier" title="Quantifier" class="mw-redirect">quantified variables</a> in logic, essentially by eliminating them. Another way of eliminating quantified variables is <a href="/wiki/Willard_Van_Orman_Quine" title="Willard Van Orman Quine">Quine's</a> <a href="/wiki/Predicate_functor_logic" title="Predicate functor logic">predicate functor logic</a>. While the expressive power of combinatory logic typically exceeds that of <a href="/wiki/First-order_logic" title="First-order logic">first-order logic</a>, the expressive power of <a href="/wiki/Predicate_functor_logic" title="Predicate functor logic">predicate functor logic</a> is identical to that of first order logic (<a href="#Quine_1960_1966" title="">Quine 1960, 1966, 1976</a>).</p>
<p>The original inventor of combinatory logic, <a href="/wiki/Moses_Sch%C3%B6nfinkel" title="Moses Schönfinkel">Moses Schönfinkel</a>, published nothing on combinatory logic after his original 1924 paper, and largely ceased to publish after <a href="/wiki/Stalin" title="Stalin" class="mw-redirect">Stalin</a> consolidated his power in 1929. Curry rediscovered the combinators while working as an instructor at the <a href="/wiki/University_of_Princeton" title="University of Princeton" class="mw-redirect">University of Princeton</a> in the late 1927.<sup id="cite_ref-Seldin_2006_0-0" class="reference"><a href="#cite_note-Seldin_2006-0" title=""><span>[</span>1<span>]</span></a></sup> In the latter 1930s, <a href="/wiki/Alonzo_Church" title="Alonzo Church">Alonzo Church</a> and his students at <a href="/wiki/Princeton_University" title="Princeton University">Princeton University</a> invented a rival formalism for functional abstraction, the <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>, which proved more popular than combinatory logic. The upshot of these historical contingencies was that until theoretical computer science began taking an interest in combinatory logic in the 1960s and 70s, nearly all work on the subject was by <a href="/wiki/Haskell_Curry" title="Haskell Curry">Haskell Curry</a> and his students, or by <a href="/wiki/Robert_Feys" title="Robert Feys">Robert Feys</a> in <a href="/wiki/Belgium" title="Belgium">Belgium</a>. Curry and Feys (1958), and Curry <i>et al.</i> (1972) survey the early history of combinatory logic. For a more modern parallel treatment of combinatory logic and the lambda calculus, see Barendregt (1984), who also reviews the <a href="/wiki/Model_theory" title="Model theory">models</a> <a href="/wiki/Dana_Scott" title="Dana Scott">Dana Scott</a> devised for combinatory logic in the 1960s and 70s.</p>
<p><a name="Combinatory_logic_in_computing" id="Combinatory_logic_in_computing"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=2" title="Edit section: Combinatory logic in computing">edit</a>]</span> <span class="mw-headline">Combinatory logic in computing</span></h2>
<p>In computer science, combinatory logic is used as a simplified model of <a href="/wiki/Computation" title="Computation">computation</a>, used in <a href="/wiki/Computability_theory" title="Computability theory">computability theory</a> and <a href="/wiki/Proof_theory" title="Proof theory">proof theory</a>. Despite its simplicity, combinatory logic captures many essential features of computation.</p>
<p>Combinatory logic can be viewed as a variant of the <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>, in which lambda expressions (representing functional abstraction) are replaced by a limited set of <i>combinators</i>, primitive functions from which <a href="/wiki/Free_variable" title="Free variable" class="mw-redirect">free variables</a> are absent. It is easy to transform lambda expressions into combinator expressions, and combinator reduction is much simpler than lambda reduction. Hence combinatory logic has been used to model some <a href="/wiki/Non-strict_programming_language" title="Non-strict programming language" class="mw-redirect">non-strict</a> <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a> languages and <a href="/wiki/Graph_reduction_machine" title="Graph reduction machine">hardware</a>. The purest form of this view is the programming language <a href="/wiki/Unlambda" title="Unlambda">Unlambda</a>, whose sole primitives are the S and K combinators augmented with character input/output. Although not a practical programming language, Unlambda is of some theoretical interest.</p>
<p>Combinatory logic can be given a variety of interpretations. Many early papers by Curry showed how to translate axiom sets for conventional logic into combinatory logic equations (Hindley and Meredith 1990). Dana Scott in the 1960s and 70s showed how to marry <a href="/wiki/Model_theory" title="Model theory">model theory</a> and combinatory logic.</p>
<p><a name="Summary_of_the_lambda_calculus" id="Summary_of_the_lambda_calculus"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=3" title="Edit section: Summary of the lambda calculus">edit</a>]</span> <span class="mw-headline">Summary of the lambda calculus</span></h2>
<div class="rellink noprint relarticle mainarticle">Main article: <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a></div>
<p>The lambda calculus is concerned with objects called <i>lambda-terms</i>, which are strings of symbols of one of the following forms:</p>
<ul>
<li><i>v</i></li>
<li><i>λv</i>.<i>E1</i></li>
<li>(<i>E1</i> <i>E2</i>)</li>
</ul>
<p>where <i>v</i> is a variable name drawn from a predefined infinite set of variable names, and <i>E1</i> and <i>E2</i> are lambda-terms.</p>
<p>Terms of the form <i>λv.E1</i> are called <i>abstractions</i>. The variable <i>v</i> is called the <a href="/wiki/Formal_parameter" title="Formal parameter" class="mw-redirect">formal parameter</a> of the abstraction, and <i>E1</i> is the <i>body</i> of the abstraction. The term <i>λv.E1</i> represents the function which, applied to an argument, binds the formal parameter <i>v</i> to the argument and then computes the resulting value of <i>E1</i>---that is, it returns <i>E1</i>, with every occurrence of <i>v</i> replaced by the argument.</p>
<p>Terms of the form <i>(E1 E2)</i> are called <i>applications</i>. Applications model function invocation or execution: the function represented by <i>E1</i> is to be invoked, with <i>E2</i> as its argument, and the result is computed. If <i>E1</i> (sometimes called the <i>applicand</i>) is an abstraction, the term may be <i>reduced</i>: <i>E2</i>, the argument, may be substituted into the body of <i>E1</i> in place of the formal parameter of <i>E1</i>, and the result is a new lambda term which is <i>equivalent</i> to the old one. If a lambda term contains no subterms of the form <i>(λv.E1 E2)</i> then it cannot be reduced, and is said to be in <a href="/wiki/Beta_normal_form" title="Beta normal form">normal form</a>.</p>
<p>The expression <i>E</i>[<i>v</i>&#160;:= <i>a</i>] represents the result of taking the term <i>E</i> and replacing all free occurrences of <i>v</i> with <i>a</i>. Thus we write</p>
<dl>
<dd>(<i>λv.E</i> <i>a</i>) =&gt; <i>E</i>[<i>v</i>&#160;:= <i>a</i>]</dd>
</dl>
<p>By convention, we take <i>(a b c d ... z)</i> as short for <i>(...(((a b) c) d) ... z)</i>. (i.e., application is <a href="/wiki/Associative#Non-associativity" title="Associative" class="mw-redirect">left associative</a>.)</p>
<p>The motivation for this definition of reduction is that it captures the essential behavior of all mathematical functions. For example, consider the function that computes the square of a number. We might write</p>
<dl>
<dd>The square of <i>x</i> is <i>x</i>*<i>x</i></dd>
</dl>
<p>(Using "*" to indicate multiplication.) <i>x</i> here is the <a href="/wiki/Formal_parameter" title="Formal parameter" class="mw-redirect">formal parameter</a> of the function. To evaluate the square for a particular argument, say 3, we insert it into the definition in place of the formal parameter:</p>
<dl>
<dd>The square of 3 is 3*3</dd>
</dl>
<p>To evaluate the resulting expression 3*3, we would have to resort to our knowledge of multiplication and the number 3. Since any computation is simply a composition of the evaluation of suitable functions on suitable primitive arguments, this simple substitution principle suffices to capture the essential mechanism of computation. Moreover, in the lambda calculus, notions such as '3' and '*' can be represented without any need for externally defined primitive operators or constants. It is possible to identify terms in the lambda calculus, which, when suitably interpreted, behave like the number 3 and like the multiplication operator.</p>
<p>The lambda calculus is known to be computationally equivalent in power to many other plausible models for computation (including <a href="/wiki/Turing_machine" title="Turing machine">Turing machines</a>); that is, any calculation that can be accomplished in any of these other models can be expressed in the lambda calculus, and vice versa. According to the <a href="/wiki/Church-Turing_thesis" title="Church-Turing thesis" class="mw-redirect">Church-Turing thesis</a>, both models can express any possible computation.</p>
<p>It is perhaps surprising that lambda-calculus can represent any conceivable computation using only the simple notions of function abstraction and application based on simple textual substitution of terms for variables. But even more remarkable is that abstraction is not even required. <i>Combinatory logic</i> is a model of computation equivalent to the lambda calculus, but without abstraction. The advantage of this is that evaluating expressions in lambda calculus is quite complicated because the semantics of substitution must be specified with great care to avoid variable capture problems. In contrast, evaluating expressions in combinatory logic is much simpler, because there is no notion of substitution.</p>
<p><a name="Combinatory_calculi" id="Combinatory_calculi"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=4" title="Edit section: Combinatory calculi">edit</a>]</span> <span class="mw-headline">Combinatory calculi</span></h2>
<p>Since abstraction is the only way to manufacture functions in the lambda calculus, something must replace it in the combinatory calculus. Instead of abstraction, combinatory calculus provides a limited set of primitive functions out of which other functions may be built.</p>
<p><a name="Combinatory_terms" id="Combinatory_terms"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=5" title="Edit section: Combinatory terms">edit</a>]</span> <span class="mw-headline">Combinatory terms</span></h3>
<p>A combinatory term has one of the following forms:</p>
<ul>
<li><i>x</i></li>
<li><i>P</i></li>
<li>(<i>E<sub>1</sub></i> <i>E<sub>2</sub></i>)</li>
</ul>
<p>where <i>x</i> is a variable, <i>P</i> is one of the primitive functions, and (<i>E<sub>1</sub></i> <i>E<sub>2</sub></i>) is the application of combinatory terms <i>E<sub>1</sub></i> and <i>E<sub>2</sub></i>. The primitive functions themselves are <i>combinators</i>, or functions that, when seen as lambda terms, contain no <a href="/wiki/Free_variable" title="Free variable" class="mw-redirect">free variables</a>. To shorten the notations, a general convention is that (<i>E<sub>1</sub></i> <i>E<sub>2</sub></i> <i>E<sub>3</sub></i> ... <i>E<sub>n</sub></i>), or even <i>E<sub>1</sub></i> <i>E<sub>2</sub></i> <i>E<sub>3</sub></i>... <i>E</i><sub>n</sub>, denotes the term (...((<i>E<sub>1</sub></i> <i>E<sub>2</sub></i>) <i>E<sub>3</sub></i>)... <i>E<sub>n</sub></i>). This is the same general convention as for multiple application in lambda calculus.</p>
<p><a name="Reduction_in_combinatory_logic" id="Reduction_in_combinatory_logic"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=6" title="Edit section: Reduction in combinatory logic">edit</a>]</span> <span class="mw-headline">Reduction in combinatory logic</span></h3>
<p>In combinatory logic, each primitive combinator comes with a reduction rule of the form</p>
<dl>
<dd>(<i>P</i> <i>x<sub>1</sub></i> ... <i>x<sub>n</sub></i>) = <i>E</i></dd>
</dl>
<p>where <i>E</i> is a term mentioning only variables from the set <i>x<sub>1</sub></i> ... <i>x<sub>n</sub></i>. It is in this way that primitive combinators behave as functions.</p>
<p><a name="Examples_of_combinators" id="Examples_of_combinators"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=7" title="Edit section: Examples of combinators">edit</a>]</span> <span class="mw-headline">Examples of combinators</span></h3>
<p>The simplest example of a combinator is <b>I</b>, the identity combinator, defined by</p>
<dl>
<dd>(<b>I</b> <i>x</i>) = <i>x</i></dd>
</dl>
<p>for all terms <i>x</i>. Another simple combinator is <b>K</b>, which manufactures constant functions: (<b>K</b> <i>x</i>) is the function which, for any argument, returns <i>x</i>, so we say</p>
<dl>
<dd>((<b>K</b> <i>x</i>) <i>y</i>) = <i>x</i></dd>
</dl>
<p>for all terms <i>x</i> and <i>y</i>. Or, following the convention for multiple application,</p>
<dl>
<dd>(<b>K</b> <i>x</i> <i>y</i>) = <i>x</i></dd>
</dl>
<p>A third combinator is <b>S</b>, which is a generalized version of application:</p>
<dl>
<dd>(<b>S</b> <i>x</i> <i>y</i> <i>z</i>) = (<i>x</i> <i>z</i> (<i>y</i> <i>z</i>))</dd>
</dl>
<p><b>S</b> applies <i>x</i> to <i>y</i> after first substituting <i>z</i> into each of them. Or put another way, <i>x</i> is applied to <i>y</i> inside the environment <i>z</i>.</p>
<p>Given <b>S</b> and <b>K</b>, <b>I</b> itself is unnecessary, since it can be built from the other two:</p>
<dl>
<dd>((<b>S</b> <b>K</b> <b>K</b>) <i>x</i>)
<dl>
<dd>= (<b>S</b> <b>K</b> <b>K</b> <i>x</i>)</dd>
<dd>= (<b>K</b> <i>x</i> (<b>K</b> <i>x</i>))</dd>
<dd>= <i>x</i></dd>
</dl>
</dd>
</dl>
<p>for any term <i>x</i>. Note that although ((<b>S</b> <b>K</b> <b>K</b>) <i>x</i>) = (<b>I</b> <i>x</i>) for any <i>x</i>, (<b>S</b> <b>K</b> <b>K</b>) itself is not equal to <b>I</b>. We say the terms are <a href="/wiki/Extensional_equality" title="Extensional equality" class="mw-redirect">extensionally equal</a>. Extensional equality captures the mathematical notion of the equality of functions: that two functions are <i>equal</i> if they always produce the same results for the same arguments. In contrast, the terms themselves, together with the reduction of primitive combinators, capture the notion of <i>intensional equality</i> of functions: that two functions are <i>equal</i> only if they have identical implementations up to the expansion of primitive combinators when these ones are applied to enough arguments. There are many ways to implement an identity function; (<b>S</b> <b>K</b> <b>K</b>) and <b>I</b> are among these ways. (<b>S</b> <b>K</b> <b>S</b>) is yet another. We will use the word <i>equivalent</i> to indicate extensional equality, reserving <i>equal</i> for identical combinatorial terms.</p>
<p>A more interesting combinator is the <a href="/wiki/Fixed_point_combinator" title="Fixed point combinator">fixed point combinator</a> or <b>Y</b> combinator, which can be used to implement <a href="/wiki/Recursion" title="Recursion">recursion</a>.</p>
<p><a name="Completeness_of_the_S-K_basis" id="Completeness_of_the_S-K_basis"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=8" title="Edit section: Completeness of the S-K basis">edit</a>]</span> <span class="mw-headline">Completeness of the <b>S</b>-<b>K</b> basis</span></h3>
<p>It is a perhaps astonishing fact that <b>S</b> and <b>K</b> can be composed to produce combinators that are extensionally equal to <i>any</i> lambda term, and therefore, by Church's thesis, to any computable function whatsoever. The proof is to present a transformation, <i>T</i>[&#160;], which converts an arbitrary lambda term into an equivalent combinator.</p>
<p><i>T</i>[&#160;] may be defined as follows:</p>
<ol>
<li><i>T</i>[<i>x</i>] =&gt; <i>x</i></li>
<li><i>T</i>[(<i>E₁</i> <i>E₂</i>)] =&gt; (<i>T</i>[<i>E₁</i>] <i>T</i>[<i>E₂</i>])</li>
<li><i>T</i>[<i>λx</i>.<i>E</i>] =&gt; (<b>K</b> <i>T</i>[<i>E</i>]) (if <i>x</i> is not free in <i>E</i>)</li>
<li><i>T</i>[<i>λx</i>.<i>x</i>] =&gt; <b>I</b></li>
<li><i>T</i>[<i>λx</i>.<i>λy</i>.<i>E</i>] =&gt; <i>T</i>[<i>λx</i>.<i>T</i>[<i>λy</i>.<i>E</i>]] (if <i>x</i> is free in <i>E</i>)</li>
<li><i>T</i>[<i>λx</i>.(<i>E₁</i> <i>E₂</i>)] =&gt; (<b>S</b> <i>T</i>[<i>λx</i>.<i>E₁</i>] <i>T</i>[<i>λx</i>.<i>E₂</i>])</li>
</ol>
<p>This process is also known as <i>abstraction elimination</i>.</p>
<p><a name="Conversion_of_a_lambda_term_to_an_equivalent_combinatorial_term" id="Conversion_of_a_lambda_term_to_an_equivalent_combinatorial_term"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=9" title="Edit section: Conversion of a lambda term to an equivalent combinatorial term">edit</a>]</span> <span class="mw-headline">Conversion of a lambda term to an equivalent combinatorial term</span></h4>
<p>For example, we will convert the lambda term <i>λx</i>.<i>λy</i>.(<i>y</i> <i>x</i>) to a combinator:</p>
<dl>
<dd><i>T</i>[<i>λx</i>.<i>λy</i>.(<i>y</i> <i>x</i>)]
<dl>
<dd>= <i>T</i>[<i>λx</i>.<i>T</i>[<i>λy</i>.(<i>y</i> <i>x</i>)]] (by 5)</dd>
<dd>= <i>T</i>[<i>λx</i>.(<b>S</b> <i>T</i>[<i>λy</i>.<i>y</i>] <i>T</i>[<i>λy</i>.<i>x</i>])] (by 6)</dd>
<dd>= <i>T</i>[<i>λx</i>.(<b>S</b> <b>I</b> <i>T</i>[<i>λy</i>.<i>x</i>])] (by 4)</dd>
<dd>= <i>T</i>[<i>λx</i>.(<b>S</b> <b>I</b> (<b>K</b> <i>x</i>))] (by 3 and 1)</dd>
<dd>= (<b>S</b> <i>T</i>[<i>λx</i>.(<b>S</b> <b>I</b>)] <i>T</i>[<i>λx</i>.(<b>K</b> <i>x</i>)]) (by 6)</dd>
<dd>= (<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>)) <i>T</i>[<i>λx</i>.(<b>K</b> <i>x</i>)]) (by 3)</dd>
<dd>= (<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>)) (<b>S</b> <i>T</i>[<i>λx</i>.<b>K</b>] <i>T</i>[<i>λx</i>.<i>x</i>])) (by 6)</dd>
<dd>= (<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>)) (<b>S</b> (<b>K</b> <b>K</b>) <i>T</i>[<i>λx</i>.<i>x</i>])) (by 3)</dd>
<dd>= (<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>)) (<b>S</b> (<b>K</b> <b>K</b>) <b>I</b>)) (by 4)</dd>
</dl>
</dd>
</dl>
<p>If we apply this combinator to any two terms <i>x</i> and <i>y</i>, it reduces as follows:</p>
<dl>
<dd>(<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>)) (<b>S</b> (<b>K</b> <b>K</b>) <b>I</b>) x y)
<dl>
<dd>= (<b>K</b> (<b>S</b> <b>I</b>) x (<b>S</b> (<b>K</b> <b>K</b>) <b>I</b> x) y)</dd>
<dd>= (<b>S</b> <b>I</b> (<b>S</b> (<b>K</b> <b>K</b>) <b>I</b> x) y)</dd>
<dd>= (<b>I</b> y (<b>S</b> (<b>K</b> <b>K</b>) <b>I</b> x y))</dd>
<dd>= (y (<b>S</b> (<b>K</b> <b>K</b>) <b>I</b> x y))</dd>
<dd>= (y (<b>K</b> <b>K</b> x (<b>I</b> x) y))</dd>
<dd>= (y (<b>K</b> (<b>I</b> x) y))</dd>
<dd>= (y (<b>I</b> x))</dd>
<dd>= (y x)</dd>
</dl>
</dd>
</dl>
<p>The combinatory representation, (<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>)) (<b>S</b> (<b>K</b> <b>K</b>) <b>I</b>)) is much longer than the representation as a lambda term, <i>λx</i>.<i>λy</i>.(y x). This is typical. In general, the <i>T</i>[&#160;] construction may expand a lambda term of length <i>n</i> to a combinatorial term of length <a href="/wiki/Big_O_notation" title="Big O notation">Θ</a>(3<sup><i>n</i></sup>).</p>
<p><a name="Explanation_of_the_T.5B.C2.A0.5D_transformation" id="Explanation_of_the_T.5B.C2.A0.5D_transformation"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=10" title="Edit section: Explanation of the T[&amp;nbsp;] transformation">edit</a>]</span> <span class="mw-headline">Explanation of the <i>T</i>[&#160;] transformation</span></h4>
<p>The <i>T</i>[&#160;] transformation is motivated by a desire to eliminate abstraction. Two special cases, rules 3 and 4, are trivial: <i>λx</i>.<i>x</i> is clearly equivalent to <b>I</b>, and <i>λx</i>.<i>E</i> is clearly equivalent to (<b>K</b> <i>T</i>[<i>E</i>]) if <i>x</i> does not appear free in <i>E</i>.</p>
<p>The first two rules are also simple: Variables convert to themselves, and applications, which are allowed in combinatory terms, are converted to combinators simply by converting the applicand and the argument to combinators.</p>
<p>It's rules 5 and 6 that are of interest. Rule 5 simply says that to convert a complex abstraction to a combinator, we must first convert its body to a combinator, and then eliminate the abstraction. Rule 6 actually eliminates the abstraction.</p>
<p><i>λx</i>.(<i>E₁</i> <i>E₂</i>) is a function which takes an argument, say <i>a</i>, and substitutes it into the lambda term (<i>E₁</i> <i>E₂</i>) in place of <i>x</i>, yielding (<i>E₁</i> <i>E₂</i>)[<i>x</i>&#160;: = <i>a</i>]. But substituting <i>a</i> into (<i>E₁</i> <i>E₂</i>) in place of <i>x</i> is just the same as substituting it into both <i>E₁</i> and <i>E₂</i>, so</p>
<pre>
       (<i>E₁</i> <i>E₂</i>)[<i>x</i> := <i>a</i>] = (<i>E₁</i>[<i>x</i> := <i>a</i>] <i>E₂</i>[<i>x</i> := <i>a</i>])
</pre>
<p>(<i>λx</i>.(<i>E₁</i> <i>E₂</i>) <i>a</i>) = ((<i>λx</i>.<i>E₁</i> <i>a</i>) (<i>λx</i>.<i>E₂</i> <i>a</i>))</p>
<pre>
                      = (<b>S</b> <i>λx</i>.<i>E₁</i> <i>λx</i>.<i>E₂</i> <i>a</i>)
                      = ((<b>S</b> <i>λx</i>.<i>E₁</i> <i>λx</i>.<i>E₂</i>) <i>a</i>)
</pre>
<p>By extensional equality,</p>
<pre>
       <i>λx</i>.(<i>E₁</i> <i>E2</i>)     = (<b>S</b> <i>λx</i>.<i>E₁</i> <i>λx</i>.<i>E₂</i>)
</pre>
<p>Therefore, to find a combinator equivalent to <i>λx</i>.(<i>E₁</i> <i>E₂</i>), it is sufficient to find a combinator equivalent to (<b>S</b> <i>λx</i>.<i>E₁</i> <i>λx</i>.<i>E₂</i>), and</p>
<pre>
       (<b>S</b> <i>T</i>[<i>λx</i>.<i>E₁</i>] <i>T</i>[<i>λx</i>.<i>E₂</i>])
</pre>
<p>evidently fits the bill. <i>E₁</i> and <i>E₂</i> each contain strictly fewer applications than (<i>E₁</i> <i>E₂</i>), so the recursion must terminate in a lambda term with no applications at all—either a variable, or a term of the form <i>λx</i>.<i>E</i>.</p>
<p><a name="Simplifications_of_the_transformation" id="Simplifications_of_the_transformation"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=11" title="Edit section: Simplifications of the transformation">edit</a>]</span> <span class="mw-headline">Simplifications of the transformation</span></h3>
<p><a name=".CE.B7-reduction" id=".CE.B7-reduction"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=12" title="Edit section: η-reduction">edit</a>]</span> <span class="mw-headline">η-reduction</span></h4>
<p>The combinators generated by the <i>T</i>[&#160;] transformation can be made smaller if we take into account the <i>η-reduction</i> rule:</p>
<pre>
       <i>T</i>[<i>λx</i>.(<i>E</i> <i>x</i>)] = <i>T</i>[<i>E</i>]   (if <i>x</i> is not free in <i>E</i>)
</pre>
<p><i>λx</i>.(<i>E</i> x) is the function which takes an argument, <i>x</i>, and applies the function <i>E</i> to it; this is extensionally equal to the function <i>E</i> itself. It is therefore sufficient to convert <i>E</i> to combinatorial form.</p>
<p>Taking this simplification into account, the example above becomes:</p>
<pre>
         <i>T</i>[<i>λx</i>.<i>λy</i>.(<i>y</i> <i>x</i>)] 
       = ...
       = (<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>))   <i>T</i>[<i>λx</i>.(<b>K</b> <i>x</i>)])
       = (<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>))   <b>K</b>)                 (by η-reduction)
</pre>
<p>This combinator is equivalent to the earlier, longer one:</p>
<pre>
         (<b>S</b> (<b>K</b> (<b>S</b> <b>I</b>))   <b>K</b> <i>x</i> <i>y</i>)
       = (<b>K</b> (<b>S</b> <b>I</b>) <i>x</i> (<b>K</b> <i>x</i>) <i>y</i>)
       = (<b>S</b> <b>I</b> (<b>K</b> <i>x</i>) <i>y</i>)
       = (<b>I</b> <i>y</i> (<b>K</b> <i>x</i> <i>y</i>))
       = (<i>y</i> (<b>K</b> <i>x</i> <i>y</i>))
       = (<i>y</i> <i>x</i>)
</pre>
<p>Similarly, the original version of the <i>T</i>[&#160;] transformation transformed the identity function <i>λf</i>.<i>λx</i>.(<i>f</i> <i>x</i>) into (<b>S</b> (<b>S</b> (<b>K</b> <b>S</b>) (<b>S</b> (<b>K</b> <b>K</b>) <b>I</b>)) (<b>K</b> <b>I</b>)). With the η-reduction rule, <i>λf</i>.<i>λx</i>.(<i>f</i> <i>x</i>) is transformed into <b>I</b>.</p>
<p><a name="One-point_basis" id="One-point_basis"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=13" title="Edit section: One-point basis">edit</a>]</span> <span class="mw-headline">One-point basis</span></h4>
<p>There are one-point bases from which every combinator can be composed extensionally equal to <i>any</i> lambda term. The simplest example of such a basis is {<b>X</b>} where:</p>
<pre>
       <b>X</b> ≡ <i>λx</i>.((x<b>S</b>)<b>K</b>)
</pre>
<p>It is not difficult to verify that:</p>
<pre>
       <b>X</b> (<b>X</b> (<b>X</b> <b>X</b>)) =<sup>ηβ</sup> <b>K</b> and
       <b>X</b> (<b>X</b> (<b>X</b> (<b>X</b> <b>X</b>)))) =<sup>ηβ</sup> <b>S</b>.
</pre>
<p>Since {<b>K</b>, <b>S</b>} is a basis, it follows that {<b>X</b>} is a basis too. The <a href="/wiki/Iota_and_Jot" title="Iota and Jot">Iota</a> programming language uses <b>X</b> as its sole combinator.</p>
<p>Another simple example of a one-point basis is:</p>
<pre>
       <b>X'</b> ≡ <i>λx</i>.(x <b>K</b> <b>S</b> <b>K</b>) with
       (<b>X'</b> <b>X'</b>) <b>X'</b> =<sup>β</sup> <b>K</b> and
       <b>X'</b> (<b>X'</b> <b>X'</b>) =<sup>β</sup> <b>S</b>
</pre>
<p><b>X'</b> does not need η contraction in order to produce <b>K</b> and <b>S</b>. <b>X</b> is a one-point basis in <b>CL</b>+ext but not in <b>CL</b> without extensionality. <b>X'</b> is a one-point basis in both <b>CL</b> and <b>CL</b>+ext.</p>
<p><a name="Combinators_B.2C_C" id="Combinators_B.2C_C"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=14" title="Edit section: Combinators B, C">edit</a>]</span> <span class="mw-headline">Combinators B, C</span></h4>
<p>In addition to <b>S</b> and <b>K</b>, <a href="/wiki/Moses_Sch%C3%B6nfinkel" title="Moses Schönfinkel">Schönfinkel</a>'s paper included two combinators which are now called <b>B</b> and <b>C</b>, with the following reductions:</p>
<pre>
       (<b>C</b> <i>a</i> <i>b</i> <i>c</i>) = (<i>a</i> <i>c</i> <i>b</i>)
       (<b>B</b> <i>a</i> <i>b</i> <i>c</i>) = (<i>a</i> (<i>b</i> <i>c</i>))
</pre>
<p>He also explains how they in turn can be expressed using only <b>S</b> and <b>K</b>.</p>
<p>These combinators are extremely useful when translating predicate logic or lambda calculus into combinator expressions. They were also used by <a href="/wiki/Haskell_Curry" title="Haskell Curry">Curry</a>, and much later by <a href="/wiki/David_Turner_(computer_scientist)" title="David Turner (computer scientist)">David Turner</a>, whose name has been associated with their computational use. Using them, we can extend the rules for the transformation as follows:</p>
<ol>
<li><i>T</i>[<i>x</i>] =&gt; <i>x</i></li>
<li><i>T</i>[(<i>E₁</i> <i>E₂</i>)] =&gt; (<i>T</i>[<i>E₁</i>] <i>T</i>[<i>E₂</i>])</li>
<li><i>T</i>[<i>λx</i>.<i>E</i>] =&gt; (<b>K</b> <i>T</i>[<i>E</i>]) (if <i>x</i> is not free in <i>E</i>)</li>
<li><i>T</i>[<i>λx</i>.<i>x</i>] =&gt; <b>I</b></li>
<li><i>T</i>[<i>λx</i>.<i>λy</i>.<i>E</i>] =&gt; <i>T</i>[<i>λx</i>.<i>T</i>[<i>λy</i>.<i>E</i>]] (if <i>x</i> is free in <i>E</i>)</li>
<li><i>T</i>[<i>λx</i>.(<i>E₁</i> <i>E₂</i>)] =&gt; (<b>S</b> <i>T</i>[<i>λx</i>.<i>E₁</i>] <i>T</i>[<i>λx</i>.<i>E₂</i>]) (if <i>x</i> is free in both <i>E₁</i> and <i>E₂</i>)</li>
<li><i>T</i>[<i>λx</i>.(<i>E₁</i> <i>E₂</i>)] =&gt; (<b>C</b> <i>T</i>[<i>λx</i>.<i>E₁</i>] <i>T</i>[<i>E₂</i>]) (if <i>x</i> is free in <i>E₁</i> but not <i>E₂</i>)</li>
<li><i>T</i>[<i>λx</i>.(<i>E₁</i> <i>E₂</i>)] =&gt; (<b>B</b> <i>T</i>[<i>E₁</i>] <i>T</i>[<i>λx</i>.<i>E₂</i>]) (if <i>x</i> is free in <i>E₂</i> but not <i>E₁</i>)</li>
</ol>
<p>Using <b>B</b> and <b>C</b> combinators, the transformation of <i>λx</i>.<i>λy</i>.(<i>y</i> <i>x</i>) looks like this:</p>
<pre>
         <i>T</i>[<i>λx</i>.<i>λy</i>.(<i>y</i> <i>x</i>)] 
       = <i>T</i>[<i>λx</i>.<i>T</i>[<i>λy</i>.(<i>y</i> <i>x</i>)]]
       = <i>T</i>[<i>λx</i>.(<b>C</b> <i>T</i>[<i>λy</i>.<i>y</i>] <i>x</i>)]     (by rule 7)
       = <i>T</i>[<i>λx</i>.(<b>C</b> <b>I</b> <i>x</i>)]
       = (<b>C</b> <b>I</b>)                   (η-reduction)
       = <b>C</b><sub>*</sub>(traditional canonical notation : <b>X</b><sub>*</sub> = <b>X</b> <b>I</b>)
       = <b>I'</b>(traditional canonical notation: <b>X'</b> = <b>C</b> <b>X</b>)  
</pre>
<p>And indeed, (<b>C</b> <b>I</b> <i>x</i> <i>y</i>) does reduce to (<i>y</i> <i>x</i>):</p>
<pre>
         (<b>C</b> <b>I</b> <i>x</i> <i>y</i>)
       = (<b>I</b> <i>y</i> <i>x</i>)
       = (<i>y</i> <i>x</i>)
</pre>
<p>The motivation here is that <b>B</b> and <b>C</b> are limited versions of <b>S</b>. Whereas <b>S</b> takes a value and substitutes it into both the applicand and its argument before performing the application, <b>C</b> performs the substitution only in the applicand, and <b>B</b> only in the argument.</p>
<p>The modern names for the combinators come from <a href="/wiki/Haskell_Curry" title="Haskell Curry">Haskell Curry</a>'s doctoral thesis of 1930 (see <a href="/wiki/B,C,K,W_System" title="B,C,K,W System" class="mw-redirect">B,C,K,W System</a>). In <a href="/wiki/Moses_Sch%C3%B6nfinkel" title="Moses Schönfinkel">Schönfinkel</a>'s original paper, what we now call <b>S</b>, <b>K</b>, <b>I</b>, <b>B</b> and <b>C</b> were called <b>S</b>, <b>C</b>, <b>I</b>, <b>Z</b>, and <b>T</b> respectively.</p>
<p><a name="CLK_versus_CLI_calculus" id="CLK_versus_CLI_calculus"></a></p>
<h5><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=15" title="Edit section: CLK versus CLI calculus">edit</a>]</span> <span class="mw-headline"><b>CL</b><sub>K</sub> versus <b>CL</b><sub>I</sub> calculus</span></h5>
<p>A distinction must be made between the <b>CL</b><sub>K</sub> as described in this article and the <b>CL</b><sub>I</sub> calculus. The distinction corresponds to that between the λ<sub>K</sub> and the λ<sub>I</sub> calculus. Unlike the λ<sub>K</sub> calculus, the λ<sub>I</sub> calculus restricts abstractions to:</p>
<dl>
<dd>
<dl>
<dd><i>λx</i>.<i>E</i> where <i>x</i> has at least one free occurrence in <i>E</i>.</dd>
</dl>
</dd>
</dl>
<p>As a consequence, combinator <b>K</b> is not present in the λ<sub>I</sub> calculus nor in the <b>CL</b><sub>I</sub> calculus. The constants of <b>CL</b><sub>I</sub> are: <b>I</b>, <b>B</b>, <b>C</b> and <b>S</b>, which form a basis from which all <b>CL</b><sub>I</sub> terms can be composed (modulo equality). Every λ<sub>I</sub> term can be converted into an equal <b>CL</b><sub>I</sub> combinator according to rules similar to those presented above for the conversion of λ<sub>K</sub> terms into <b>CL</b><sub>K</sub> combinators. See chapter 9 in Barendregt (1984).</p>
<p><a name="Reverse_conversion" id="Reverse_conversion"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=16" title="Edit section: Reverse conversion">edit</a>]</span> <span class="mw-headline">Reverse conversion</span></h3>
<p>The conversion <i>L</i>[&#160;] from combinatorial terms to lambda terms is trivial:</p>
<pre>
       <i>L</i>[<b>I</b>]       = <i>λx</i>.<i>x</i>
       <i>L</i>[<b>K</b>]       = <i>λx</i>.<i>λy</i>.<i>x</i>
       <i>L</i>[<b>C</b>]       = <i>λx</i>.<i>λy</i>.<i>λz</i>.(<i>x</i> <i>z</i> <i>y</i>)
       <i>L</i>[<b>B</b>]       = <i>λx</i>.<i>λy</i>.<i>λz</i>.(<i>x</i> (<i>y</i> <i>z</i>))
       <i>L</i>[<b>S</b>]       = <i>λx</i>.<i>λy</i>.<i>λz</i>.(<i>x</i> <i>z</i> (<i>y</i> <i>z</i>))
       <i>L</i>[(<i>E₁</i> <i>E₂</i>)] = (<i>L</i>[<i>E₁</i>] <i>L</i>[<i>E₂</i>])
</pre>
<p>Note, however, that this transformation is not the inverse transformation of any of the versions of <i>T</i>[&#160;] that we have seen.</p>
<p><a name="Undecidability_of_combinatorial_calculus" id="Undecidability_of_combinatorial_calculus"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=17" title="Edit section: Undecidability of combinatorial calculus">edit</a>]</span> <span class="mw-headline">Undecidability of combinatorial calculus</span></h2>
<p>A <i>normal</i> form is any combinatory term in which the primitive combinators that occur, if any, are not applied to enough arguments to be simplified. It is undecidable whether a general combinatory term has a normal form; whether two combinatory terms are equivalent, etc. This is equivalent to the undecidability of the corresponding problems for lambda terms. However, a direct proof is as follows:</p>
<p>First, observe that the term</p>
<pre>
       <b>Ω</b> = (<b>S</b> <b>I</b> <b>I</b> (<b>S</b> <b>I</b> <b>I</b>))
</pre>
<p>has no normal form, because it reduces to itself after three steps, as follows:</p>
<pre>
         (<b>S</b> <b>I</b> <b>I</b> (<b>S</b> <b>I</b> <b>I</b>))
       = (<b>I</b> (<b>S</b> <b>I</b> <b>I</b>) (<b>I</b> (<b>S</b> <b>I</b> <b>I</b>)))
       = (<b>S</b> <b>I</b> <b>I</b> (<b>I</b> (<b>S</b> <b>I</b> <b>I</b>)))
       = (<b>S</b> <b>I</b> <b>I</b> (<b>S</b> <b>I</b> <b>I</b>))
</pre>
<p>and clearly no other reduction order can make the expression shorter.</p>
<p>Now, suppose <b>N</b> were a combinator for detecting normal forms, such that</p>
<pre>
       (<b>N</b> <i>x</i>) =&gt; <b>T</b>, if <i>x</i> has a normal form
                <b>F</b>, otherwise.
</pre>
<p>(Where <b>T</b> and <b>F</b> represent the conventional <a href="/wiki/Church_encoding" title="Church encoding">Church encodings</a> of true and false, <i>λx</i>.<i>λy</i>.<i>x</i> and <i>λx</i>.<i>λy</i>.<i>y</i>, transformed into combinatory logic. The combinatory versions have <b>T</b> = <b>K</b> and <b>F</b> = (<b>K</b> <b>I</b>).)</p>
<p>Now let</p>
<pre>
       <i>Z</i> = (<b>C</b> (<b>C</b> (<b>B</b> <b>N</b> (<b>S</b> <b>I</b> <b>I</b>)) <b>Ω</b>) <b>I</b>)
</pre>
<p>now consider the term (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>). Does (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>) have a normal form? It does if and only if the following do also:</p>
<pre>
         (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>)
       = (<b>I</b> <i>Z</i> (<b>I</b> <i>Z</i>))
       = (<i>Z</i> (<b>I</b> <i>Z</i>))
       = (<i>Z</i> <i>Z</i>) 
       = (<b>C</b> (<b>C</b> (<b>B</b> <b>N</b> (<b>S</b> <b>I</b> <b>I</b>)) <b>Ω</b>) <b>I</b> <i>Z</i>)           (definition of <i>Z</i>)
       = (<b>C</b> (<b>B</b> <b>N</b> (<b>S</b> <b>I</b> <b>I</b>)) <b>Ω</b> <i>Z</i> <b>I</b>)
       = (<b>B</b> <b>N</b> (<b>S</b> <b>I</b> <b>I</b>) <i>Z</i> <b>Ω</b> <b>I</b>)
       = (<b>N</b> (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>) <b>Ω</b> <b>I</b>)
</pre>
<p>Now we need to apply <b>N</b> to (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>). Either (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>) has a normal form, or it does not. If it <i>does</i> have a normal form, then the foregoing reduces as follows:</p>
<pre>
         (<b>N</b> (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>) <b>Ω</b> <b>I</b>)
       = (<b>K</b> <b>Ω</b> <b>I</b>)                               (definition of <b>N</b>)
       = <b>Ω</b>
</pre>
<p>but <b>Ω</b> does <i>not</i> have a normal form, so we have a contradiction. But if (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>) does <i>not</i> have a normal form, the foregoing reduces as follows:</p>
<pre>
         (<b>N</b> (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>) <b>Ω</b> <b>I</b>)
       = (<b>K</b> <b>I</b> <b>Ω</b> <b>I</b>)                             (definition of <b>N</b>)
       = (<b>I</b> <b>I</b>)
         <b>I</b>
</pre>
<p>which means that the normal form of (<b>S</b> <b>I</b> <b>I</b> <i>Z</i>) is simply <b>I</b>, another contradiction. Therefore, the hypothetical normal-form combinator <b>N</b> cannot exist.</p>
<p>The combinatory logic analogue of <a href="/wiki/Rice%27s_theorem" title="Rice's theorem">Rice's theorem</a> says that there is no complete nontrivial predicate. A <i>predicate</i> is a combinator that, when applied, returns either <b>T</b> or <b>F</b>. A predicate <i>N</i> is <i>nontrivial</i> if there are two arguments <i>A</i> and <i>B</i> such that <i>NA</i>=<b>T</b> and <i>NB</i>=<b>F</b>. A combinator <i>N</i> is <i>complete</i> if and only if <i>NM</i> has a normal form for every argument <i>M</i>. The analogue of Rice's theorem then says that every complete predicate is trivial. The proof of this theorem is rather simple.</p>
<p><b>Proof:</b> By reductio ad absurdum. Suppose there is a complete non trivial predicate, say <i>N</i>.<br />
Because <i>N</i> is supposed to be non trivial there are combinators <i>A</i> and <i>B</i> such that<br />
(<i>N A</i>) = <b>T</b> and<br />
(<i>N B</i>) = <b>F</b>.</p>
<p>Define NEGATION ≡ <i>λx.</i>(if (<i>N x</i>) then <i>B</i> else <i>A</i>) ≡ <i>λx.</i>((<i>N x</i>) <i>B</i> <i>A</i>)<br />
Define ABSURDUM ≡ (<b>Y</b> NEGATION)</p>
<p>Fixed point theorem gives: ABSURDUM = (NEGATION ABSURDUM), for<br />
ABSURDUM ≡ (<b>Y</b> NEGATION) = (NEGATION (<b>Y</b> NEGATION)) ≡ (NEGATION ABSURDUM).</p>
<p>Because <i>N</i> is supposed to be complete either:</p>
<ol>
<li>(<i>N</i> ABSURDUM) = <b>F</b> or</li>
<li>(<i>N</i> ABSURDUM) = <b>T</b></li>
</ol>
<p>Case 1: <b>F</b> = (<i>N</i> ABSURDUM) = <i>N</i> (NEGATION ABSURDUM) = (<i>N A</i>) = <b>T</b>, a contradiction.<br />
Case 2: <b>T</b> = (<i>N</i> ABSURDUM) = <i>N</i> (NEGATION ABSURDUM) = (<i>N B</i>) = <b>F</b>, again a contradiction.</p>
<p>Hence (<i>N</i> ABSURDUM) is neither <b>T</b> nor <b>F</b>, which contradicts the presupposition that <i>N</i> would be a complete non trivial predicate. <b>QED</b>.</p>
<p>From this undecidability theorem it immediately follows that there is no complete predicate that can discriminate between terms that have a normal form and terms that do not have a normal form. It also follows that there is <b>no</b> complete predicate, say EQUAL, such that:<br />
(EQUAL <i>A B</i>) = <b>T</b> if <i>A</i> = <i>B</i> and<br />
(EQUAL <i>A B</i>) = <b>F</b> if <i>A</i> ≠ <i>B</i>.<br />
If EQUAL would exist, then for all <i>A</i>, <i>λx.</i>(EQUAL <i>x A</i>) would have to be a complete non trivial predicate.</p>
<p><a name="Applications" id="Applications"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=18" title="Edit section: Applications">edit</a>]</span> <span class="mw-headline">Applications</span></h2>
<p><a name="Compilation_of_functional_languages" id="Compilation_of_functional_languages"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=19" title="Edit section: Compilation of functional languages">edit</a>]</span> <span class="mw-headline">Compilation of functional languages</span></h3>
<p><a href="/wiki/Functional_programming_language" title="Functional programming language" class="mw-redirect">Functional programming languages</a> are often based on the simple but universal semantics of the <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>.</p>
<p>David Turner used his combinators to implement the <a href="/wiki/SASL_programming_language" title="SASL programming language" class="mw-redirect">SASL programming language</a>.</p>
<p><a href="/wiki/Kenneth_E._Iverson" title="Kenneth E. Iverson">Kenneth E. Iverson</a> used primitives based on Curry's combinators in his <a href="/wiki/J_programming_language" title="J programming language" class="mw-redirect">J programming language</a>, a successor to <a href="/wiki/APL_(programming_language)" title="APL (programming language)">APL</a>. This enabled what Iverson called <a href="/wiki/Tacit_programming" title="Tacit programming">tacit programming</a>, that is, programming in functional expressions containing no variables, along with powerful tools for working with such programs. It turns out that tacit programming is possible in a clumsier manner in any APL-like language with user-defined operators (<a href="http://portal.acm.org/citation.cfm?id=114065&amp;dl=GUIDE&amp;coll=GUIDE" class="external text" title="http://portal.acm.org/citation.cfm?id=114065&amp;dl=GUIDE&amp;coll=GUIDE" rel="nofollow">Pure Functions in APL and J</a>).</p>
<p><a name="Logic" id="Logic"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=20" title="Edit section: Logic">edit</a>]</span> <span class="mw-headline">Logic</span></h3>
<p>The <a href="/wiki/Curry-Howard_isomorphism" title="Curry-Howard isomorphism" class="mw-redirect">Curry-Howard isomorphism</a> implies a connection between logic and programming: every proof of a theorem of <a href="/wiki/Intuitionistic_logic" title="Intuitionistic logic">intuitionistic logic</a> corresponds to a reduction of a typed lambda term, and conversely. Moreover, theorems can be identified with function type signatures. Specifically, a typed combinatory logic corresponds to a <a href="/wiki/Hilbert-style_deduction_system" title="Hilbert-style deduction system">Hilbert system</a> in <a href="/wiki/Proof_theory" title="Proof theory">proof theory</a>.</p>
<p>The <b>K</b> and <b>S</b> combinators correspond to the axioms</p>
<dl>
<dd><b>AK</b>: <i>A</i> → (<i>B</i> → <i>A</i>),</dd>
<dd><b>AS</b>: (<i>A</i> → (<i>B</i> → <i>C</i>)) → ((<i>A</i> → <i>B</i>) → (<i>A</i> → <i>C</i>)),</dd>
</dl>
<p>and function application corresponds to the detachment (modus ponens) rule</p>
<dl>
<dd><b>MP</b>: from <i>A</i> and <i>A</i> → <i>B</i> infer <i>B</i>.</dd>
</dl>
<p>The calculus consisting of <b>AK</b>, <b>AS</b>, and <b>MP</b> is complete for the implicational fragment of the intuitionistic logic, which can be seen as follows. Consider the set <i>W</i> of all deductively closed sets of formulas, ordered by <a href="/wiki/Inclusion_(set_theory)" title="Inclusion (set theory)" class="mw-redirect">inclusion</a>. Then <img class="tex" alt="\langle W,\subseteq\rangle" src="http://upload.wikimedia.org/math/2/b/3/2b37a66b691d468e899836e8c829d91e.png" /> is an intuitionistic <a href="/wiki/Kripke_semantics" title="Kripke semantics">Kripke frame</a>, and we define a model <img class="tex" alt="\Vdash" src="http://upload.wikimedia.org/math/f/a/b/fab53e7da58e75e9eb1c8b5719631e0b.png" /> in this frame by</p>
<dl>
<dd><img class="tex" alt="X\Vdash A\iff A\in X." src="http://upload.wikimedia.org/math/7/9/2/79271fd613b2d89e89bf22a0b3050c0b.png" /></dd>
</dl>
<p>This definition obeys the conditions on satisfaction of →: on one hand, if <img class="tex" alt="X\Vdash A\to B" src="http://upload.wikimedia.org/math/e/5/e/e5eea0be53faf84f7687ec90c9e3c91a.png" />, and <img class="tex" alt="Y\in W" src="http://upload.wikimedia.org/math/0/c/5/0c5df5806926312c23820e442b872b86.png" /> is such that <img class="tex" alt="Y\supseteq X" src="http://upload.wikimedia.org/math/5/4/9/549c41ef5853f719e63e05a59fbe4488.png" /> and <img class="tex" alt="Y\Vdash A" src="http://upload.wikimedia.org/math/9/3/0/930ffe136386d5b57ffdd758a4e09394.png" />, then <img class="tex" alt="Y\Vdash B" src="http://upload.wikimedia.org/math/6/b/7/6b7922b1220562162594e95dc131c7dd.png" /> by modus ponens. On the other hand, if <img class="tex" alt="X\not\Vdash A\to B" src="http://upload.wikimedia.org/math/0/2/e/02e3742b33edfe9ea85440d3031ee460.png" />, then <img class="tex" alt="X,A\not\vdash B" src="http://upload.wikimedia.org/math/8/b/8/8b842c145038485447f6d8db8e9a367f.png" /> by the <a href="/wiki/Deduction_theorem" title="Deduction theorem">deduction theorem</a>, thus the deductive closure of <img class="tex" alt="X\cup\{A\}" src="http://upload.wikimedia.org/math/a/3/d/a3d5f9be6deaaedb93307c0b60724951.png" /> is an element <img class="tex" alt="Y\in W" src="http://upload.wikimedia.org/math/0/c/5/0c5df5806926312c23820e442b872b86.png" /> such that <img class="tex" alt="Y\supseteq X" src="http://upload.wikimedia.org/math/5/4/9/549c41ef5853f719e63e05a59fbe4488.png" />, <img class="tex" alt="Y\Vdash A" src="http://upload.wikimedia.org/math/9/3/0/930ffe136386d5b57ffdd758a4e09394.png" />, and <img class="tex" alt="Y\not\Vdash B" src="http://upload.wikimedia.org/math/d/9/d/d9d8c5df4ea9e263c73d37246e81c6a1.png" />.</p>
<p>Let <i>A</i> be any formula which is not provable in the calculus. Then <i>A</i> does not belong to the deductive closure <i>X</i> of the empty set, thus <img class="tex" alt="X\not\Vdash A" src="http://upload.wikimedia.org/math/8/6/6/86606eceb5e75fd9365f40b30069bea8.png" />, and <i>A</i> is not intuitionistically valid.</p>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=21" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/SKI_combinator_calculus" title="SKI combinator calculus">SKI combinator calculus</a></li>
<li><a href="/wiki/B,C,K,W_system" title="B,C,K,W system">B,C,K,W system</a></li>
<li><a href="/wiki/Fixed_point_combinator" title="Fixed point combinator">Fixed point combinator</a></li>
<li><a href="/wiki/Graph_reduction_machine" title="Graph reduction machine">graph reduction machine</a></li>
<li><a href="/wiki/Supercombinator" title="Supercombinator">supercombinators</a></li>
<li><a href="/wiki/Lambda_calculus" title="Lambda calculus">Lambda calculus</a> and <a href="/wiki/Cylindric_algebra" title="Cylindric algebra">Cylindric algebra</a>, other approaches to modelling quantification and eliminating variables</li>
<li><i><a href="/wiki/To_Mock_a_Mockingbird" title="To Mock a Mockingbird">To Mock a Mockingbird</a></i></li>
<li><a href="/wiki/Combinatory_categorial_grammar" title="Combinatory categorial grammar">combinatory categorial grammar</a></li>
<li><a href="/wiki/Categorical_abstract_machine" title="Categorical abstract machine">Categorical abstract machine</a></li>
<li><a href="/wiki/Applicative_computing_systems" title="Applicative computing systems">Applicative computing systems</a></li>
</ul>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=22" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<ol class="references">
<li id="cite_note-Seldin_2006-0"><b><a href="#cite_ref-Seldin_2006_0-0" title="">^</a></b> <cite style="font-style:normal" class="" id="CITEREFSeldin">Seldin, Jonathan. <i>The Logic of Curry and Church</i>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+Logic+of+Curry+and+Church&amp;rft.aulast=Seldin&amp;rft.aufirst=Jonathan&amp;rft.au=Seldin%2C+Jonathan&amp;rfr_id=info:sid/en.wikipedia.org:Combinatory_logic"><span style="display: none;">&#160;</span></span></li>
</ol>
<p><a name="Further_reading" id="Further_reading"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=23" title="Edit section: Further reading">edit</a>]</span> <span class="mw-headline">Further reading</span></h2>
<ul>
<li><a href="/wiki/Hendrik_Pieter_Barendregt" title="Hendrik Pieter Barendregt" class="mw-redirect">Hendrik Pieter Barendregt</a>, 1984. <i>The Lambda Calculus, Its Syntax and Semantics</i>. Studies in Logic and the Foundations of Mathematics, Volume 103, North-Holland. <a href="/wiki/Special:BookSources/0444875085" class="internal">ISBN 0-444-87508-5</a></li>
<li><cite style="font-style:normal" class="book" id="CITEREFCurryRobert_Feys1958">Curry, Haskell B.; Robert Feys (1958). <i>Combinatory Logic Vol. I</i>. <b>1</b>. Amsterdam: North Holland.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Combinatory+Logic+Vol.+I&amp;rft.aulast=Curry&amp;rft.aufirst=Haskell+B.&amp;rft.au=Curry%2C+Haskell+B.&amp;rft.au=Robert+Feys&amp;rft.date=1958&amp;rft.volume=1&amp;rft.place=Amsterdam&amp;rft.pub=North+Holland&amp;rfr_id=info:sid/en.wikipedia.org:Combinatory_logic"><span style="display: none;">&#160;</span></span></li>
<li><cite style="font-style:normal" class="book" id="CITEREFCurryJ._Roger_Hindley_and_Jonathan_P._Seldin1972">Curry, Haskell B.; J. Roger Hindley and Jonathan P. Seldin (1972). <i>Combinatory Logic Vol. II</i>. <b>2</b>. Amsterdam: North Holland. <a href="/wiki/Special:BookSources/0720422086" class="internal">ISBN 0-7204-2208-6</a>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Combinatory+Logic+Vol.+II&amp;rft.aulast=Curry&amp;rft.aufirst=Haskell+B.&amp;rft.au=Curry%2C+Haskell+B.&amp;rft.au=J.+Roger+Hindley+and+Jonathan+P.+Seldin&amp;rft.date=1972&amp;rft.volume=2&amp;rft.place=Amsterdam&amp;rft.pub=North+Holland&amp;rft.isbn=0-7204-2208-6&amp;rfr_id=info:sid/en.wikipedia.org:Combinatory_logic"><span style="display: none;">&#160;</span></span></li>
<li>Field, Anthony J. and Peter G. Harrison, 1998. <i>Functional Programming</i>. . Addison-Wesley. <a href="/wiki/Special:BookSources/0201192497" class="internal">ISBN 0-201-19249-7</a></li>
<li>Hindley, Roger, and Meredith, 1990, "Principal Type-Schemes and Condensed Detachment," <i>Journal of Symbolic Logic 55</i>: 90-105</li>
<li>Paulson, Lawrence C., 1995. <i><a href="http://www.cl.cam.ac.uk/Teaching/Lectures/founds-fp/Founds-FP.ps.gz" class="external text" title="http://www.cl.cam.ac.uk/Teaching/Lectures/founds-fp/Founds-FP.ps.gz" rel="nofollow">Foundations of Functional Programming.</a></i> University of Cambridge.</li>
<li><span id="Quine_1960"><a href="/wiki/Willard_Van_Orman_Quine" title="Willard Van Orman Quine">Quine, W. V.</a>, 1960 "Variables explained away", <i>Proceedings of the American Philosophical Society</i> <b>104</b>:3:343-347 (Jun. 15, 1960) <a href="http://links.jstor.org/sici?sici=0003-049X%2819600615%29104%3A3%3C343%3AVEA%3E2.0.CO%3B2-W" class="external text" title="http://links.jstor.org/sici?sici=0003-049X%2819600615%29104%3A3%3C343%3AVEA%3E2.0.CO%3B2-W" rel="nofollow">at JSTOR</a>. Reprinted as Chapter 23 of Quine's <i>Selected Logic Papers</i> (1966), pp. 227–235</span></li>
<li><a href="/wiki/Moses_Sch%C3%B6nfinkel" title="Moses Schönfinkel">Moses Schönfinkel</a>, 1924, "Über die Bausteine der mathematischen Logik," translated as "On the Building Blocks of Mathematical Logic" in <i>From Frege to Gödel: a source book in mathematical logic, 1879-1931</i>, <a href="/wiki/Jean_van_Heijenoort" title="Jean van Heijenoort" class="mw-redirect">Jean van Heijenoort</a>, ed. Harvard University Press, 1967. <a href="/wiki/Special:BookSources/0674324498" class="internal">ISBN 0-674-32449-8</a>. The article that founded combinatory logic.</li>
<li>Sørensen, Morten Heine B. and Paweł Urzyczyn, 1999. <i><a href="http://folli.loria.fr/cds/1999/library/pdf/curry-howard.pdf" class="external text" title="http://folli.loria.fr/cds/1999/library/pdf/curry-howard.pdf" rel="nofollow">Lectures on the Curry-Howard Isomorphism.</a></i> University of Copenhagen and University of Warsaw, 1999.</li>
<li><a href="/wiki/Raymond_Smullyan" title="Raymond Smullyan">Smullyan, Raymond</a>, 1985. <i><a href="/wiki/To_Mock_a_Mockingbird" title="To Mock a Mockingbird">To Mock a Mockingbird</a></i>. Knopf. <a href="/wiki/Special:BookSources/0394534913" class="internal">ISBN 0-394-53491-3</a>. A gentle introduction to combinatory logic, presented as a series of recreational puzzles using bird watching metaphors.</li>
<li>--------, 1994. <i>Diagonalization and Self-Reference</i>. Oxford Univ. Press. Chpts. 17-20 are a more formal introduction to combinatory logic, with a special emphasis on fixed point results.</li>
<li>Wolfengagen, V.E. <i><a href="http://vew.0catch.com/books/Wolfengagen_CLP-2003-En.djvu" class="external text" title="http://vew.0catch.com/books/Wolfengagen_CLP-2003-En.djvu" rel="nofollow">Combinatory logic in programming.</a> Computations with objects through examples and exercises</i>. -- 2-nd ed. -- M.: "Center JurInfoR" Ltd., 2003. -- x+337 с. <a href="/wiki/Special:BookSources/5891581019" class="internal">ISBN 5-89158-101-9</a>.</li>
</ul>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Combinatory_logic&amp;action=edit&amp;section=24" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://plato.stanford.edu/entries/logic-combinatory/" class="external text" title="http://plato.stanford.edu/entries/logic-combinatory/" rel="nofollow">Combinatory Logic – (SEP entry)</a> by <i>Katalin Bimbó</i></li>
<li><a href="http://www.sadl.uleth.ca/gsdl/cgi-bin/library?a=p&amp;p=about&amp;c=curry" class="external text" title="http://www.sadl.uleth.ca/gsdl/cgi-bin/library?a=p&amp;p=about&amp;c=curry" rel="nofollow">1920–1931 Curry's block notes</a></li>
<li>Keenan, David C. (2001) <a href="http://users.bigpond.net.au/d.keenan/Lambda/index.htm" class="external text" title="http://users.bigpond.net.au/d.keenan/Lambda/index.htm" rel="nofollow">To Dissect a Mockingbird</a></li>
<li>Rathman, Chris, <a href="http://www.angelfire.com/tx4/cus/combinator/birds.html" class="external text" title="http://www.angelfire.com/tx4/cus/combinator/birds.html" rel="nofollow">Combinator Birds</a></li>
<li><a href="http://cstein.kings.cam.ac.uk/~chris/combinators.html" class="external text" title="http://cstein.kings.cam.ac.uk/~chris/combinators.html" rel="nofollow">Drag 'n' Drop Combinators (Java Applet)</a></li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 1877/1000000
Post-expand include size: 10220/2048000 bytes
Template argument size: 2759/2048000 bytes
Expensive parser function count: 0/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:149848-0!1!0!default!!en!2 and timestamp 20090407055959 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Combinatory_logic">http://en.wikipedia.org/wiki/Combinatory_logic</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Lambda_calculus" title="Category:Lambda calculus">Lambda calculus</a></span> | <span dir='ltr'><a href="/wiki/Category:Logic_in_computer_science" title="Category:Logic in computer science">Logic in computer science</a></span> | <span dir='ltr'><a href="/wiki/Category:Combinatory_logic" title="Category:Combinatory logic">Combinatory logic</a></span></div><div id="mw-hidden-catlinks" class="mw-hidden-cats-hidden">Hidden categories:&#32;<span dir='ltr'><a href="/wiki/Category:Articles_to_be_merged_since_January_2008" title="Category:Articles to be merged since January 2008">Articles to be merged since January 2008</a></span> | <span dir='ltr'><a href="/wiki/Category:All_articles_to_be_merged" title="Category:All articles to be merged">All articles to be merged</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Combinatory_logic" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Combinatory_logic" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Combinatory_logic&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Combinatory_logic&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Combinatory_logic" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Combinatory_logic" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Combinatory_logic" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Combinatory_logic&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Combinatory_logic&amp;oldid=259894237" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Combinatory_logic&amp;id=259894237">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Kombinatorische_Logik">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/L%C3%B3gica_combinatoria">Español</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Logique_combinatoire">Français</a></li>
				<li class="interwiki-hr"><a href="http://hr.wikipedia.org/wiki/Kombinatorna_logika">Hrvatski</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Rachunek_kombinator%C3%B3w">Polski</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B1%D0%B8%D0%BD%D0%B0%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0">Русский</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E5%AD%90%E9%80%BB%E8%BE%91">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 24 December 2008, at 11:40 (UTC).</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv50 in 0.073 secs. --></body></html>
