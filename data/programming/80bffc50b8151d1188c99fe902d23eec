<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<meta name="generator" content="MediaWiki 1.15alpha" />
		<meta name="keywords" content="Garbage collection (computer science),Articles needing additional references from January 2008,Articles with unsourced statements since June 2007,Articles with unsourced statements since September 2008,Wikipedia articles needing clarification from September 2008,Articles with dead external links since March 2009,Fact,.NET Framework,.NET Micro Framework,APL (programming language),Abstraction (computer science)" />
		<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit" />
		<link rel="edit" title="Edit this page" href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit" />
		<link rel="apple-touch-icon" href="http://en.wikipedia.org/apple-touch-icon.png" />
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)" />
		<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html" />
		<link rel="alternate" type="application/rss+xml" title="Wikipedia RSS Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=rss" />
		<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom Feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom" />
		<title>Garbage collection (computer science) - Wikipedia, the free encyclopedia</title>
		<link rel="stylesheet" href="/skins-1.5/common/shared.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/common/commonPrint.css?207xx" type="text/css" media="print" />
		<link rel="stylesheet" href="/skins-1.5/monobook/main.css?207xx" type="text/css" media="screen" />
		<link rel="stylesheet" href="/skins-1.5/chick/main.css?207xx" type="text/css" media="handheld" />
		<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<!--[if IE 7]><link rel="stylesheet" href="/skins-1.5/monobook/IE70Fixes.css?207xx" type="text/css" media="screen" /><![endif]-->
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Common.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Print.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="print" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Handheld.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" media="handheld" />
		<link rel="stylesheet" href="/w/index.php?title=MediaWiki:Monobook.css&amp;usemsgcache=yes&amp;ctype=text%2Fcss&amp;smaxage=2678400&amp;action=raw&amp;maxage=2678400" type="text/css" />
		<link rel="stylesheet" href="/w/index.php?title=-&amp;action=raw&amp;maxage=2678400&amp;gen=css" type="text/css" />
		<!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?207xx"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->

		<script type= "text/javascript">/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Garbage_collection_(computer_science)";
		var wgTitle = "Garbage collection (computer science)";
		var wgAction = "view";
		var wgArticleId = "6734";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 281543359;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</script>

		<script type="text/javascript" src="/skins-1.5/common/wikibits.js?207xx"><!-- wikibits js --></script>
		<!-- Head Scripts -->
		<script type="text/javascript" src="/skins-1.5/common/ajax.js?207xx"></script>
		<script type="text/javascript" src="/skins-1.5/common/mwsuggest.js?207xx"></script>
<script type="text/javascript">/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/</script>		<script type="text/javascript" src="http://upload.wikimedia.org/centralnotice/wikipedia/en/centralnotice.js?207xx"></script>
<style type="text/css">/*<![CDATA[*/
.source-java {line-height: normal;}
.source-java li, .source-java pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java
 * CSS class: source-java, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-java .de1, .source-java .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-java  {}
.source-java .head {}
.source-java .foot {}
.source-java .imp {font-weight: bold; color: red;}
.source-java .ln-xtra {color: #cc0; background-color: #ffc;}
.source-java li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-java li.li2 {font-weight: bold;}
.source-java .kw1 {color: #b1b100;}
.source-java .kw2 {color: #000000; font-weight: bold;}
.source-java .kw3 {color: #aaaadd; font-weight: bold;}
.source-java .kw4 {color: #993333;}
.source-java .co1 {color: #808080; font-style: italic;}
.source-java .co2 {color: #a1a100;}
.source-java .coMULTI {color: #808080; font-style: italic;}
.source-java .es0 {color: #000099; font-weight: bold;}
.source-java .br0 {color: #66cc66;}
.source-java .st0 {color: #ff0000;}
.source-java .nu0 {color: #cc66cc;}
.source-java .me1 {color: #006600;}
.source-java .me2 {color: #006600;}

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
</style>		<script type="text/javascript" src="/w/index.php?title=-&amp;action=raw&amp;gen=js&amp;useskin=monobook"><!-- site js --></script>
	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Garbage_collection_computer_science skin-monobook">
	<div id="globalWrapper">
		<div id="column-content">
	<div id="content">
		<a name="top" id="top"></a>
		<div id="siteNotice"><script type='text/javascript'>if (wgNotice != '') document.writeln(wgNotice);</script></div>		<h1 id="firstHeading" class="firstHeading">Garbage collection (computer science)</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From Wikipedia, the free encyclopedia</h3>
			<div id="contentSub"></div>
									<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<table class="metadata plainlinks ambox ambox-content" style="">
<tr>
<td class="mbox-image">
<div style="width: 52px;"><a href="/wiki/File:Question_book-new.svg" class="image" title="Question book-new.svg"><img alt="" src="http://upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png" width="50" height="39" border="0" /></a></div>
</td>
<td class="mbox-text" style="">This article <b>needs additional <a href="/wiki/Wikipedia:Citing_sources" title="Wikipedia:Citing sources">citations</a> for <a href="/wiki/Wikipedia:Verifiability" title="Wikipedia:Verifiability">verification</a>.</b> Please help <a href="http://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit" class="external text" title="http://en.wikipedia.org/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit" rel="nofollow">improve this article</a> by adding <a href="/wiki/Wikipedia:Reliable_sources" title="Wikipedia:Reliable sources">reliable references</a> (ideally, using <i><a href="/wiki/Wikipedia:Footnotes" title="Wikipedia:Footnotes">inline citations</a></i>). Unsourced material may be <a href="/wiki/Template:Fact" title="Template:Fact">challenged</a> and <a href="/wiki/Wikipedia:BURDEN" title="Wikipedia:BURDEN" class="mw-redirect">removed</a>. <small><i>(January 2008)</i></small></td>
</tr>
</table>
<p>In <a href="/wiki/Computer_science" title="Computer science">computer science</a>, <b>garbage collection</b> (<b>GC</b>) is a form of automatic <a href="/wiki/Memory_management" title="Memory management">memory management</a>. The <i>garbage collector</i>, or just <i>collector</i>, attempts to reclaim <i><a href="/wiki/Garbage_(computer_science)" title="Garbage (computer science)">garbage</a></i>, or memory used by <a href="/wiki/Object_(computer_science)" title="Object (computer science)">objects</a> that will never be accessed or mutated again by the <a href="/wiki/Application_software" title="Application software">application</a>. Garbage collection was invented by <a href="/wiki/John_McCarthy_(computer_scientist)" title="John McCarthy (computer scientist)">John McCarthy</a> around 1959 to solve the problems of manual memory management in <a href="/wiki/Lisp_(programming_language)" title="Lisp (programming language)">Lisp</a>.<sup id="cite_ref-0" class="reference"><a href="#cite_note-0" title=""><span>[</span>1<span>]</span></a></sup></p>
<p>Garbage collection is often portrayed as the opposite of <a href="/wiki/Manual_memory_management" title="Manual memory management">manual memory management</a>, which requires the programmer to specify which objects to deallocate and return to the memory system. However, many systems use a combination of the two approaches, and there are other techniques being studied (such as <a href="/wiki/Region_inference" title="Region inference">region inference</a>) to solve the same fundamental problem.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1" title=""><span>[</span>2<span>]</span></a></sup></p>
<table id="toc" class="toc" summary="Contents">
<tr>
<td>
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1"><a href="#Description"><span class="tocnumber">1</span> <span class="toctext">Description</span></a>
<ul>
<li class="toclevel-2"><a href="#Benefits"><span class="tocnumber">1.1</span> <span class="toctext">Benefits</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Tracing_garbage_collectors"><span class="tocnumber">2</span> <span class="toctext">Tracing garbage collectors</span></a>
<ul>
<li class="toclevel-2"><a href="#Reachability_of_an_object"><span class="tocnumber">2.1</span> <span class="toctext">Reachability of an object</span></a></li>
<li class="toclevel-2"><a href="#Basic_algorithm"><span class="tocnumber">2.2</span> <span class="toctext">Basic algorithm</span></a>
<ul>
<li class="toclevel-3"><a href="#Naive_mark-and-sweep"><span class="tocnumber">2.2.1</span> <span class="toctext">Naive mark-and-sweep</span></a></li>
<li class="toclevel-3"><a href="#Tri-colour_marking"><span class="tocnumber">2.2.2</span> <span class="toctext">Tri-colour marking</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Implementation_strategies"><span class="tocnumber">2.3</span> <span class="toctext">Implementation strategies</span></a>
<ul>
<li class="toclevel-3"><a href="#Moving_vs._non-moving"><span class="tocnumber">2.3.1</span> <span class="toctext">Moving vs. non-moving</span></a></li>
<li class="toclevel-3"><a href="#Copying_vs._mark-and-sweep_vs._mark-and-don.27t-sweep"><span class="tocnumber">2.3.2</span> <span class="toctext">Copying vs. mark-and-sweep vs. mark-and-don't-sweep</span></a></li>
<li class="toclevel-3"><a href="#Generational_GC_.28aka_Ephemeral_GC.29"><span class="tocnumber">2.3.3</span> <span class="toctext">Generational GC (aka Ephemeral GC)</span></a></li>
<li class="toclevel-3"><a href="#Stop-the-world_vs._incremental_vs._concurrent"><span class="tocnumber">2.3.4</span> <span class="toctext">Stop-the-world vs. incremental vs. concurrent</span></a></li>
<li class="toclevel-3"><a href="#Precise_vs._conservative_and_internal_pointers"><span class="tocnumber">2.3.5</span> <span class="toctext">Precise vs. conservative and internal pointers</span></a></li>
</ul>
</li>
<li class="toclevel-2"><a href="#Performance_implications"><span class="tocnumber">2.4</span> <span class="toctext">Performance implications</span></a></li>
<li class="toclevel-2"><a href="#Determinism"><span class="tocnumber">2.5</span> <span class="toctext">Determinism</span></a></li>
</ul>
</li>
<li class="toclevel-1"><a href="#Reference_counting"><span class="tocnumber">3</span> <span class="toctext">Reference counting</span></a></li>
<li class="toclevel-1"><a href="#Escape_analysis"><span class="tocnumber">4</span> <span class="toctext">Escape analysis</span></a></li>
<li class="toclevel-1"><a href="#Availability"><span class="tocnumber">5</span> <span class="toctext">Availability</span></a></li>
<li class="toclevel-1"><a href="#Limited_environments"><span class="tocnumber">6</span> <span class="toctext">Limited environments</span></a></li>
<li class="toclevel-1"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1"><a href="#References"><span class="tocnumber">8</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1"><a href="#External_links"><span class="tocnumber">9</span> <span class="toctext">External links</span></a></li>
</ul>
</td>
</tr>
</table>
<script type="text/javascript">
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</script>
<p><a name="Description" id="Description"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=1" title="Edit section: Description">edit</a>]</span> <span class="mw-headline">Description</span></h2>
<p>The basic principles of garbage collection are:</p>
<ol>
<li>Find data objects in a program that cannot be accessed in the future</li>
<li>Reclaim the resources used by those objects</li>
</ol>
<p>By making manual memory deallocation unnecessary (and often forbidding it), garbage collection frees the programmer from having to worry about releasing objects that are no longer needed, which can otherwise consume a significant amount of design effort. It also aids programmers in their efforts to make programs more stable, because it prevents several classes of runtime errors. For example, it prevents <a href="/wiki/Dangling_pointer" title="Dangling pointer">dangling pointer</a> errors, where a reference to a deallocated object is used. (The pointer still points to the location in memory where the object or data was, even though the object or data has since been deleted and the memory may now be used for other purposes, creating a dangling pointer. This can, and often does, lead to <a href="/wiki/Storage_violation" title="Storage violation">storage violation</a> errors that are extremely difficult to detect.)</p>
<p>Many <a href="/wiki/Programming_language" title="Programming language">computer languages</a> require garbage collection, either as part of the language specification (e.g., <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, <a href="/wiki/C_Sharp_(programming_language)" title="C Sharp (programming language)">C#</a>, and most <a href="/wiki/Scripting_languages" title="Scripting languages" class="mw-redirect">scripting languages</a>) or effectively for practical implementation (e.g., formal languages like <a href="/wiki/Lambda_calculus" title="Lambda calculus">lambda calculus</a>); these are said to be <b>garbage collected languages</b>. Other languages were designed for use with manual memory management, but have garbage collected implementations (e.g., <a href="/wiki/C_(programming_language)" title="C (programming language)">C</a>, <a href="/wiki/C%2B%2B" title="C++">C++</a>). <a href="/wiki/Object_Pascal" title="Object Pascal">Delphi</a> versions support garbage collected dynamic arrays, long strings, variants and interfaces. Some languages, like <a href="/wiki/Ada_(programming_language)" title="Ada (programming language)">Ada</a> and <a href="/wiki/Modula-3" title="Modula-3">Modula-3</a>, allow both garbage collection and <a href="/wiki/Manual_memory_management" title="Manual memory management">manual memory management</a> to co-exist in the same application by using separate heaps for collected and manually managed objects, or yet others like <a href="/wiki/D_(programming_language)" title="D (programming language)">D</a>, which is garbage collected but allows the user to manually delete objects and also entirely disable garbage collection when speed is required. In any case, it is far easier to implement garbage collection as part of the language's <a href="/wiki/Compiler" title="Compiler">compiler</a> and <a href="/wiki/Runtime" title="Runtime">runtime</a> system,<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since June 2007" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup> but <i>post hoc</i> GC systems exist, including ones that do not require recompilation. The garbage collector will almost always be closely integrated with the <a href="/wiki/Dynamic_memory_allocation" title="Dynamic memory allocation">memory allocator</a>.</p>
<p><a name="Benefits" id="Benefits"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=2" title="Edit section: Benefits">edit</a>]</span> <span class="mw-headline">Benefits</span></h3>
<p>Garbage collection frees the programmer from manually dealing with memory allocation and deallocation. As a result, certain categories of bugs are eliminated or substantially reduced:</p>
<ul>
<li><b>Dangling pointer bugs</b>, which occur when a piece of memory is freed while there are still pointers to it, and one of those pointers is used.</li>
<li><b>Double free bugs</b>, which occur when the program attempts to free a region of memory that is already free.</li>
<li>Certain kinds of <b><a href="/wiki/Memory_leak" title="Memory leak">memory leaks</a></b>, in which a program fails to free memory that is no longer referenced by any variable, leading, over time, to memory exhaustion.</li>
</ul>
<p>Researchers draw a distinction between "physical" and "logical" memory leaks. In a physical memory leak, the last pointer to a region of allocated memory is removed, but the memory is not freed. In a logical memory leak, a region of memory is still referenced by a pointer, but is never actually used.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2" title=""><span>[</span>3<span>]</span></a></sup> Garbage collectors generally can do nothing about logical memory leaks. Novice programmers sometimes believe that garbage collection makes memory leaks impossible, not realizing that <i>logical</i> leaks are still possible.</p>
<p>In languages that provide dynamic allocation, garbage collection is crucial to <a href="/wiki/Memory_safety" title="Memory safety">memory safety</a> and often to the associated property of <a href="/wiki/Type_safety" title="Type safety">type safety</a>. This in turn improves the <a href="/wiki/Computer_security" title="Computer security">security</a> of the language by preventing a wide class of security <a href="/wiki/Vulnerability_(computing)" title="Vulnerability (computing)">vulnerabilities</a> based on over-writing memory in unexpected ways.</p>
<p><a name="Tracing_garbage_collectors" id="Tracing_garbage_collectors"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=3" title="Edit section: Tracing garbage collectors">edit</a>]</span> <span class="mw-headline">Tracing garbage collectors</span></h2>
<p>Tracing garbage collectors are the most common type of garbage collector. They first determine which objects are <i>reachable</i> (or potentially reachable), and then discard all remaining objects.</p>
<p><a name="Reachability_of_an_object" id="Reachability_of_an_object"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=4" title="Edit section: Reachability of an object">edit</a>]</span> <span class="mw-headline">Reachability of an object</span></h3>
<p>Informally, a reachable object can be defined as an object for which there exists some variable in the program environment that leads to it, either directly or through references from other reachable objects. More precisely, objects can be reachable in only two ways:</p>
<ol>
<li>A distinguished set of objects are assumed to be reachable—these are known as the <i>roots.</i> Typically, these include all the objects referenced from anywhere in the <a href="/wiki/Call_stack" title="Call stack">call stack</a> (that is, all local variables and parameters in the functions currently being invoked), and any global variables.</li>
<li>Anything referenced from a reachable object is itself reachable; more formally, reachability is a <a href="/wiki/Transitive_closure" title="Transitive closure">transitive closure</a>.</li>
</ol>
<p>The reachability definition of "garbage" is not optimal, insofar as the last time a program uses an object could be long before that object falls out of the environment scope. A distinction is sometimes drawn between <i>syntactic garbage</i>, those objects the program cannot possibly reach, and <i>semantic garbage</i>, those objects the program will in fact never again use. For example:</p>
<div dir="ltr" style="text-align: left;">
<pre class="source-java">
<span class="kw3">Object</span> x = <span class="kw2">new</span> Foo<span class="br0">(</span><span class="br0">)</span>;
<span class="kw3">Object</span> y = <span class="kw2">new</span> Bar<span class="br0">(</span><span class="br0">)</span>;
x = <span class="kw2">new</span> Quux<span class="br0">(</span><span class="br0">)</span>;
<span class="coMULTI">/* at this point, we know that the Foo object will
 * never be accessed - it is syntactic garbage
 */</span>
 
<span class="kw1">if</span><span class="br0">(</span>x.<span class="me1">check_something</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
  x.<span class="me1">do_something</span><span class="br0">(</span>y<span class="br0">)</span>;
<span class="br0">}</span>
<span class="kw3">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span>;
<span class="coMULTI">/* in the above block, y *could* be semantic garbage,
 * but we won't know until x.check_something() returns
 * some value - if it returns at all
 */</span>
</pre></div>
<p>The problem of precisely identifying semantic garbage can easily be shown to be <a href="/wiki/Decision_problem" title="Decision problem">partially decidable</a>: a program that allocates an object <i>X</i>, runs an arbitrary input program <i>P</i>, and uses <i>X</i> if and only if <i>P</i> finishes would require a semantic garbage collector to solve the <a href="/wiki/Halting_problem" title="Halting problem">halting problem</a>. Although conservative heuristic methods for semantic garbage detection remain an active research area, essentially all practical garbage collectors focus on syntactic garbage.<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since September 2008" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup></p>
<p>Another complication with this approach is that, in languages with both <a href="/wiki/Reference_type" title="Reference type">reference types</a> and unboxed <a href="/wiki/Value_type" title="Value type">value types</a>, the garbage collector needs to somehow be able to distinguish which variables on the stack or fields in an object are regular values and which are references; since in memory, an integer and a reference might look alike. This often runs into problems with <a href="/wiki/Generic_programming" title="Generic programming">generic programming</a>, where you may want to have a generic container class be able to hold various types of elements (e.g. the programmers want to have a list that can hold integers or references, or a mix of them). The garbage collector then needs to know whether to treat the element as a reference and follow it, or whether it is a primitive value. One common solution is the use of <a href="/wiki/Tagged_pointer" title="Tagged pointer">Tagged pointers</a>.</p>
<p><a name="Basic_algorithm" id="Basic_algorithm"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=5" title="Edit section: Basic algorithm">edit</a>]</span> <span class="mw-headline">Basic algorithm</span></h3>
<p>Tracing collectors are so called because they trace through the working set of memory. These garbage collectors perform collection in cycles. A cycle is started when the collector decides (or is notified) that it needs to reclaim memory, which happens most often when the system is low on memory. The original method involves a naive <b>mark-and-sweep</b> in which the entire memory set is touched several times.</p>
<p><a name="Naive_mark-and-sweep" id="Naive_mark-and-sweep"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=6" title="Edit section: Naive mark-and-sweep">edit</a>]</span> <span class="mw-headline">Naive mark-and-sweep</span></h4>
<p>In the naive mark-and-sweep method, each object in memory has a flag (typically a single bit) reserved for garbage collection use only. This flag is always <i>cleared</i> (counter-intuitively), except during the collection cycle. The first stage of collection sweeps the entire 'root set', marking each accessible object as being 'in-use'. All objects transitively accessible from the root set are marked, as well. Finally, each object in memory is again examined; those with the in-use flag still cleared are not reachable by any program or data, and their memory is freed. (For objects which are marked in-use, the in-use flag is cleared again, preparing for the next cycle.)</p>
<p>This method has several disadvantages, the most notable being that the entire system must be suspended during collection; no mutation of the working set can be allowed. This will cause programs to 'freeze' periodically (and generally unpredictably), making real-time and time-critical applications impossible. In addition, the entire working memory must be examined, much of it twice, potentially causing problems in <a href="/wiki/Paged_memory" title="Paged memory" class="mw-redirect">paged memory</a> systems.</p>
<p><a name="Tri-colour_marking" id="Tri-colour_marking"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=7" title="Edit section: Tri-colour marking">edit</a>]</span> <span class="mw-headline">Tri-colour marking</span></h4>
<p>Because of these pitfalls, most modern tracing garbage collectors implement some variant of the <i>tri-colour marking</i> <a href="/wiki/Abstraction_(computer_science)" title="Abstraction (computer science)">abstraction</a>, but simple collectors (such as the <i>mark-and-sweep</i> collector) often do not make this abstraction explicit. Tri-colour marking works as follows:</p>
<ol>
<li>Create initial white, grey, and black sets; these sets will be used to maintain progress during the cycle. Initially the white set or <i>condemned set</i> is the set of objects that are candidates for having their memory recycled. The black set is the set of objects that cheaply can be proven to have no references to objects in the white set; in many implementations the black set starts off empty. The grey set is all the remaining objects that may or may not have references to objects in the white set (and elsewhere). These sets <a href="/wiki/Partition_of_a_set" title="Partition of a set">partition</a> memory; every object in the system, including the root set, is in precisely one set.</li>
<li>Pick an object from the grey set. <i>Blacken</i> this object (move it to the black set), by <i>greying</i> all the white objects it references directly.</li>
<li>Repeat the previous step until the grey set is empty.</li>
<li>When there are no more objects in the grey set, then all the objects remaining in the white set are provably not reachable and the storage occupied by them can be reclaimed.</li>
</ol>
<p>The tri-colour marking algorithm preserves an important invariant:</p>
<dl>
<dd>No black object points directly to a white object.</dd>
</dl>
<p>This ensures that the white objects can be safely destroyed once the grey set is empty. (Some variations on the algorithm do not preserve the tricolour invariant but they use a modified form for which all the important properties hold.)</p>
<p>The tri-colour method has an important advantage: it can be performed 'on-the-fly', without halting the system for significant time periods. This is accomplished by marking objects as they are allocated and during mutation, maintaining the various sets. By monitoring the size of the sets, the system can perform garbage collection periodically, rather than as-needed. Also, the need to touch the entire working set each cycle is avoided.</p>
<p><a name="Implementation_strategies" id="Implementation_strategies"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=8" title="Edit section: Implementation strategies">edit</a>]</span> <span class="mw-headline">Implementation strategies</span></h3>
<p>In order to implement the basic tri-colour algorithm, several important design decisions must be made, which can significantly affect the performance characteristics of the garbage collector.</p>
<p><a name="Moving_vs._non-moving" id="Moving_vs._non-moving"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=9" title="Edit section: Moving vs. non-moving">edit</a>]</span> <span class="mw-headline">Moving vs. non-moving</span></h4>
<p>Once the unreachable set has been determined, the garbage collector may simply release the <a href="/wiki/Unreachable_object" title="Unreachable object" class="mw-redirect">unreachable objects</a> and leave everything else as it is, or it may copy some or all of the reachable objects into a new area of memory, updating all references to those objects as needed. These are called "non-moving" and "moving" garbage collectors, respectively.</p>
<p>At first, a moving GC strategy may seem inefficient and costly compared to the non-moving approach, since much more work would appear to be required on each cycle. In fact, however, the moving GC strategy leads to several performance advantages, both during the garbage collection cycle itself and during actual program execution:</p>
<ul>
<li>No additional work is required to reclaim the space freed by dead objects; the entire region of memory from which reachable objects were moved can be considered free space. In contrast, a non-moving GC must visit each unreachable object and somehow record that the memory it alone occupied is available.</li>
<li>Similarly, new objects can be allocated very quickly. Since large contiguous regions of memory are usually made available by the moving GC strategy, new objects can be allocated by simply incrementing a 'free memory' pointer. A non-moving strategy may, after some time, lead to a heavily <a href="/wiki/Fragmentation_(computer)" title="Fragmentation (computer)">fragmented</a> heap, requiring expensive consultation of "free lists" of small available blocks of memory in order to allocate new objects.</li>
<li>If an appropriate traversal order is used, objects that refer to each other frequently can be moved very close to each other in memory, increasing the likelihood that they will be located in the same <a href="/wiki/Cache_line" title="Cache line" class="mw-redirect">cache line</a> or <a href="/wiki/Virtual_memory" title="Virtual memory">virtual memory</a> page. This can significantly speed up access to these objects through these references.</li>
</ul>
<p>One disadvantage of a moving garbage collector is that it only allows access through references that are managed by the garbage collected environment, and does not allow <a href="/wiki/Pointer_(computing)" title="Pointer (computing)">pointer arithmetic</a>. This is because any native pointers to objects will be invalidated when the garbage collector moves the object (they become <a href="/wiki/Dangling_pointer" title="Dangling pointer">dangling pointers</a>). For <a href="/wiki/Interoperability" title="Interoperability">interoperability</a> with native code, the garbage collector must copy the object contents to a location outside of the garbage collected region of memory. An alternative approach is to <b>pin</b> the object in memory, preventing the garbage collector from moving it and allowing the memory to be directly shared with native pointers (and possibly allowing pointer arithmetic).<sup id="cite_ref-3" class="reference"><a href="#cite_note-3" title=""><span>[</span>4<span>]</span></a></sup></p>
<p><a name="Copying_vs._mark-and-sweep_vs._mark-and-don.27t-sweep" id="Copying_vs._mark-and-sweep_vs._mark-and-don.27t-sweep"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=10" title="Edit section: Copying vs. mark-and-sweep vs. mark-and-don't-sweep">edit</a>]</span> <span class="mw-headline">Copying vs. mark-and-sweep vs. mark-and-don't-sweep</span></h4>
<p>To further refine the distinction, tracing collectors can also be divided by considering how the three sets of objects (white, grey, and black) are maintained during a collection cycle.</p>
<p>The most straightforward approach is the <b>semi-space collector</b>, which dates to 1969. In this moving GC scheme, memory is partitioned into a "from space" and "to space". Initially, objects are allocated into "to space" until they become full and a collection is triggered. At the start of a collection, the "to space" becomes the "from space", and vice versa. The objects reachable from the root set are copied from the "from space" to the "to space". These objects are scanned in turn, and all objects that they point to are copied to "to space", until all reachable objects have been copied to "to space". Once the program continues execution, new objects are once again allocated from the "to space" until it is once again full and the process is repeated. This approach has the advantage of conceptual simplicity (the three object color sets are implicitly constructed during the copying process), but the disadvantage that a (possibly) very large contiguous region of free memory is necessarily required on every collection cycle. This technique is also known as <b>stop-and-copy</b>. <a href="/wiki/Cheney%27s_algorithm" title="Cheney's algorithm">Cheney's algorithm</a> is an improvement on the semi-space collector.</p>
<p>A <b>mark and sweep</b> garbage collector maintains a bit (or two) with each object to record whether it is white or black; the grey set is either maintained as a separate list (such as the process stack) or using another bit. As the reference tree is traversed during a collection cycle (the "mark" phase), these bits are manipulated by the collector to reflect the current state. A final "sweep" of the memory areas then frees white objects. The mark and sweep strategy has the advantage that, once the unreachable set is determined, either a moving or non-moving collection strategy can be pursued; this choice of strategy can even be made at runtime, as available memory permits. It has the disadvantage of "bloating" objects by a small amount.</p>
<p>A <b>mark and don't sweep</b> garbage collector, like the mark-and-sweep, maintains a bit with each object to record whether it is white or black; the gray set is either maintained as a separate list (such as the process stack) or using another bit. There are two key differences here. First, black and white mean different things than they do in the mark and sweep collector. In a "mark and don't sweep" system, all reachable objects are always black. An object is marked black at the time it is allocated, and it will stay black even if it becomes unreachable. A white object is unused memory and may be allocated. Second, the interpretation of the black/white bit can change. Initially, the black/white bit may have the sense of (0=white, 1=black). If an allocation operation ever fails to find any available (white) memory, that means all objects are marked used (black). The sense of the black/white bit is then inverted (for example, 0=black, 1=white). Everything becomes white. This momentarily breaks the invariant that reachable objects are black, but a full marking phase follows immediately, to mark them black again. Once this is done, all unreachable memory is white. No "sweep" phase is necessary.</p>
<p><a name="Generational_GC_.28aka_Ephemeral_GC.29" id="Generational_GC_.28aka_Ephemeral_GC.29"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=11" title="Edit section: Generational GC (aka Ephemeral GC)">edit</a>]</span> <span class="mw-headline">Generational GC (aka Ephemeral GC)</span></h4>
<p>It has been empirically observed that in many programs, the most recently created objects are also those most likely to become unreachable quickly (known as <i>infant mortality</i> or the <i>generational hypothesis</i>). A generational GC divides objects into generations and, on most cycles, will place only the objects of a subset of generations into the initial white (condemned) set. Furthermore, the runtime system maintains knowledge of when references cross generations by observing the creation and overwriting of references. When the garbage collector runs, it may be able to use this knowledge to prove that some objects in the initial white set are unreachable without having to traverse the entire reference tree. If the generational hypothesis holds, this results in much faster collection cycles while still reclaiming most unreachable objects.</p>
<p>In order to implement this concept, many generational garbage collectors use separate memory regions for different ages of objects. When a region becomes full, those few objects that are referenced from older memory regions are promoted (copied) up to the next highest region, and the entire region can then be overwritten with fresh objects. This technique permits very fast incremental garbage collection, since the garbage collection of only one region at a time is all that is typically required.</p>
<p>Generational garbage collection is a <a href="/wiki/Heuristic_(computer_science)" title="Heuristic (computer science)" class="mw-redirect">heuristic</a> approach, and some unreachable objects may not be reclaimed on each cycle. It may therefore occasionally be necessary to perform a full mark and sweep or copying garbage collection to reclaim all available space. In fact, runtime systems for modern programming languages (such as <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> and the <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>) usually use some hybrid of the various strategies that have been described thus far; for example, most collection cycles might look only at a few generations, while occasionally a mark-and-sweep is performed, and even more rarely a full copying is performed to combat fragmentation. The terms "minor cycle" and "major cycle" are sometimes used to describe these different levels of collector aggression.</p>
<p><a name="Stop-the-world_vs._incremental_vs._concurrent" id="Stop-the-world_vs._incremental_vs._concurrent"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=12" title="Edit section: Stop-the-world vs. incremental vs. concurrent">edit</a>]</span> <span class="mw-headline">Stop-the-world vs. incremental vs. concurrent</span></h4>
<p>Simple <i>stop-the-world</i> garbage collectors completely halt execution of the program to run a collection cycle, thus guaranteeing that new objects are not allocated and objects do not suddenly become unreachable while the collector is running. This has the obvious disadvantage that the program can perform no useful work while a collection cycle is running (sometimes called the "embarrassing pause").</p>
<p><i>Incremental</i> and <i>concurrent</i> garbage collectors are designed to reduce this disruption by interleaving their work with activity from the main program. Incremental garbage collectors perform the garbage collection cycle in discrete phases, with program execution permitted between each phase (and sometimes during some phases). Concurrent garbage collectors do not stop program execution at all, except perhaps briefly when the program's execution stack is scanned. Careful design is necessary with these techniques to ensure that the main program does not interfere with the garbage collector and vice versa; for example, when the program needs to allocate a new object, the runtime system may either need to suspend it until the collection cycle is complete, or somehow notify the garbage collector that there exists a new, reachable object.</p>
<p><a name="Precise_vs._conservative_and_internal_pointers" id="Precise_vs._conservative_and_internal_pointers"></a></p>
<h4><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=13" title="Edit section: Precise vs. conservative and internal pointers">edit</a>]</span> <span class="mw-headline">Precise vs. conservative and internal pointers</span></h4>
<p>Some collectors running in a particular environment can correctly identify all pointers (references) in an object; these are called "precise" (also "exact" or "accurate") collectors, the opposite being a "conservative" or "partly conservative" collector. Conservative collectors have to assume that any bit pattern in memory could be a pointer if (when interpreted as a pointer) it would point into any allocated object. Thus, conservative collectors may have some false negatives, where storage is not released because of accidental fake pointers, but this is rarely a significant drawback in practice, unless the program has to handle data that is or seems to be random and could easily be a pointer. Naturally 64bit systems suffer less from this problem than 32bit systems, since the possibility for a 64bit pattern to form a valid pointer is smaller than for a 32bit pattern as the domain of a 64bit value is much greater than a 32bit value. Thus it is less probable for a "random" 64bit value to point to a region on system's memory. Whether a precise collector is practical usually depends on the type safety properties of the programming language in question. An example for which a conservative garbage collector would be needed is the <a href="/wiki/C_programming_language" title="C programming language" class="mw-redirect">C programming language</a>, which allows typed (non-void) pointers to be type cast into untyped (void) pointers, and vice versa.</p>
<p>A related issue concerns <i>internal pointers</i>, or pointers to fields within an object. If the semantics of a language allow internal pointers, then there may be many different addresses that can refer to the same object, which complicates determining whether an object is garbage or not. An example for this is the <a href="/wiki/C%2B%2B_programming_language" title="C++ programming language" class="mw-redirect">C++ programming language</a>, in which multiple inheritance can cause pointers to base objects to have different addresses. Even in languages like <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a>, however, internal pointers can exist during the computation, say, of an array element address, and in a tightly-optimized program the corresponding pointer to the object itself may have been overwritten in its register, so such internal pointers need to be scanned.</p>
<p><a name="Performance_implications" id="Performance_implications"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=14" title="Edit section: Performance implications">edit</a>]</span> <span class="mw-headline">Performance implications</span></h3>
<p>Tracing garbage collectors require some implicit runtime <a href="/wiki/Computational_overhead" title="Computational overhead">overhead</a> that may be beyond the control of the programmer, and can sometimes lead to performance problems. For example, commonly used stop-the-world garbage collectors, which pause program execution at arbitrary times, may make garbage collection inappropriate for some <a href="/wiki/Embedded_system" title="Embedded system">embedded systems</a>, high-performance <a href="/wiki/Server_(computing)" title="Server (computing)">server</a> software, and applications with <a href="/wiki/Real-time_computing" title="Real-time computing">real-time</a> needs.</p>
<dl>
<dt>Manual heap allocation</dt>
</dl>
<ul>
<li>search for best/first-fit block of sufficient size</li>
<li>free list maintenance</li>
</ul>
<dl>
<dt>Garbage collection</dt>
</dl>
<ul>
<li>locate reachable objects</li>
<li>copy reachable objects for moving collectors</li>
<li>read/write barriers for incremental collectors</li>
<li>search for best/first-fit block and free list maintenance for non-moving collectors</li>
</ul>
<p>It is difficult to compare the two cases directly, as their behavior depends on the situation. For example, in the best case for a garbage collecting system, allocation just increments a pointer, but in the best case for manual heap allocation, the allocator maintains freelists of specific sizes and allocation only requires following a pointer. However, this size segregation usually cause a large degree of external fragmentation, which can have an adverse impact on cache behaviour. Memory allocation in a garbage collected language may be implemented using heap allocation behind the scenes (rather than simply incrementing a pointer), so the performance advantages listed above don't necessarily apply in this case. In some situations, most notably <a href="/wiki/Embedded_systems" title="Embedded systems" class="mw-redirect">embedded systems</a>, it is possible to avoid both garbage collection and heap management overhead by preallocating pools of memory and using a custom, lightweight scheme for allocation/deallocation.<sup id="cite_ref-4" class="reference"><a href="#cite_note-4" title=""><span>[</span>5<span>]</span></a></sup></p>
<p>The overhead of write barriers is more likely to be noticeable in an <a href="/wiki/Imperative_programming" title="Imperative programming">imperative</a>-style program which frequently writes pointers into existing data structures than in a <a href="/wiki/Functional_programming" title="Functional programming">functional</a>-style program which constructs data only once and never changes them.</p>
<p>Some advances in garbage collection can be understood as reactions to performance issues. Early collectors were stop-the-world collectors, but the performance of this approach was distracting in interactive applications. Incremental collection avoided this disruption, but at the cost of decreased efficiency due to the need for barriers. Generational collection techniques are used with both stop-the-world and incremental collectors to increase performance; the trade-off is that some garbage is not detected as such for longer than normal.</p>
<p><a name="Determinism" id="Determinism"></a></p>
<h3><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=15" title="Edit section: Determinism">edit</a>]</span> <span class="mw-headline">Determinism</span></h3>
<p>The main disadvantage of tracing garbage collection is that it is not <a href="/wiki/Deterministic" title="Deterministic" class="mw-redirect">deterministic</a>. An object which becomes eligible for garbage collection will usually be cleaned up eventually, but there is no guarantee when (or even if) that will happen. The reason is that the operating mechanism of tracing garbage collection makes it difficult to give any such guarantees.</p>
<p>This can cause a number of problems in practice.</p>
<ul>
<li>It is difficult to provide <a href="/wiki/Destructor" title="Destructor">destructors</a> that run deterministically (ideally right after an object becomes eligible for GC).<sup id="cite_ref-5" class="reference"><a href="#cite_note-5" title=""><span>[</span>6<span>]</span></a></sup> Therefore, frameworks with tracing GC (such as <a href="/wiki/Java_(software_platform)" title="Java (software platform)">Java</a> and <a href="/wiki/.NET_Framework" title=".NET Framework">.NET Framework</a>) do not provide destructors and require manual deallocation of resources.</li>
<li>The performance impact (see above) caused by GC is seemingly random and hard to predict.</li>
</ul>
<p><a name="Reference_counting" id="Reference_counting"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=16" title="Edit section: Reference counting">edit</a>]</span> <span class="mw-headline">Reference counting</span></h2>
<div class="rellink noprint relarticle mainarticle">Main article: <a href="/wiki/Reference_counting" title="Reference counting">Reference counting</a></div>
<p>Reference counting is a form of automatic memory management where each object has a count of the number of references to it. An object's reference count is incremented when a reference to it is created, and decremented when a reference is destroyed. The object's memory is reclaimed when the count reaches zero.</p>
<p>There are two major disadvantages to reference counting:</p>
<ul>
<li>If two or more objects refer to each other, they can create a cycle whereby neither will be collected as their mutual references never let their reference counts become zero. Some garbage collection systems (like the one in <a href="/wiki/CPython" title="CPython">CPython</a>) using reference counting use specific cycle-detecting algorithms to deal with this issue.<sup id="cite_ref-6" class="reference"><a href="#cite_note-6" title=""><span>[</span>7<span>]</span></a></sup></li>
<li>In naïve implementations, each assignment of a reference and each reference falling out of scope often require modifications of one or more reference counters. However, optimizations to this are <a href="/wiki/Reference_counting#Dealing_with_inefficiency_of_updates" title="Reference counting">described in the literature</a>.<sup class="noprint Inline-Template"><span title="The text in the vicinity of this tag needs clarification or removal of jargon&#160;from September 2008" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Please_clarify" title="Wikipedia:Please clarify">clarification needed</a></i>]</span></sup> When used in a <a href="/wiki/Thread_(computing)" title="Thread (computing)" class="mw-redirect">multithreaded</a> environment, these modifications (increment and decrement) may need to be interlocked. This may be an expensive operation for processors without atomic operations such as <a href="/wiki/Compare-and-swap" title="Compare-and-swap">Compare-and-swap</a>.<sup class="noprint Template-Fact"><span title="This claim needs references to reliable sources&#160;since September 2008" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Citation_needed" title="Wikipedia:Citation needed">citation needed</a></i>]</span></sup></li>
</ul>
<p>One important advantage of reference counting is that it provides deterministic garbage collection (as opposed to tracing GC).</p>
<p><a name="Escape_analysis" id="Escape_analysis"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=17" title="Edit section: Escape analysis">edit</a>]</span> <span class="mw-headline">Escape analysis</span></h2>
<div class="rellink noprint relarticle mainarticle">Main article: <a href="/wiki/Escape_analysis" title="Escape analysis">Escape analysis</a></div>
<p><a href="/wiki/Escape_analysis" title="Escape analysis">Escape analysis</a> can be used to convert heap allocations to stack allocations, thus reducing the amount of work needed to be done by the garbage collector.</p>
<p><a name="Availability" id="Availability"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=18" title="Edit section: Availability">edit</a>]</span> <span class="mw-headline">Availability</span></h2>
<p>Generally speaking, <a href="/wiki/High-level_programming_language" title="High-level programming language">higher-level programming languages</a> are more likely to have garbage collection as a standard feature. In languages that do not have built in garbage collection, it can often be added through a library, as with the <a href="/wiki/Boehm_garbage_collector" title="Boehm garbage collector">Boehm garbage collector</a> for C and C++. This approach is not without drawbacks, such as changing object creation and destruction mechanisms.</p>
<p>Most <a href="/wiki/Functional_programming_language" title="Functional programming language" class="mw-redirect">functional programming languages</a>, such as <a href="/wiki/ML_programming_language" title="ML programming language" class="mw-redirect">ML</a>, <a href="/wiki/Haskell_(programming_language)" title="Haskell (programming language)">Haskell</a>, and <a href="/wiki/APL_(programming_language)" title="APL (programming language)">APL</a>, have garbage collection built in. <a href="/wiki/Lisp_programming_language" title="Lisp programming language" class="mw-redirect">Lisp</a>, which introduced <a href="/wiki/Functional_programming" title="Functional programming">functional programming</a>, is especially notable for introducing this mechanism.</p>
<p>Other dynamic languages, such as <a href="/wiki/Ruby_(programming_language)" title="Ruby (programming language)">Ruby</a> (but not <a href="/wiki/Perl" title="Perl">Perl</a>, or <a href="/wiki/PHP" title="PHP">PHP</a>, which use reference counting), also tend to use GC. Object-oriented programming languages such as <a href="/wiki/Smalltalk_programming_language" title="Smalltalk programming language" class="mw-redirect">Smalltalk</a>, <a href="/wiki/Java_(programming_language)" title="Java (programming language)">Java</a> and <a href="/wiki/ECMAScript" title="ECMAScript">ECMAScript</a> usually provide integrated garbage collection, a notable exception being <a href="/wiki/C%2B%2B" title="C++">C++</a>.</p>
<p>Historically, languages intended for beginners, such as <a href="/wiki/BASIC" title="BASIC">BASIC</a> and <a href="/wiki/Logo_(programming_language)" title="Logo (programming language)">Logo</a>, have often used garbage collection for variable-length data types, such as strings and lists, so as not to burden programmers with manual memory management. On early microcomputers, with their limited memory and slow processors, garbage collection could often cause apparently random, inexplicable pauses in the midst of program operation.</p>
<p><a name="Limited_environments" id="Limited_environments"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=19" title="Edit section: Limited environments">edit</a>]</span> <span class="mw-headline">Limited environments</span></h2>
<p>Garbage collection is rarely used on embedded or real-time systems because of the perceived need for very tight control over the use of limited resources. However, garbage collectors compatible with such limited environments have been developed. <sup id="cite_ref-7" class="reference"><a href="#cite_note-7" title=""><span>[</span>8<span>]</span></a></sup> The Microsoft <a href="/wiki/.NET_Micro_Framework" title=".NET Micro Framework">.NET Micro Framework</a> and <a href="/wiki/Java_Platform,_Micro_Edition" title="Java Platform, Micro Edition">Java Platform, Micro Edition</a> are embedded software platforms that, like their larger cousins, include garbage collection.</p>
<p><a name="See_also" id="See_also"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=20" title="Edit section: See also">edit</a>]</span> <span class="mw-headline">See also</span></h2>
<ul>
<li><a href="/wiki/Cheney%27s_algorithm" title="Cheney's algorithm">Cheney's algorithm</a></li>
<li><a href="/wiki/Memory_management" title="Memory management">Memory management</a></li>
<li><a href="/wiki/Reversible_computing" title="Reversible computing">Reversible computing</a></li>
<li><a href="/wiki/Memory_leak" title="Memory leak">Memory leak</a></li>
<li><a href="/wiki/Weak_reference" title="Weak reference">Weak reference</a></li>
</ul>
<p><a name="References" id="References"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=21" title="Edit section: References">edit</a>]</span> <span class="mw-headline">References</span></h2>
<div class="references-small references-column-count references-column-count-2" style="-moz-column-count:2; column-count:2;">
<ol class="references">
<li id="cite_note-0"><b><a href="#cite_ref-0" title="">^</a></b> <cite style="font-style:normal" class="web"><a href="http://portal.acm.org/citation.cfm?id=367177.367199" class="external text" title="http://portal.acm.org/citation.cfm?id=367177.367199" rel="nofollow">"Recursive functions of symbolic expressions and their computation by machine"</a>. Portal.acm.org<span class="printonly">. <a href="http://portal.acm.org/citation.cfm?id=367177.367199" class="external free" title="http://portal.acm.org/citation.cfm?id=367177.367199" rel="nofollow">http://portal.acm.org/citation.cfm?id=367177.367199</a></span><span class="reference-accessdate">. Retrieved on 2009-03-29</span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Recursive+functions+of+symbolic+expressions+and+their+computation+by+machine&amp;rft.atitle=&amp;rft.pub=Portal.acm.org&amp;rft_id=http%3A%2F%2Fportal.acm.org%2Fcitation.cfm%3Fid%3D367177.367199&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-1"><b><a href="#cite_ref-1" title="">^</a></b> Note that there is an ambiguity of terms, as theory often uses the terms <i>manual garbage collection</i> and <i>automatic garbage collection</i> rather than <i>manual memory management</i> and <i>garbage collection</i>, and does not restrict garbage collection to <a href="/wiki/Memory_management" title="Memory management">memory management</a>, rather considering that any logical or physical <a href="/wiki/Resource_(computer_science)" title="Resource (computer science)">resource</a> may be garbage collected.</li>
<li id="cite_note-2"><b><a href="#cite_ref-2" title="">^</a></b> Maebe, Ronsse, and De Bosschere, "Precise detection of memory leaks." <a href="http://www.cs.virginia.edu/woda2004/papers/maebe.pdf" class="external free" title="http://www.cs.virginia.edu/woda2004/papers/maebe.pdf" rel="nofollow">http://www.cs.virginia.edu/woda2004/papers/maebe.pdf</a></li>
<li id="cite_note-3"><b><a href="#cite_ref-3" title="">^</a></b> <a href="http://msdn2.microsoft.com/en-us/library/23acw07k.aspx" class="external autonumber" title="http://msdn2.microsoft.com/en-us/library/23acw07k.aspx" rel="nofollow">[1]</a><sup class="noprint Inline-Template"><span title="&#160;since March 2009" style="white-space: nowrap;">[<i><a href="/wiki/Wikipedia:Dead_external_links" title="Wikipedia:Dead external links">dead link</a></i>]</span></sup></li>
<li id="cite_note-4"><b><a href="#cite_ref-4" title="">^</a></b> <cite style="font-style:normal" class="web"><a href="http://www.eros-os.org/pipermail/cap-talk/2007-January/006795.html" class="external text" title="http://www.eros-os.org/pipermail/cap-talk/2007-January/006795.html" rel="nofollow">"Memory allocation in embedded systems"</a>. Eros-os.org<span class="printonly">. <a href="http://www.eros-os.org/pipermail/cap-talk/2007-January/006795.html" class="external free" title="http://www.eros-os.org/pipermail/cap-talk/2007-January/006795.html" rel="nofollow">http://www.eros-os.org/pipermail/cap-talk/2007-January/006795.html</a></span><span class="reference-accessdate">. Retrieved on 2009-03-29</span>.</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Memory+allocation+in+embedded+systems&amp;rft.atitle=&amp;rft.pub=Eros-os.org&amp;rft_id=http%3A%2F%2Fwww.eros-os.org%2Fpipermail%2Fcap-talk%2F2007-January%2F006795.html&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-5"><b><a href="#cite_ref-5" title="">^</a></b> <a href="http://blogs.msdn.com/brada/articles/371015.aspx" class="external text" title="http://blogs.msdn.com/brada/articles/371015.aspx" rel="nofollow">Resource management</a> Blog entry by Brad Abrams. Retrieved 2009-03-27.</li>
<li id="cite_note-6"><b><a href="#cite_ref-6" title="">^</a></b> <cite style="font-style:normal" class="web"><a href="http://www.python.org/doc/2.5.2/ext/refcounts.html" class="external text" title="http://www.python.org/doc/2.5.2/ext/refcounts.html" rel="nofollow">"Reference Counts"</a>. <i>Extending and Embedding the Python Interpreter</i>. 2008-02-21<span class="printonly">. <a href="http://www.python.org/doc/2.5.2/ext/refcounts.html" class="external free" title="http://www.python.org/doc/2.5.2/ext/refcounts.html" rel="nofollow">http://www.python.org/doc/2.5.2/ext/refcounts.html</a></span><span class="reference-accessdate">. Retrieved on 2008-11-13</span>.  "While Python uses the traditional reference counting implementation, it also offers a cycle detector that works to detect reference cycles."</cite><span class="Z3988" title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.btitle=Reference+Counts&amp;rft.atitle=Extending+and+Embedding+the+Python+Interpreter&amp;rft.date=2008-02-21&amp;rft_id=http%3A%2F%2Fwww.python.org%2Fdoc%2F2.5.2%2Fext%2Frefcounts.html&amp;rfr_id=info:sid/en.wikipedia.org:Garbage_collection_(computer_science)"><span style="display: none;">&#160;</span></span></li>
<li id="cite_note-7"><b><a href="#cite_ref-7" title="">^</a></b> Wei Fu and Carl Hauser, "A Real-Time Garbage Collection Framework for Embedded Systems". ACM SCOPES '05, 2005. <a href="http://portal.acm.org/ft_gateway.cfm?id=1140392&amp;type=pdf&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=15151515&amp;CFTOKEN=6184618" class="external free" title="http://portal.acm.org/ft_gateway.cfm?id=1140392&amp;type=pdf&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=15151515&amp;CFTOKEN=6184618" rel="nofollow">http://portal.acm.org/ft_gateway.cfm?id=1140392&amp;type=pdf&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=15151515&amp;CFTOKEN=6184618</a></li>
</ol>
</div>
<p><a name="External_links" id="External_links"></a></p>
<h2><span class="editsection">[<a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit&amp;section=22" title="Edit section: External links">edit</a>]</span> <span class="mw-headline">External links</span></h2>
<ul>
<li><a href="http://www.academicresourcecenter.net/curriculum/pfv.aspx?ID=6182" class="external text" title="http://www.academicresourcecenter.net/curriculum/pfv.aspx?ID=6182" rel="nofollow">A Garbage Collection Course Curriculum at MSDN Academic Alliance</a></li>
<li><a href="http://www.cs.utexas.edu/users/oops/papers.html" class="external text" title="http://www.cs.utexas.edu/users/oops/papers.html" rel="nofollow">Publications by the OOPS group</a> at the <a href="/wiki/University_of_Texas_at_Austin" title="University of Texas at Austin">University of Texas at Austin</a></li>
<li><a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/" class="external text" title="http://www.hpl.hp.com/personal/Hans_Boehm/gc/" rel="nofollow">A garbage collector for C and C++</a> by Hans Boehm</li>
<li><a href="http://vineetgupta.spaces.live.com/blog/cns!8DE4BDC896BEE1AD!1104.entry" class="external text" title="http://vineetgupta.spaces.live.com/blog/cns!8DE4BDC896BEE1AD!1104.entry" rel="nofollow">Notes on the CLR Garbage Collector</a></li>
<li><a href="http://www.osnews.com/story.php?news_id=6864" class="external text" title="http://www.osnews.com/story.php?news_id=6864" rel="nofollow">A Glance At Garbage Collection In Object-Oriented Languages</a></li>
<li><a href="http://www.cs.utexas.edu/users/EWD/ewd05xx/EWD595.PDF" class="external text" title="http://www.cs.utexas.edu/users/EWD/ewd05xx/EWD595.PDF" rel="nofollow">On-the-fly garbage collection: an exercise in cooperation</a> by <a href="/wiki/Edsger_W._Dijkstra" title="Edsger W. Dijkstra">Edsger W. Dijkstra</a> and <a href="/wiki/Leslie_Lamport" title="Leslie Lamport">Leslie Lamport</a> and A.J.Martin and C.S.Scholten and E.F.M.Steffens</li>
<li>Richard Jones and Rafael Lins, <i>Garbage Collection: Algorithms for Automatic Dynamic Memory Management</i>, Wiley and Sons (1996), <a href="/wiki/Special:BookSources/0471941484" class="internal">ISBN 0-471-94148-4</a></li>
<li><a href="http://www.cs.kent.ac.uk/people/staff/rej/gc.html" class="external text" title="http://www.cs.kent.ac.uk/people/staff/rej/gc.html" rel="nofollow">Richard Jones' Garbage Collection Page</a></li>
<li><a href="http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html" class="external text" title="http://web.media.mit.edu/~lieber/Lieberary/GC/Realtime/Realtime.html" rel="nofollow">A Real-Time Garbage Collector Based on the Lifetimes of Objects</a> by H. Lieberman and C. Hewitt, MIT Artificial Intelligence Laboratory</li>
</ul>


<!-- 
NewPP limit report
Preprocessor node count: 1805/1000000
Post-expand include size: 20025/2048000 bytes
Template argument size: 7660/2048000 bytes
Expensive parser function count: 6/500
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:6734-0!1!0!default!!en!2 and timestamp 20090403181456 -->
<div class="printfooter">
Retrieved from "<a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/wiki/Special:Categories" title="Special:Categories">Categories</a>:&#32;<span dir='ltr'><a href="/wiki/Category:Memory_management" title="Category:Memory management">Memory management</a></span> | <span dir='ltr'><a href="/wiki/Category:Garbage_collection_(computer_science)" title="Category:Garbage collection (computer science)">Garbage collection (computer science)</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_example_code" title="Category:Articles with example code">Articles with example code</a></span></div><div id="mw-hidden-catlinks" class="mw-hidden-cats-hidden">Hidden categories:&#32;<span dir='ltr'><a href="/wiki/Category:All_articles_with_dead_external_links" title="Category:All articles with dead external links">All articles with dead external links</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_dead_external_links_since_March_2009" title="Category:Articles with dead external links since March 2009">Articles with dead external links since March 2009</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_needing_additional_references_from_January_2008" title="Category:Articles needing additional references from January 2008">Articles needing additional references from January 2008</a></span> | <span dir='ltr'><a href="/wiki/Category:All_articles_with_unsourced_statements" title="Category:All articles with unsourced statements">All articles with unsourced statements</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_unsourced_statements_since_June_2007" title="Category:Articles with unsourced statements since June 2007">Articles with unsourced statements since June 2007</a></span> | <span dir='ltr'><a href="/wiki/Category:Articles_with_unsourced_statements_since_September_2008" title="Category:Articles with unsourced statements since September 2008">Articles with unsourced statements since September 2008</a></span> | <span dir='ltr'><a href="/wiki/Category:All_pages_needing_cleanup" title="Category:All pages needing cleanup">All pages needing cleanup</a></span> | <span dir='ltr'><a href="/wiki/Category:Wikipedia_articles_needing_clarification_from_September_2008" title="Category:Wikipedia articles needing clarification from September 2008">Wikipedia articles needing clarification from September 2008</a></span></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div>
		<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/wiki/Garbage_collection_(computer_science)" title="View the content page [c]" accesskey="c">Article</a></li>
				 <li id="ca-talk"><a href="/wiki/Talk:Garbage_collection_(computer_science)" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				 <li id="ca-edit"><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=edit" title="You can edit this page. &#10;Please use the preview button before saving. [e]" accesskey="e">Edit this page</a></li>
				 <li id="ca-history"><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;action=history" title="Past versions of this page [h]" accesskey="h">History</a></li>			</ul>
		</div>
	</div>
	<div class="portlet" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Garbage_collection_(computer_science)" title="You are encouraged to log in; however, it is not mandatory. [o]" accesskey="o">Log in / create account</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a style="background-image: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png);" href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li>
				<li id="n-contents"><a href="/wiki/Portal:Contents" title="Guides to browsing Wikipedia">Contents</a></li>
				<li id="n-featuredcontent"><a href="/wiki/Portal:Featured_content" title="Featured content — the best of Wikipedia">Featured content</a></li>
				<li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li>
				<li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">Search</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/w/index.php" id="searchform"><div>
				<input type='hidden' name="title" value="Special:Search"/>
				<input id="searchInput" name="search" type="text" title="Search Wikipedia [f]" accesskey="f" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" title="Go to a page with this exact name if one exists" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" title="Search Wikipedia for this text" />
			</div></form>
		</div>
	</div>
	<div class='generated-sidebar portlet' id='p-interaction'>
		<h5>Interaction</h5>
		<div class='pBody'>
			<ul>
				<li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li>
				<li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li>
				<li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="The list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
				<li id="n-contact"><a href="/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact Wikipedia</a></li>
				<li id="n-sitesupport"><a href="http://wikimediafoundation.org/wiki/Donate" title="Support us">Donate to Wikipedia</a></li>
				<li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Garbage_collection_(computer_science)" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Garbage_collection_(computer_science)" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
<li id="t-upload"><a href="/wiki/Wikipedia:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li>
<li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="List of all special pages [q]" accesskey="q">Special pages</a></li>
				<li id="t-print"><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>				<li id="t-permalink"><a href="/w/index.php?title=Garbage_collection_(computer_science)&amp;oldid=281543359" title="Permanent link to this version of the page">Permanent link</a></li><li id="t-cite"><a href="/w/index.php?title=Special:Cite&amp;page=Garbage_collection_(computer_science)&amp;id=281543359">Cite this page</a></li>			</ul>
		</div>
	</div>
	<div id="p-lang" class="portlet">
		<h5>Languages</h5>
		<div class="pBody">
			<ul>
				<li class="interwiki-ar"><a href="http://ar.wikipedia.org/wiki/%D8%AC%D9%85%D8%B9_%D8%A7%D9%84%D9%82%D9%85%D8%A7%D9%85%D8%A9">العربية</a></li>
				<li class="interwiki-cs"><a href="http://cs.wikipedia.org/wiki/Garbage_collector">Česky</a></li>
				<li class="interwiki-de"><a href="http://de.wikipedia.org/wiki/Garbage_Collection">Deutsch</a></li>
				<li class="interwiki-es"><a href="http://es.wikipedia.org/wiki/Recolecci%C3%B3n_de_basura">Español</a></li>
				<li class="interwiki-fr"><a href="http://fr.wikipedia.org/wiki/Ramasse-miettes_(informatique)">Français</a></li>
				<li class="interwiki-ko"><a href="http://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%A0%84%EC%82%B0%ED%95%99)">한국어</a></li>
				<li class="interwiki-id"><a href="http://id.wikipedia.org/wiki/Pengumpulan_sampah">Bahasa Indonesia</a></li>
				<li class="interwiki-it"><a href="http://it.wikipedia.org/wiki/Garbage_collection">Italiano</a></li>
				<li class="interwiki-he"><a href="http://he.wikipedia.org/wiki/%D7%90%D7%99%D7%A1%D7%95%D7%A3_%D7%96%D7%91%D7%9C_(%D7%AA%D7%9B%D7%A0%D7%95%D7%AA)">עברית</a></li>
				<li class="interwiki-lt"><a href="http://lt.wikipedia.org/wiki/%C5%A0iuk%C5%A1li%C5%B3_surinktuvas">Lietuvių</a></li>
				<li class="interwiki-hu"><a href="http://hu.wikipedia.org/wiki/Garbage_collection">Magyar</a></li>
				<li class="interwiki-nl"><a href="http://nl.wikipedia.org/wiki/Garbage_collection">Nederlands</a></li>
				<li class="interwiki-ja"><a href="http://ja.wikipedia.org/wiki/%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3">日本語</a></li>
				<li class="interwiki-pl"><a href="http://pl.wikipedia.org/wiki/Garbage_collection">Polski</a></li>
				<li class="interwiki-pt"><a href="http://pt.wikipedia.org/wiki/Coletor_de_lixo">Português</a></li>
				<li class="interwiki-ru"><a href="http://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0">Русский</a></li>
				<li class="interwiki-fi"><a href="http://fi.wikipedia.org/wiki/Automaattinen_roskienker%C3%A4ys">Suomi</a></li>
				<li class="interwiki-sv"><a href="http://sv.wikipedia.org/wiki/Skr%C3%A4psamling">Svenska</a></li>
				<li class="interwiki-uk"><a href="http://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%B1%D0%B8%D1%80%D0%B0%D0%BD%D0%BD%D1%8F_%D1%81%D0%BC%D1%96%D1%82%D1%82%D1%8F">Українська</a></li>
				<li class="interwiki-zh"><a href="http://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">中文</a></li>
			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="http://www.mediawiki.org/"><img src="/skins-1.5/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" /></a></div>
				<div id="f-copyrightico"><a href="http://wikimediafoundation.org/"><img src="/images/wikimedia-button.png" border="0" alt="Wikimedia Foundation"/></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 3 April 2009, at 18:14.</li>
					<li id="copyright">All text is available under the terms of the <a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License" title="Wikipedia:Text of the GNU Free Documentation License">GNU Free Documentation License</a>. (See <b><a class='internal' href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights" title="Wikipedia:Copyrights">Copyrights</a></b> for details.) <br /> Wikipedia&reg; is a registered trademark of the <a href="http://www.wikimediafoundation.org">Wikimedia Foundation, Inc.</a>, a U.S. registered <a class='internal' href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29" title="501(c)(3)">501(c)(3)</a> <a href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</a> <a class='internal' href="http://en.wikipedia.org/wiki/Non-profit_organization" title="Non-profit organization">nonprofit</a> <a href="http://en.wikipedia.org/wiki/Charitable_organization" title="Charitable organization">charity</a>.<br /></li>
					<li id="privacy"><a href="http://wikimediafoundation.org/wiki/Privacy_policy" title="wikimedia:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
					<li id="disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>

		<script type="text/javascript">if (window.runOnloadHook) runOnloadHook();</script>
<!-- Served by srv180 in 0.059 secs. --></body></html>
